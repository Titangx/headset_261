
/home/svc-audio-dspsw/kymera_builds/builds/2021/kymera_2103100121/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_volume_control.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_vol_ctrl_update_channel>:
.MODULE $M.vol_ctrl_update_channel;
    .MAXIM;
    .CODESEGMENT VOL_CTRL_UPD_CHAN_PM;

$_vol_ctrl_update_channel:
    pushm <r4,r5,r6,r7,r8,r9>;
84200000:	c0 0f 00 f1 	pushm <r4, r5, r6, r7, r8, r9>;
    pushm <I0,I1,I4,I5,M3,L0,L4,L5>;
84200004:	33 d8 01 f1 	pushm <I0, I1, I4, I5, M3, L0, L4, L5>;
    pushm <B0,B4,B5>;
84200008:	00 34 02 f1 	pushm <B0, B4, B5>;
    pushm <FP(=SP),r0,r1,r2,r3,rLink>;
8420000c:	3d 20 00 f1 	pushm <FP(=SP), r0, r1, r2, r3, rLink>;

   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_channel.PATCH_ID_0, r7)

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200010:	5c 00 92 d1 	r7 = M[r0 + 92];
    if LE jump vol_ctrl_apply_volume_abort;
84200014:	72 01 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort;

    // Enable saturate on add/sub
    r4 = M[$ARITHMETIC_MODE];
84200018:	14 e0 60 09 	r4 = Null + M[0xffffe014];
    push r4;
8420001c:	00 00 60 f3 	push r4;
    r4 = r4 OR $ADDSUB_SATURATE_ON_OVERFLOW_MASK;
84200020:	01 00 66 85 	r4 = r4 OR 0x1;
    M[$ARITHMETIC_MODE] = r4;
84200024:	14 e0 60 19 	M[0xffffe014] = r4 + Null;


    /* Update Channel for AUX stream priority.   */
    /* op_extra_data->aux_in_use  = 0; */
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD] = NULL;
84200028:	e8 02 02 d5 	M[r0 + 744] = Null;

8420002c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_next>:
        {
            vol_ctrl_update_channel(op_extra_data,&op_extra_data->channels[i],op_extra_data->lpvols,&volume_tc);
        }
    */
vol_ctrl_update_channel_next:
    push r7;
8420002c:	00 00 90 f3 	push r7;
// r1: vol_ctrl_channel_t   *chan_ptr
// r2: vol_ctrl_gains_t     *volptr
// r3: vol_time_constants_t *lpvcs


    r4 = 1.0;
84200030:	ff 7f 00 fd 	r4 = Null + 2147483647;
84200034:	ff ff 60 01 
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]=r4;
84200038:	10 00 63 d5 	M[r1 + 16] = r4;
    // chan_idx
    r4 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420003c:	00 00 63 d1 	r4 = M[r1 + 0];
    // target_vol (r5) = volptr->master_gain;
    r5 = M[r2 + $volume_control_cap.vol_ctrl_gains_struct.MASTER_GAIN_FIELD];
84200040:	00 00 74 d1 	r5 = M[r2 + 0];
    // channel_trim (r6) = volptr->channel_trims[chan_ptr->chan_idx];
    r6 = r4 * ADDR_PER_WORD (int);
84200044:	04 00 86 99 	r6 = r4 * 4 (int);
    r6 = r6 + $volume_control_cap.vol_ctrl_gains_struct.CHANNEL_TRIMS_FIELD;
84200048:	28 00 88 01 	r6 = r6 + 40;
    r6 = M[r2 + r6];
8420004c:	8f 00 84 d0 	r6 = M[r2 + r6];
    // chan_params (r7) = (vol_ctrl_chan_params_t*)&op_extra_data->parameters.OFFSET_CHAN1_AUX_ROUTE;
    // aux_routing (r9) = chan_params[chan_ptr->chan_idx].aux_routing;
    r8 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
84200050:	f4 01 a2 01 	r8 = r0 + 500;
    r7 = r4 * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200054:	14 00 96 99 	r7 = r4 * 20 (int);
    r7 = r7 + r8;
84200058:	00 00 9a 03 	r7 = r7 + r8;
    r9 = M[r7 + $volume_control_cap.vol_ctrl_chan_params_struct.AUX_ROUTING_FIELD];
8420005c:	00 00 b9 d1 	r9 = M[r7 + 0];
    // Pointer (I0) to Channel Aux prim_scale factors
    I0 = r7 + $volume_control_cap.vol_ctrl_chan_params_struct.PRIM_SCALE_FIELD;
84200060:	04 00 09 51 	I0 = r7 + 4;

    // Conditionally add in NDVC adjustment
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.CHAN_NDVC_ENABLE_BIT;
84200064:	10 00 00 fd 	Null = r9 AND 0x100000;
84200068:	00 00 0b 81 
    if Z jump vol_ctrl_update_channel_no_ndvc;
8420006c:	05 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc;
        r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
84200070:	8c 01 a2 d1 	r8 = M[r0 + 396];
        r8 = M[r8 + $volume_control_cap._shared_volume_struct.NDVC_NOISE_LEVEL_FIELD];
84200074:	00 00 aa d1 	r8 = M[r8 + 0];
	    /* NDVC is in 3dB steps */
        r8 = r8 * 180 (int);
84200078:	b4 00 aa 99 	r8 = r8 * 180 (int);
        r6 = r6 + r8;
8420007c:	00 00 8a 03 	r6 = r6 + r8;

84200080 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc>:
    vol_ctrl_update_channel_no_ndvc:

   /* Bypass Aux */
   NULL = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD];
84200080:	e0 02 02 d1 	Null = M[r0 + 736];
   if Z r9 = NULL;
84200084:	00 00 b0 00 	if EQ r9 = Null + Null;

    // channel_trim -= op_extra_data->post_gain;
    r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.POST_GAIN_FIELD];
84200088:	f4 00 a2 d1 	r8 = M[r0 + 244];
    r6 = r6 - r8;
8420008c:	00 00 8a 23 	r6 = r6 - r8;
    // target_vol = dB60toLinearQ5(target_vol+channel_trim);
    r0 = r6 + r5;
84200090:	7f 00 28 00 	r0 = r6 + r5;
    call $_dB60toLinearQ5;
84200094:	03 00 00 fd 	call (m) 0x37fbe;
84200098:	bf 7f f0 e1 

    // Update Channel Gain (r0 is target)
    r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
8420009c:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842000a0:	18 00 43 d1 	r2 = M[r1 + 24];

    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
842000a4:	10 00 58 f1 	r3 = M[FP + 0x10];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD];
842000a8:	04 00 55 d1 	r3 = M[r3 + 4];

    r8 = r0 - r2;
842000ac:	4f 00 a2 20 	r8 = r0 - r2;
    if Z jump vol_ctrl_update_channel_no_vol_change;
842000b0:	09 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change;
        r8 = ABS r8;
842000b4:	4f 00 aa e4 	r8 = ABS r8;
        r3 = r2 * r3 (frac);
842000b8:	5f 00 54 94 	r3 = r2 * r3 (frac);
        r3 = r3 + $volume_and_limit.VOLUME_RAMP_OFFSET_CONST;
842000bc:	6e 34 55 01 	r3 = r3 + 13422;
        r3 = MIN r8;
842000c0:	5f 00 5a e4 	r3 = MIN r8;
        Null = r0 - r2;
842000c4:	4f 00 02 20 	Null = r0 - r2;
        if NEG r3 = -r3;
842000c8:	54 00 50 20 	if NEG r3 = Null - r3;
        r2 = r2 + r3;
842000cc:	00 00 45 03 	r2 = r2 + r3;
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD] = r2;
842000d0:	18 00 43 d5 	M[r1 + 24] = r2;

842000d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change>:
    vol_ctrl_update_channel_no_vol_change:

     r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842000d4:	04 00 28 f1 	r0 = M[FP + 0x4];
     r0 = r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
842000d8:	6c 00 22 01 	r0 = r0 + 108;

// r9=routing, r1=chan_ptr, I0=prim_scale, r0=aux_chan_ptr, r6=chan_trim, r4=chan_idx

    /* Check each aux in channel priority */
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = NULL;
842000dc:	04 00 03 d5 	M[r1 + 4] = Null;
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD]    = NULL;
842000e0:	20 00 03 d5 	M[r1 + 32] = Null;

842000e4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp>:

    // while(aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_VALID_BIT)
vol_ctrl_update_channel_aux_prio_lp:
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
842000e4:	10 00 0b 81 	Null = r9 AND 0x10;
    if NZ jump vol_ctrl_update_channel_aux_prio_valid;
842000e8:	05 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid;
        // There is no AUX
        r2 = $volume_and_limit.OneQ5;
842000ec:	00 08 00 fd 	r2 = Null + 134217728;
842000f0:	00 00 40 01 
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD]      = r2;
842000f4:	08 00 43 d5 	M[r1 + 8] = r2;
        jump vol_ctrl_update_channel_aux_prio_done;
842000f8:	37 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

842000fc <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid>:
vol_ctrl_update_channel_aux_prio_valid:
        // aux_idx =  aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_CHANNEL_MASK;
        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
842000fc:	07 00 7b 81 	r5 = r9 AND 0x7;
        // op_extra_data->aux_channel[aux_idx].state
        r8 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200100:	10 00 a7 99 	r8 = r5 * 16 (int);
        r8 = r8 + r0,   r3=M[I0,M1];    // r3 = prim_scale
84200104:	00 51 a2 02 	r8 = r8 + r0, r3 = M[I0,M1];
        r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200108:	04 00 9a d1 	r7 = M[r8 + 4];
        if NZ jump vol_ctrl_update_channel_aux_prio_found;
8420010c:	03 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found;
            // NO_AUX, Try Next entry
            r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200110:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
            jump vol_ctrl_update_channel_aux_prio_lp;
84200114:	f4 ff f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp;

84200118 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found>:
vol_ctrl_update_channel_aux_prio_found:
        NULL = r7 - $volume_control_cap.AUX_STATE_IN_AUX;
84200118:	cf 00 09 e4 	Null = r7 - 2;
        if Z jump vol_ctrl_update_channel_aux_prio_in_aux;
8420011c:	16 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux;
    	    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
84200120:	08 00 43 d1 	r2 = M[r1 + 8];

            NULL = r7 - $volume_control_cap.AUX_STATE_END_AUX;
84200124:	03 00 09 21 	Null = r7 - 3;
            if NZ jump vol_ctrl_update_channel_aux_prio_transition;
84200128:	0d 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;
                // Leaving AUX mix,  see if a lower priority aux is pending
                r3 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
8420012c:	08 00 53 d1 	r3 = M[r1 + 8];

84200130 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp>:
                vol_ctrl_update_channel_aux_prio_prev_lp:
                    r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200130:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
                    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
84200134:	10 00 0b 81 	Null = r9 AND 0x10;
                    if Z jump vol_ctrl_update_channel_aux_prio_prev_none;
84200138:	07 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none;
                        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
8420013c:	07 00 7b 81 	r5 = r9 AND 0x7;
                        r5 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200140:	10 00 77 99 	r5 = r5 * 16 (int);
                        r5 = r5 + r0,   r2=M[I0,M1];    // r3 = prim_scale
84200144:	00 41 72 02 	r5 = r5 + r0, r2 = M[I0,M1];
                        r7 = M[r5 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200148:	04 00 97 d1 	r7 = M[r5 + 4];
                        if Z jump vol_ctrl_update_channel_aux_prio_prev_lp;
8420014c:	f9 ff 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp;
                        jump vol_ctrl_update_channel_aux_prio_transition;
84200150:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;

84200154 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none>:
                vol_ctrl_update_channel_aux_prio_prev_none:
                r2 = $volume_and_limit.OneQ5;
84200154:	00 08 00 fd 	r2 = Null + 134217728;
84200158:	00 00 40 01 

8420015c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition>:

            vol_ctrl_update_channel_aux_prio_transition:
            // transition = op_extra_data->aux_channel[aux_idx].transition;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
8420015c:	08 00 9a d1 	r7 = M[r8 + 8];
            // chan_ptr->prim_mix_gain = (MAXINT-transition)*Q5.xx + chan_params->prim_scale[chan_ptr->chan_idx]*transition;
            rMAC = r2;              // r2=1.0  Q5.xx
84200160:	0f 00 14 00 	rMAC = r2 + Null;
            rmAC = rMAC - r7*r2;
84200164:	4f 00 19 bc 	rMAC = rMAC - r7 * r2 (SS);
            rMAC = rMAC + r7*r3;
84200168:	5f 00 19 ac 	rMAC = rMAC + r7 * r3 (SS);
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = rMAC;
8420016c:	08 00 13 d5 	M[r1 + 8] = rMAC;
            jump vol_ctrl_update_channel_aux_prio_done;
84200170:	19 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

84200174 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux>:
        vol_ctrl_update_channel_aux_prio_in_aux:
            // Transition is complete, in aux
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = r3;
84200174:	08 00 53 d5 	M[r1 + 8] = r3;

            // Check if aux mix not muted
            NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_MUTE_BIT;
84200178:	08 00 0b 81 	Null = r9 AND 0x8;
            if NZ jump vol_ctrl_update_channel_aux_prio_done;
8420017c:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;
            // chan_ptr->aux_buffer       = op_extra_data->aux_channel[aux_idx].buffer;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.BUFFER_FIELD];
84200180:	00 00 9a d1 	r7 = M[r8 + 0];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD] = r7;
84200184:	20 00 93 d5 	M[r1 + 32] = r7;

            // r5=aux_idx, r1=chan_ptr, r6=chan_trim, r4 = chan_idx
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
84200188:	04 00 28 f1 	r0 = M[FP + 0x4];

            // aux_in_use |= (1<<aux_idx);
            r2 = 1 LSHIFT r5;
8420018c:	01 00 47 e9 	r2 = 0x1 LSHIFT r5;
            r3 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD];
84200190:	e8 02 52 d1 	r3 = M[r0 + 744];
            r3 = r3 OR r2;
84200194:	00 00 54 87 	r3 = r3 OR r2;
            M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD]=r3;
84200198:	e8 02 52 d5 	M[r0 + 744] = r3;

            // aux_params = (vol_ctrl_aux_params_t*)&op_extra_data->parameters.OFFSET_AUX1_SCALE;
            // aux_volume = aux_params[aux_idx].aux_scale;
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
8420019c:	04 00 28 f1 	r0 = M[FP + 0x4];
            r0 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
842001a0:	94 01 22 01 	r0 = r0 + 404;
            r2 = r5 * ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
842001a4:	0c 00 47 99 	r2 = r5 * 12 (int);
            r0 = M[r0 + r2];
842001a8:	00 00 24 d3 	r0 = M[r0 + r2];
            // aux_volume += op_extra_data->lpvols->auxiliary_gain[aux_idx];
            r3 = M[FP + $vol_ctrl.cufp.vol_ptr];
842001ac:	0c 00 58 f1 	r3 = M[FP + 0xc];
            r2 = r5 * ADDR_PER_WORD (int);
842001b0:	04 00 47 99 	r2 = r5 * 4 (int);
            r3 = r3 + r2;
842001b4:	00 00 54 03 	r3 = r3 + r2;
            r3 = M[r3 + $volume_control_cap.vol_ctrl_gains_struct.AUXILIARY_GAIN_FIELD];
842001b8:	08 00 55 d1 	r3 = M[r3 + 8];
            r0 = r0 + r3;
842001bc:	00 00 25 03 	r0 = r0 + r3;
            // chan_ptr->aux_mix_gain  = dB60toLinearQ5(aux_volume+channel_trim);
            r0 = r0 + r6;
842001c0:	00 00 28 03 	r0 = r0 + r6;
            call $_dB60toLinearQ5;
842001c4:	03 00 00 fd 	call (m) 0x37fbe;
842001c8:	bf 7f f0 e1 
            r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001cc:	08 00 38 f1 	r1 = M[FP + 0x8];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = r0;
842001d0:	04 00 23 d5 	M[r1 + 4] = r0;

842001d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done>:

vol_ctrl_update_channel_aux_prio_done:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842001d4:	04 00 28 f1 	r0 = M[FP + 0x4];

    // r4=chan_idx, r0=op_data_ptr

    // limiter_attn = 0;
    r5 = NULL;
842001d8:	0f 00 70 00 	r5 = Null + Null;

    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842001dc:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842001e0:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_channel_sat_done;
842001e4:	29 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;
    r7 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001e8:	08 00 98 f1 	r7 = M[FP + 0x8];
    r8 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842001ec:	18 00 a9 d1 	r8 = M[r7 + 24];
    NULL = r8 - $volume_and_limit.MIN_POSITIVE_VOLUME;
842001f0:	00 08 00 fd 	Null = r8 - 134217728;
842001f4:	00 00 0a 21 
    if LE jump vol_ctrl_update_channel_sat_done;
842001f8:	24 00 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        // Get Data Buffer
        r6 = r4 * ADDR_PER_WORD (int);
842001fc:	04 00 86 99 	r6 = r4 * 4 (int);
        r6 = r6 + $volume_control_cap._vol_ctrl_data_struct.INPUT_BUFFER_FIELD;
84200200:	00 00 88 01 	r6 = r6 + 0;
        r0 = M[r0 + r6];
84200204:	00 00 28 d3 	r0 = M[r0 + r6];
        call $cbuffer.get_read_address_and_size_and_start_address;
84200208:	03 00 00 fd 	call (m) 0x3a27a;
8420020c:	7b a2 f0 e1 
        I0 = r0;
84200210:	2f 00 00 50 	I0 = Null + r0;
        L0 = r1;
84200214:	3f 00 c0 50 	L0 = Null + r1;
        push r2;
84200218:	00 00 40 f3 	push r2;
        pop B0;
8420021c:	00 00 a6 f3 	pop B0;

        // Compute Peak
        r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200220:	10 00 58 f1 	r3 = M[FP + 0x10];
        r10 = M[r3+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84200224:	00 00 c5 d1 	r10 = M[r3 + 0];
        r2 = M[r3+$volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200228:	0c 00 45 d1 	r2 = M[r3 + 12];
        r3 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD];
8420022c:	14 00 59 d1 	r3 = M[r7 + 20];
        r10 = r10 - 1;
84200230:	3f 00 cc e4 	r10 = r10 - 1;
        // Use history for peak but decay it based on num samples
        r3 = r3 * r2 (frac), r2=M[I0,M1];
84200234:	00 41 54 96 	r3 = r3 * r2 (frac), r2 = M[I0,M1];
        do vol_ctrl_update_channel_peak_lp;
84200238:	03 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp;
            r2 = ABS r2;
8420023c:	4f 00 44 e4 	r2 = ABS r2;
            r3 = MAX r2, r2=M[I0,M1];
84200240:	6f 41 54 e4 	r3 = MAX r2, r2 = M[I0,M1];

84200244 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp>:
        vol_ctrl_update_channel_peak_lp:
        r2 = ABS r2;
84200244:	4f 00 44 e4 	r2 = ABS r2;
        r3 = MAX r2;
84200248:	6f 00 54 e4 	r3 = MAX r2;
        M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD]=r3;
8420024c:	14 00 59 d5 	M[r7 + 20] = r3;

        // max_abs = MAX(ABS(channel data)) * chan_ptr->channel_gain;
        rMAC = r3 * r8;
84200250:	af 00 15 cc 	rMAC = r3 * r8 (SS);

        r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200254:	04 00 28 f1 	r0 = M[FP + 0x4];
        r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LINEAR_FIELD)];
84200258:	a4 02 32 d1 	r1 = M[r0 + 676];
        NULL = rMAC - r1;
8420025c:	3f 00 01 20 	Null = rMAC - r1;
        if NEG jump vol_ctrl_update_channel_sat_done;
84200260:	0a 00 40 dd 	if NEG jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        r7 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_ADAPTATION_RATIO_FIELD)];
84200264:	a8 02 92 d1 	r7 = M[r0 + 680];
        r9 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LOG_FIELD)];
84200268:	ac 02 b2 d1 	r9 = M[r0 + 684];

        // limiter_attn = (LIMIT_THRESHOLD - log2(max_abs)) * LIMIT_RATIO;
        call $math.log2_table;
8420026c:	07 00 00 fd 	call 0x745ac;
84200270:	ac 45 f0 e1 
        /* Input to log was Q5.xx,  need to adjust to Q1.xx */
        r0 = r0 + (4<<(DAWTH-8));
84200274:	00 04 00 fd 	r0 = r0 + 67108864;
84200278:	00 00 22 01 
        r9 = r9 - r0;
8420027c:	00 00 b2 23 	r9 = r9 - r0;
        r5 = r9 * r7 (frac);
84200280:	9f 00 7b 94 	r5 = r9 * r7 (frac);
        if POS r5=NULL;
84200284:	05 00 70 00 	if POS r5 = Null + Null;

84200288 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done>:
vol_ctrl_update_channel_sat_done:

    // Time constants are scaled based on num samples
    r1 = M[FP+$vol_ctrl.cufp.chan_ptr];
84200288:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD];
8420028c:	0c 00 43 d1 	r2 = M[r1 + 12];
    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200290:	10 00 58 f1 	r3 = M[FP + 0x10];
    r4 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD];
84200294:	08 00 65 d1 	r4 = M[r3 + 8];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200298:	0c 00 55 d1 	r3 = M[r3 + 12];
    NULL = r5 - r2;
8420029c:	4f 00 07 20 	Null = r5 - r2;
    if POS r3 = r4;
842002a0:	05 00 56 00 	if POS r3 = r4 + Null;

    // chan_ptr->limit_gain_log2 = (1.0 - tc)*limiter_attn + tc*chan_ptr->limit_gain_log2;
    // chan_ptr->limit_gain_log2 = MIN(chan_ptr->limit_gain_log2,0);
    rMAC = r5;
842002a4:	0f 00 17 00 	rMAC = r5 + Null;
    rMAC = rMAC - r3*r5;
842002a8:	7f 00 15 bc 	rMAC = rMAC - r3 * r5 (SS);
    rMAC = rMAC + r3*r2;
842002ac:	4f 00 15 ac 	rMAC = rMAC + r3 * r2 (SS);
    if POS rMAC = NULL;
842002b0:	05 00 10 00 	if POS rMAC = Null + Null;

    r3 = r5 - rMAC;
842002b4:	1f 00 57 20 	r3 = r5 - rMAC;
    r3 = ABS r3;
842002b8:	4f 00 55 e4 	r3 = ABS r3;
    NULL = r3 - 0.00001;
842002bc:	e3 53 05 21 	Null = r3 - 21475;
    if LE rMAC = r5;
842002c0:	0d 00 17 00 	if LE rMAC = r5 + Null;

    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD]=rMAC;
842002c4:	0c 00 13 d5 	M[r1 + 12] = rMAC;

    // r1 = chan_ptr

    L0 = NULL;
842002c8:	0f 00 c0 50 	L0 = Null + Null;
    push NULL;
842002cc:	00 00 00 f3 	push Null;
    pop B0;
842002d0:	00 00 a6 f3 	pop B0;

    /* channel count */
    pop r7;
842002d4:	00 00 94 f3 	pop r7;

    /* advance channel */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842002d8:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cufp.chan_ptr] = r1;
842002dc:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* restore data */
    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842002e0:	04 00 28 f1 	r0 = M[FP + 0x4];
    r2 = M[FP + $vol_ctrl.cufp.vol_ptr];
842002e4:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* Another channel ? */
    r7 = r7 - 1;
842002e8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_update_channel_next;
842002ec:	50 ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_next;

842002f0 <$_vol_ctrl_update_saturation>:
//    Function is C compatible
//
// *****************************************************************************
$_vol_ctrl_update_saturation:
    /* Saturation protection may be per channel or across all channels */
    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842002f0:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842002f4:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_saturation_done;
842002f8:	1a 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

        r2 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
842002fc:	68 00 42 d1 	r2 = M[r0 + 104];
        r10 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200300:	5c 00 c2 d1 	r10 = M[r0 + 92];
        M3 = ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE * ADDR_PER_WORD);
84200304:	24 00 b0 51 	M3 = Null + 36;
        I0 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD;
84200308:	0c 00 04 51 	I0 = r2 + 12;
        I1 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD;
8420030c:	10 00 14 51 	I1 = r2 + 16;

        NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATESYNCENA;
84200310:	04 00 03 81 	Null = r1 AND 0x4;
        if Z jump vol_ctrl_update_saturation_not_sync;
84200314:	0e 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync;
            // Min log gain of channels
            push r10,    r1 = M[I0,M3];
84200318:	00 33 c0 f2 	push r10, r1 = M[I0,M3];
            r10 = r10 - 1;
8420031c:	3f 00 cc e4 	r10 = r10 - 1;
            r0  = r1;
84200320:	0f 00 23 00 	r0 = r1 + Null;
            do vol_ctrl_update_saturation_min_lp;
84200324:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp;
                r0 = MIN r1, r1 = M[I0,M3];
84200328:	5f 33 23 e4 	r0 = MIN r1, r1 = M[I0,M3];

8420032c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp>:
            vol_ctrl_update_saturation_min_lp:
            r0 = MIN r1;
8420032c:	5f 00 23 e4 	r0 = MIN r1;
            // Convert to linear
            call $math.pow2_table;
84200330:	07 00 00 fd 	call 0x74514;
84200334:	14 45 f0 e1 
            // Apply to all channels
            pop r10;
84200338:	00 00 c4 f3 	pop r10;
            // Nops ensures pipeline for setting r10
            nop;
8420033c:	00 00 00 03 	Null = Null + Null;
            do vol_ctrl_update_saturation_apply_lp;
84200340:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp;
                M[I1,M3]=r0;
84200344:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200348 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp>:
            vol_ctrl_update_saturation_apply_lp:
            jump vol_ctrl_update_saturation_done;
84200348:	06 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

8420034c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync>:

        vol_ctrl_update_saturation_not_sync:
            // Convert to linear
            do vol_ctrl_update_saturation_conv_lp;
8420034c:	05 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;
                r0 = M[I0,M3];
84200350:	00 23 00 02 	Null = Null + Null, r0 = M[I0,M3];
                call $math.pow2_table;
84200354:	07 00 00 fd 	call 0x74514;
84200358:	14 45 f0 e1 
                M[I1,M3]=r0;
8420035c:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200360 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp>:
           vol_ctrl_apply_volume(op_extra_data,&op_extra_data->channels[i],&volume_tc);
       }
   */
$_vol_ctrl_apply_volume:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200360:	04 00 28 f1 	r0 = M[FP + 0x4];

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200364:	5c 00 92 d1 	r7 = M[r0 + 92];

    // Reset chan_ptr
    r1 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
84200368:	68 00 32 d1 	r1 = M[r0 + 104];
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
8420036c:	08 00 3c f1 	M[FP + 0x8] = r1;

    // Move time constants */
    r2 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200370:	10 00 48 f1 	r2 = M[FP + 0x10];
    M[FP + $vol_ctrl.cuup.tc_ptr] = r2;
84200374:	0c 00 4c f1 	M[FP + 0xc] = r2;

84200378 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next>:
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

vol_ctrl_apply_volume_next:
    push r7;
84200378:	00 00 90 f3 	push r7;
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

    // r3: routing
    r7 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
8420037c:	f4 01 92 01 	r7 = r0 + 500;
    r6 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200380:	00 00 83 d1 	r6 = M[r1 + 0];
    r6 = r6  * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200384:	14 00 88 99 	r6 = r6 * 20 (int);
    r3 = M[r7+r6];
84200388:	8f 00 59 d0 	r3 = M[r7 + r6];

    // Boost
    r8 = $volume_and_limit.OneQ5;
8420038c:	00 08 00 fd 	r8 = Null + 134217728;
84200390:	00 00 a0 01 
    r5  = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_FIELD)];
84200394:	9c 02 72 d1 	r5 = M[r0 + 668];
    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
84200398:	20 00 00 fd 	Null = r3 AND 0x200000;
8420039c:	00 00 05 81 
    if Z r5 = r8;
842003a0:	00 00 7a 00 	if EQ r5 = r8 + Null;

    // Gains
    r9  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];        // Q5.xx
842003a4:	18 00 b3 d1 	r9 = M[r1 + 24];
    r10 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
842003a8:	00 00 c4 d1 	r10 = M[r2 + 0];
    r7  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];       // Q5.xx
842003ac:	08 00 93 d1 	r7 = M[r1 + 8];
    r6  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]; // Q.xx
842003b0:	10 00 83 d1 	r6 = M[r1 + 16];

    // calculate init and final volume for this frame
    rMAC = r9 * r6;
842003b4:	8f 00 1b cc 	rMAC = r9 * r6 (SS);
    rMAC = rMAC * r7;
842003b8:	9f 00 11 cc 	rMAC = rMAC * r7 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);
842003bc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
    rMAC = rMAC * r5;
842003c0:	7f 00 11 cc 	rMAC = rMAC * r5 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);  // Boost
842003c4:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);

    // Compute the volume step size
    r4  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD];         // Q5.xx
842003c8:	1c 00 63 d1 	r4 = M[r1 + 28];
    r2 = rMAC - r4;
842003cc:	6f 00 41 20 	r2 = rMAC - r4;
    rMAC = r2 ASHIFT 0 (LO);
842003d0:	00 01 e4 91 	rMAC = r2 ASHIFT 0 (LO);
    Div = rMAC / r10;
842003d4:	00 00 1c d9 	Div = rMAC / r10;

    // Aux Mix
    r8  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD];        // Q5.xx
842003d8:	04 00 a3 d1 	r8 = M[r1 + 4];
    rMAC = r8 * r5;
842003dc:	7f 00 1a cc 	rMAC = r8 * r5 (SS);
    r8 = rMAC ASHIFT 4;  // Boost
842003e0:	04 00 a1 91 	r8 = rMAC ASHIFT 4;

    /* Adjust Clip Point
       (might as well do it even if we don't use it, divide takes time anyway) */
    r5 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CLIP_POINT_FIELD)];
842003e4:	94 02 72 d1 	r5 = M[r0 + 660];
    r2 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_CLIP_POINT_FIELD)];
842003e8:	98 02 42 d1 	r2 = M[r0 + 664];
    // Multiply the Clip Point (r5) with the Inverse Post Gain (r7)
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
842003ec:	8c 01 92 d1 	r7 = M[r0 + 396];
    r7 = M[r7 + $volume_control_cap._shared_volume_struct.INV_POST_GAIN_FIELD];
842003f0:	0c 00 99 d1 	r7 = M[r7 + 12];
    // The inverse DAC gain is Q5.xx, so we need to shift r7 to get Q1.xx
    rMAC = r5 * r7;
842003f4:	9f 00 17 cc 	rMAC = r5 * r7 (SS);
    r7 = rMAC ASHIFT 4;
842003f8:	04 00 91 91 	r7 = rMAC ASHIFT 4;
    // limit the clipper threshold so DAC wrap bug doesn't occur
    Null = r7 - r2;
842003fc:	4f 00 09 20 	Null = r7 - r2;
    if POS r7 = r2;
84200400:	05 00 94 00 	if POS r7 = r2 + Null;

    // Step for main volume
    r5 = DivResult;
84200404:	01 00 70 d9 	r5 = DivResult;

    // Setup Buffers
    pushm <r3,r10>;
84200408:	20 10 00 f1 	pushm <r3, r10>;

    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420040c:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD (int);
84200410:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = r0 + r1;
84200414:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200418:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420041c:	00 00 20 d3 	r0 = M[r0 + Null];
    call $cbuffer.get_read_address_and_size_and_start_address;
84200420:	03 00 00 fd 	call (m) 0x3a27a;
84200424:	7b a2 f0 e1 
    I0 = r0;
84200428:	2f 00 00 50 	I0 = Null + r0;
    push r2;
8420042c:	00 00 40 f3 	push r2;
    pop  B0;
84200430:	00 00 a6 f3 	pop B0;
    L0 = r1;
84200434:	3f 00 c0 50 	L0 = Null + r1;

    pop r0;
84200438:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
8420043c:	20 00 22 d1 	r0 = M[r0 + 32];
    call $cbuffer.get_write_address_and_size_and_start_address;
84200440:	03 00 00 fd 	call (m) 0x3a2b0;
84200444:	b1 a2 f0 e1 
    I5 = r0;
84200448:	2f 00 50 50 	I5 = Null + r0;
    push r2;
8420044c:	00 00 40 f3 	push r2;
    pop B5;
84200450:	00 00 d6 f3 	pop B5;
    L5 = r1;
84200454:	3f 00 f0 50 	L5 = Null + r1;

    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
84200458:	08 00 38 f1 	r1 = M[FP + 0x8];
    r0 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD];
8420045c:	20 00 23 d1 	r0 = M[r1 + 32];
    if NZ jump vol_ctrl_apply_volume_get_aux;
84200460:	06 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux;
        r0 = FP + $vol_ctrl.cuup.dummy;
84200464:	10 00 27 f1 	r0 = FP + 16;
        r1 = ADDR_PER_WORD;
84200468:	bf 00 30 e4 	r1 = Null + 4;
        r2 = r0;
8420046c:	0f 00 42 00 	r2 = r0 + Null;
        r8 = NULL;
84200470:	0f 00 a0 00 	r8 = Null + Null;
        jump vol_ctrl_apply_volume_get_aux_ok;
84200474:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok;

84200478 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux>:
    vol_ctrl_apply_volume_get_aux:
        call $cbuffer.get_read_address_and_size_and_start_address;
84200478:	03 00 00 fd 	call (m) 0x3a27a;
8420047c:	7b a2 f0 e1 

84200480 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok>:
  vol_ctrl_apply_volume_get_aux_ok:
    // Set Aux pointer
    I4 = r0;
84200480:	2f 00 40 50 	I4 = Null + r0;
    push r2;
84200484:	00 00 40 f3 	push r2;
    pop B4;
84200488:	00 00 c6 f3 	pop B4;
    L4 = r1;
8420048c:	3f 00 e0 50 	L4 = Null + r1;

    popm <r3,r10>;
84200490:	20 10 04 f1 	popm <r3, r10>;
    // r7=clip, r4=main gain, r8=aux gain, r3=routing, r10 = amount

    /* Check Mute */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200494:	04 00 28 f1 	r0 = M[FP + 0x4];
    r6 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD];
84200498:	04 03 82 d1 	r6 = M[r0 + 772];
    r9 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD];
8420049c:	08 03 b2 d1 	r9 = M[r0 + 776];
    if NZ jump vol_ctrl_apply_volume_mute;
842004a0:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute;

    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004a4:	20 00 00 fd 	Null = r3 AND 0x200000;
842004a8:	00 00 05 81 
    if NZ jump vol_ctrl_apply_volume_clip;
842004ac:	08 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip;
        do vol_ctrl_apply_volume_lp;
842004b0:	06 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004b4:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004b8:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004bc:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004c0:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            M[I5,MK1] = rMAC;
842004c4:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

842004c8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp>:
        vol_ctrl_apply_volume_lp:
        jump vol_ctrl_apply_volume_done;
842004c8:	26 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004cc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip>:

    vol_ctrl_apply_volume_clip:
        do vol_ctrl_apply_volume_clip_lp;
842004cc:	0a 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004d0:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004d4:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004d8:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004dc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
842004e0:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
842004e4:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
842004e8:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
842004ec:	00 00 43 97 	r2 = r2 * r1 (frac);
            M[I5,MK1] = r2;
842004f0:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

842004f4 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp>:
        vol_ctrl_apply_volume_clip_lp:
        jump vol_ctrl_apply_volume_done;
842004f4:	1b 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004f8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute>:

vol_ctrl_apply_volume_mute:
        NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004f8:	20 00 00 fd 	Null = r3 AND 0x200000;
842004fc:	00 00 05 81 
        if NZ jump vol_ctrl_apply_volume_clip_mute;
84200500:	0b 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute;

        do vol_ctrl_apply_volume_mute_lp;
84200504:	09 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200508:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
8420050c:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200510:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
84200514:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Mute
            r6 = r6 + r9;
84200518:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
8420051c:	04 00 80 00 	if NEG r6 = Null + Null;
            rMAC = rMAC * r6 (frac);
84200520:	00 00 18 97 	rMAC = rMAC * r6 (frac);
            // Save result
            M[I5,MK1] = rMAC;
84200524:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

84200528 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp>:
        vol_ctrl_apply_volume_mute_lp:
        jump vol_ctrl_apply_volume_done;
84200528:	0e 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

8420052c <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute>:

vol_ctrl_apply_volume_clip_mute:
        do vol_ctrl_apply_volume_clip_mute_lp;
8420052c:	0d 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200530:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
84200534:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200538:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
8420053c:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
84200540:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
84200544:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
84200548:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
8420054c:	00 00 43 97 	r2 = r2 * r1 (frac);
            // Mute
            r6 = r6 + r9;
84200550:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
84200554:	04 00 80 00 	if NEG r6 = Null + Null;
            r2 = r2 * r6 (frac);
84200558:	00 00 48 97 	r2 = r2 * r6 (frac);
            // Save result
            M[I5,MK1] = r2;
8420055c:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

84200560 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp>:
        vol_ctrl_apply_volume_clip_mute_lp:

vol_ctrl_apply_volume_done:

    // Save last gain
    r1 = M[FP +$vol_ctrl.cuup.chan_ptr];
84200560:	08 00 38 f1 	r1 = M[FP + 0x8];
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD] = r4;
84200564:	1c 00 63 d5 	M[r1 + 28] = r4;

    // Update Buffer
    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200568:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD(int);
8420056c:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200570:	04 00 28 f1 	r0 = M[FP + 0x4];
    r0 = r0 + r1;
84200574:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200578:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420057c:	00 00 20 d3 	r0 = M[r0 + Null];
    r1 = I0;
84200580:	0f 00 30 44 	r1 = Null + I0;
    call $cbuffer.set_read_address;
84200584:	03 00 00 fd 	call (m) 0x3a2e6;
84200588:	e7 a2 f0 e1 
    pop r0;
8420058c:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
84200590:	20 00 22 d1 	r0 = M[r0 + 32];
    r1 = I5;
84200594:	5f 00 30 44 	r1 = Null + I5;
    call $cbuffer.set_write_address;
84200598:	03 00 00 fd 	call (m) 0x3a320;
8420059c:	21 a3 f0 e1 

    /* Next Channel */
    pop r7;
842005a0:	00 00 94 f3 	pop r7;

    /* Restore parameters */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
842005a4:	04 00 28 f1 	r0 = M[FP + 0x4];
    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
842005a8:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[FP + $vol_ctrl.cuup.tc_ptr];
842005ac:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* advance chan_ptr */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842005b0:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
842005b4:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* Another channel */
    r7 = r7 - 1;
842005b8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_apply_volume_next;
842005bc:	6f ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next;

    // Save current mute
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD]=r6;
842005c0:	04 03 82 d5 	M[r0 + 772] = r6;
    NULL = r6 - 1.0;
842005c4:	ff 7f 00 fd 	Null = r6 - 2147483647;
842005c8:	ff ff 08 21 
    if Z r9=NULL;
842005cc:	00 00 b0 00 	if EQ r9 = Null + Null;
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD]=r9;
842005d0:	08 03 b2 d5 	M[r0 + 776] = r9;

    // Restore arithmetic mode */
    pop r4;
842005d4:	00 00 64 f3 	pop r4;
    M[$ARITHMETIC_MODE]=r4;
842005d8:	14 e0 60 19 	M[0xffffe014] = r4 + Null;

842005dc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort>:

vol_ctrl_apply_volume_abort:

    popm <FP,r0,r1,r2,r3,rlink>;
842005dc:	3d 20 04 f1 	popm <FP, r0, r1, r2, r3, rLink>;
    popm <B0,B4,B5>;
842005e0:	00 34 06 f1 	popm <B0, B4, B5>;
    popm <I0,I1,I4,I5,M3,L0,L4,L5>;
842005e4:	33 d8 05 f1 	popm <I0, I1, I4, I5, M3, L0, L4, L5>;
    popm <r4,r5,r6,r7,r8,r9>;
842005e8:	c0 0f 04 f1 	popm <r4, r5, r6, r7, r8, r9>;

    rts;
842005ec:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

842005f0 <$_setup_processing>:
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;

}

bool setup_processing(VOL_CTRL_DATA_T   *op_extra_data)
{
842005f0:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842005f2:	11 09       	r7 = r0 + Null;
    unsigned touched_sink = TOUCHED_NOTHING;
842005f4:	06 00       	r4 = Null + Null;
    unsigned touched_src  = TOUCHED_NOTHING;
842005f6:	07 00       	r5 = Null + Null;
    unsigned i,sink_bit,initial_channel_gain,chan_count=0;
842005f8:	00 09       	r6 = Null + Null;
    vol_ctrl_channel_t *chan_ptr;
	vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
842005fa:	9a f0 f8 20 	r8 = r7 + 248;

    patch_fn_shared(volume_control_wrapper);

    /* Release data object */
    destroy_processing(op_extra_data);
842005fe:	6a 4e       	call (m) $_destroy_processing;


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200600:	01 00       	rMAC = Null + Null;
84200602:	02 00       	r0 = Null + Null;
84200604:	93 f0 20 20 	r1 = r7 + 32;

84200608 <Lc_setup_processing_2>:
    {
        if(op_extra_data->input_buffer[i])
84200608:	34 f3 f8 b9 	r2 = M[r1 + -32];
8420060c:	43 60       	if EQ jump (m) Lc_setup_processing_12;

8420060e <Lc_setup_processing_3>:
        {
            if(op_extra_data->output_buffer[i])
8420060e:	1c e8       	r2 = M[r1 + Null];
84200610:	43 60       	if EQ jump (m) Lc_setup_processing_13;

84200612 <Lc_setup_processing_4>:
            {
                chan_count++;
84200612:	08 75       	r6 = r6 + 1;
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
84200614:	14 00       	r2 = r0 + Null;
84200616:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
8420061a:	36 13       	r4 = r4 OR r2;
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
8420061c:	0c 00       	r2 = rMAC + Null;
8420061e:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
84200622:	3f 13       	r5 = r5 OR r2;

84200624 <Lc_setup_processing_5>:
    /* Release data object */
    destroy_processing(op_extra_data);


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200624:	49 20       	rMAC = rMAC + 1;
84200626:	92 20       	r0 = r0 + 2;
84200628:	1b 21       	r1 = r1 + 4;
8420062a:	08 26       	Null = rMAC - 8;
8420062c:	ee 65       	if NC jump (m) Lc_setup_processing_2;

8420062e <Lc_setup_processing_6>:
            return FALSE;
        }
    }

    /* Must have at least one channel */
    if(chan_count<1)
8420062e:	0f f8 00 c2 	Null = r6 - Null;
84200632:	32 60       	if EQ jump (m) Lc_setup_processing_13;

84200634 <Lc_setup_processing_7>:
    {
        return FALSE;
    }

    /* A valid set of channels is connected */
    op_extra_data->channels = (vol_ctrl_channel_t*)xzpmalloc(chan_count*sizeof(vol_ctrl_channel_t));
84200634:	c3 20       	r1 = Null + 3;
84200636:	12 f8 92 c9 	r0 = r6 * 36 (int);
8420063a:	ff fd 31 f0 	call (m) 0x68a6;
8420063e:	2d e3 
    if(!op_extra_data->channels)
84200640:	92 f0 1a 8e 	M[r7 + 104] = r0;
84200644:	29 60       	if EQ jump (m) Lc_setup_processing_13;

84200646 <Lc_setup_processing_8>:
    {
        return FALSE;
    }
    op_extra_data->touched_src  = touched_src;
84200646:	97 f0 19 8e 	M[r7 + 100] = r5;
    op_extra_data->touched_sink = touched_sink;
8420064a:	96 f0 18 8e 	M[r7 + 96] = r4;
    op_extra_data->num_channels = chan_count;
8420064e:	98 f0 17 8e 	M[r7 + 92] = r6;

    /* Initialize Mute */
    op_extra_data->cur_mute_gain = 0;
84200652:	90 f0 c1 8e 	M[r7 + 772] = Null;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84200656:	a3 f0 01 88 	r1 = M[r8 + 4];
8420065a:	4a 08       	r0 = r7 + Null;
8420065c:	08 f0 37 ed 	call (m) Lc_vol_ctrl_setup_mute_1;

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
84200660:	96 f0 1a 88 	r4 = M[r7 + 104];
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
84200664:	07 00       	r5 = Null + Null;
84200666:	98 f0 20 20 	r6 = r7 + 32;

8420066a <Lc_setup_processing_9>:
    {
        if(op_extra_data->output_buffer[i])
8420066a:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420066e:	21 60       	if EQ jump (m) Lc_setup_processing_16;

84200670 <Lc_setup_processing_10>:
        {
		    /* If initial value not specified before operator start, use -96db as default
			 * If an initial value is specified calculate channel gain as master_gain + channel_trim - post gain
			 */
		    if(op_extra_data->vol_initialised)
84200670:	90 f0 bf 88 	Null = M[r7 + 764];
84200674:	13 60       	if EQ jump (m) Lc_setup_processing_14;

84200676 <Lc_setup_processing_11>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
84200676:	91 f0 62 88 	rMAC = M[r7 + 392];
8420067a:	7a 54       	r0 = r5 LSHIFT 2;
8420067c:	8a 00       	r0 = rMAC + r0;
8420067e:	92 98       	r0 = M[r0 + 40];
84200680:	1f f2 81 c0 	rMAC = r0 + M[rMAC];
84200684:	92 f0 3d 88 	r0 = M[r7 + 244];
84200688:	8a 04       	r0 = rMAC - r0;
8420068a:	ff fd bc f1 	call (m) 0x37fbe;
8420068e:	35 e9 
84200690:	06 6e       	jump (m) Lc_setup_processing_15;

84200692 <Lc_setup_processing_12>:
            else
            {
                return FALSE;
            }
        }
        else if(op_extra_data->output_buffer[i])
84200692:	1c e8       	r2 = M[r1 + Null];
84200694:	c8 61       	if EQ jump (m) Lc_setup_processing_5;

84200696 <Lc_setup_processing_13>:
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
            }
            else
            {
                return FALSE;
84200696:	02 00       	r0 = Null + Null;
84200698:	1b 6e       	jump (m) Lc_setup_processing_18;

8420069a <Lc_setup_processing_14>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
			}
			else
			{
				initial_channel_gain = 0;
8420069a:	02 00       	r0 = Null + Null;

8420069c <Lc_setup_processing_15>:
			};

			chan_ptr->chan_idx = i;
8420069c:	37 ee       	M[r4 + Null] = r5;
			chan_ptr->channel_gain = initial_channel_gain;
8420069e:	b2 8f       	M[r4 + 24] = r0;
			chan_ptr->prim_mix_gain = dB60toLinearQ5(0); /*set to 0db. this will be recalculated as part of the update function*/
842006a0:	02 00       	r0 = Null + Null;
842006a2:	ff fd bc f1 	call (m) 0x37fbe;
842006a6:	3d e8 
842006a8:	b2 8e       	M[r4 + 8] = r0;
			chan_ptr->last_volume  = chan_ptr->channel_gain;
842006aa:	b1 89       	rMAC = M[r4 + 24];
842006ac:	f1 8f       	M[r4 + 28] = rMAC;
			chan_ptr++;
842006ae:	36 31       	r4 = r4 + 36;

842006b0 <Lc_setup_processing_16>:
    op_extra_data->cur_mute_gain = 0;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
842006b0:	7f 20       	r5 = r5 + 1;
842006b2:	20 75       	r6 = r6 + 4;
842006b4:	38 26       	Null = r5 - 8;
842006b6:	da 65       	if NC jump (m) Lc_setup_processing_9;

842006b8 <Lc_setup_processing_17>:
			chan_ptr->last_volume  = chan_ptr->channel_gain;
			chan_ptr++;
        }
    }

    op_extra_data->vol_initialised = 0;
842006b8:	90 f0 bf 8e 	M[r7 + 764] = Null;
    op_extra_data->wait_on_space_buffer=NULL;
842006bc:	90 f0 10 8e 	M[r7 + 64] = Null;
    op_extra_data->wait_on_data_buffer=NULL;
842006c0:	90 f0 11 8e 	M[r7 + 68] = Null;
    op_extra_data->aux_pending = FALSE;
842006c4:	90 f0 bc 8e 	M[r7 + 752] = Null;
    op_extra_data->used_all_input = FALSE;
842006c8:	90 f0 bd 8e 	M[r7 + 756] = Null;

    return TRUE;
842006cc:	42 20       	r0 = Null + 1;

842006ce <Lc_setup_processing_18>:
}
842006ce:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842006d0:	d8 4c       	rts;

842006d2 <$_destroy_processing>:
}

/* ************************************* Data processing-related functions and wrappers **********************************/

void destroy_processing(VOL_CTRL_DATA_T *op_extra_data)
{
842006d2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842006d4:	16 00       	r4 = r0 + Null;
    timer_cancel_event_atomic(&op_extra_data->pending_timer);
842006d6:	67 f0 f8 22 	r5 = r4 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
842006da:	ff fd d3 f1 	call (m) 0x3ad3a;
842006de:	21 e3 
    if (*timer_id != TIMER_ID_INVALID)
842006e0:	3a e8       	r0 = M[r5 + Null];
842006e2:	07 60       	if EQ jump (m) Lc_destroy_processing_3;

842006e4 <Lc_destroy_processing_2>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
842006e4:	04 00       	r2 = Null + Null;
842006e6:	03 00       	r1 = Null + Null;
842006e8:	ff fd 2d f0 	call (m) 0x6292;
842006ec:	2b ed 
        *timer_id = TIMER_ID_INVALID;
842006ee:	38 ee       	M[r5 + Null] = Null;

842006f0 <Lc_destroy_processing_3>:
    }
    interrupt_unblock();
842006f0:	ff fd d3 f1 	call (m) 0x3ad56;
842006f4:	27 e3 

    if(!op_extra_data->channels)
842006f6:	b2 b8       	r0 = M[r4 + 104];
842006f8:	05 60       	if EQ jump (m) Lc_destroy_processing_5;

842006fa <Lc_destroy_processing_4>:
    {
        return;
    }

    pfree(op_extra_data->channels);
842006fa:	ff fd 30 f0 	call (m) 0x68d8;
842006fe:	3f ee 
    op_extra_data->channels = NULL;
84200700:	b0 be       	M[r4 + 104] = Null;

84200702 <Lc_destroy_processing_5>:
}
84200702:	f2 48       	popm <FP, r4, r5, rLink>;
84200704:	d8 4c       	rts;

84200706 <$_vol_ctlr_create>:


/* ********************************** API functions ************************************* */

bool vol_ctlr_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200706:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200708:	17 00       	r5 = r0 + Null;
8420070a:	19 09       	r7 = r1 + Null;
8420070c:	20 09       	r6 = r2 + Null;
8420070e:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200710:	ef fd fe ff 	call (m) 0x4e6;
84200714:	37 ee 
84200716:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    if (!base_op_create(op_data, message_data, response_id, response_data))
84200718:	55 08       	r3 = r8 + Null;
8420071a:	44 08       	r2 = r6 + Null;
8420071c:	4b 08       	r1 = r7 + Null;
8420071e:	3a 00       	r0 = r5 + Null;
84200720:	ef fd fe ff 	call (m) 0x35a;
84200724:	3b e1 
84200726:	10 04       	Null = r0 - Null;
84200728:	03 62       	if NE jump (m) Lc_vol_ctlr_create_3;

8420072a <Lc_vol_ctlr_create_2>:
    {
        return FALSE;
8420072a:	02 00       	r0 = Null + Null;
8420072c:	31 6e       	jump (m) Lc_vol_ctlr_create_7;

8420072e <Lc_vol_ctlr_create_3>:
    }

    /*allocate the volume control shared memory*/
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
8420072e:	ff fd 9d f0 	call (m) 0x14256;
84200732:	29 e9 
84200734:	62 f0 63 8e 	M[r4 + 396] = r0;
    if(!op_extra_data->shared_volume_ptr)
84200738:	61 f0 63 88 	rMAC = M[r4 + 396];
8420073c:	08 62       	if NE jump (m) Lc_vol_ctlr_create_6;

8420073e <Lc_vol_ctlr_create_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420073e:	01 f0 00 60 	rMAC = Null + 4096;
84200742:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200746:	51 8e       	M[r0 + 4] = rMAC;

84200748 <Lc_vol_ctlr_create_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84200748:	42 20       	r0 = Null + 1;
8420074a:	22 6e       	jump (m) Lc_vol_ctlr_create_7;

8420074c <Lc_vol_ctlr_create_6>:
    }

    op_extra_data->lpvols = &op_extra_data->host_vol;
8420074c:	61 f0 f8 20 	rMAC = r4 + 248;
84200750:	61 f0 62 8e 	M[r4 + 392] = rMAC;
    op_extra_data->stream_based = FALSE;
84200754:	60 f0 c3 8e 	M[r4 + 780] = Null;

    /* Initialize mute control */
    op_extra_data->mute_period = 10;
84200758:	81 22       	rMAC = Null + 10;
8420075a:	61 f0 c0 8e 	M[r4 + 768] = rMAC;

    /* Initialize extended data for operator.  Assume initialized to zero*/
    op_extra_data->ReInitFlag = 1;
8420075e:	41 20       	rMAC = Null + 1;
84200760:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200764:	60 f0 be 8e 	M[r4 + 760] = Null;

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)VOL_CTRL_GetDefaults(base_op_get_cap_id(op_data)),(unsigned*)&op_extra_data->parameters,sizeof(VOL_CTRL_PARAMETERS)))
84200768:	3a 00       	r0 = r5 + Null;
8420076a:	ef fd fe ff 	call (m) 0x4ea;
8420076e:	21 ec 
84200770:	08 f0 35 eb 	call (m) $_VOL_CTRL_GetDefaults;
84200774:	13 00       	r1 = r0 + Null;
84200776:	05 f0 20 41 	r3 = Null + 288;
8420077a:	64 f0 90 21 	r2 = r4 + 400;
8420077e:	62 f0 b4 22 	r0 = r4 + 692;
84200782:	ef fd ff ff 	call (m) 0x742;
84200786:	21 ee 
84200788:	10 04       	Null = r0 - Null;
8420078a:	df 63       	if NE jump (m) Lc_vol_ctlr_create_5;

8420078c <Lc__ite_11>:
8420078c:	d9 6f       	jump (m) Lc_vol_ctlr_create_4;

8420078e <Lc_vol_ctlr_create_7>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    return TRUE;
}
8420078e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200790:	d8 4c       	rts;

84200792 <$_vol_ctlr_destroy>:



bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200792:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200794:	17 00       	r5 = r0 + Null;
84200796:	1a 09       	r8 = r1 + Null;
84200798:	21 09       	r7 = r2 + Null;
8420079a:	2e 00       	r4 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420079c:	ef fd fe ff 	call (m) 0x4e6;
842007a0:	2b ea 
842007a2:	10 09       	r6 = r0 + Null;

bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    if (opmgr_op_is_running(op_data))
842007a4:	3a 00       	r0 = r5 + Null;
842007a6:	ff fd 27 f0 	call (m) 0x5700;
842007aa:	3b ea 
842007ac:	10 04       	Null = r0 - Null;
842007ae:	09 60       	if EQ jump (m) Lc_vol_ctlr_destroy_3;

842007b0 <Lc_vol_ctlr_destroy_2>:
    {
        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842007b0:	03 f0 00 60 	r1 = Null + 4096;
842007b4:	34 00       	r2 = r4 + Null;
842007b6:	3a 00       	r0 = r5 + Null;
842007b8:	ef fd fe ff 	call (m) 0x4bc;
842007bc:	25 e8 
842007be:	16 6e       	jump (m) Lc_vol_ctlr_destroy_6;

842007c0 <Lc_vol_ctlr_destroy_3>:
    }

    /* call base_op destroy that creates and fills response message, too */
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
842007c0:	35 00       	r3 = r4 + Null;
842007c2:	4c 08       	r2 = r7 + Null;
842007c4:	53 08       	r1 = r8 + Null;
842007c6:	3a 00       	r0 = r5 + Null;
842007c8:	ef fd fd ff 	call (m) 0x370;
842007cc:	29 ed 
842007ce:	10 04       	Null = r0 - Null;
842007d0:	03 62       	if NE jump (m) Lc_vol_ctlr_destroy_5;

842007d2 <Lc_vol_ctlr_destroy_4>:
    {
        return(FALSE);
842007d2:	02 00       	r0 = Null + Null;
842007d4:	0b 6e       	jump (m) Lc_vol_ctlr_destroy_6;

842007d6 <Lc_vol_ctlr_destroy_5>:
    }

    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
842007d6:	82 f0 63 88 	r0 = M[r6 + 396];
842007da:	ff fd 9d f0 	call (m) 0x1427a;
842007de:	21 e5 
    op_extra_data->shared_volume_ptr = NULL;
842007e0:	80 f0 63 8e 	M[r6 + 396] = Null;

    /* Release Channels */
    destroy_processing(op_extra_data);
842007e4:	42 08       	r0 = r6 + Null;
842007e6:	76 4f       	call (m) $_destroy_processing;

    return TRUE;
842007e8:	42 20       	r0 = Null + 1;

842007ea <Lc_vol_ctlr_destroy_6>:
}
842007ea:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842007ec:	d8 4c       	rts;

842007ee <$_vol_ctlr_connect>:
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842007ee:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842007f0:	11 09       	r7 = r0 + Null;
842007f2:	18 09       	r6 = r1 + Null;
842007f4:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842007f6:	ef fd fe ff 	call (m) 0x4e6;
842007fa:	31 e7 
842007fc:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);    /* extract the terminal_id */
842007fe:	87 f0 00 e8 	r5 = M[r6 + Null];
    tCbuffer* pterminal_buf = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
84200802:	88 f0 01 88 	r6 = M[r6 + 4];

    /* Setup Response to Connection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200806:	03 00       	r1 = Null + Null;
84200808:	54 08       	r2 = r8 + Null;
8420080a:	4a 08       	r0 = r7 + Null;
8420080c:	ef fd fe ff 	call (m) 0x4bc;
84200810:	31 e5 
84200812:	10 04       	Null = r0 - Null;
84200814:	03 62       	if NE jump (m) Lc_vol_ctlr_connect_3;

84200816 <Lc_vol_ctlr_connect_2>:
    {
        return FALSE;
84200816:	02 00       	r0 = Null + Null;
84200818:	67 6e       	jump (m) Lc_vol_ctlr_connect_23;

8420081a <Lc_vol_ctlr_connect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
8420081a:	3b 00       	r1 = r5 + Null;
8420081c:	4a 08       	r0 = r7 + Null;
8420081e:	ef fd fe ff 	call (m) 0x496;
84200822:	39 e3 
84200824:	10 04       	Null = r0 - Null;
84200826:	04 60       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200828 <Lc_vol_ctlr_connect_4>:
84200828:	0f f8 00 c2 	Null = r6 - Null;
8420082c:	07 62       	if NE jump (m) Lc_vol_ctlr_connect_6;

8420082e <Lc_vol_ctlr_connect_5>:
8420082e:	01 f0 00 60 	rMAC = Null + 4096;
84200832:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200836:	51 8e       	M[r0 + 4] = rMAC;
84200838:	47 6e       	jump (m) Lc_vol_ctlr_connect_19;

8420083a <Lc_vol_ctlr_connect_6>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (opmgr_op_is_running(op_data))
8420083a:	4a 08       	r0 = r7 + Null;
8420083c:	ff fd 27 f0 	call (m) 0x5700;
84200840:	25 e6 
84200842:	10 04       	Null = r0 - Null;
84200844:	07 60       	if EQ jump (m) Lc_vol_ctlr_connect_9;

84200846 <Lc_vol_ctlr_connect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
84200846:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420084a:	00 00 
8420084c:	f1 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

8420084e <Lc_vol_ctlr_connect_8>:
8420084e:	39 c0       	rMAC = r5 AND 0x1;
84200850:	ef 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200852 <Lc_vol_ctlr_connect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
84200852:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200856:	00 00 
84200858:	39 60       	if EQ jump (m) Lc_vol_ctlr_connect_20;

8420085a <Lc_vol_ctlr_connect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
8420085a:	3a 50       	r0 = r5 LSHIFT -1;
8420085c:	2a f0 1f 00 	r8 = r0 AND 0x1f;

        if(terminal_id&0x1)
84200860:	39 c0       	rMAC = r5 AND 0x1;
84200862:	23 60       	if EQ jump (m) Lc_vol_ctlr_connect_15;

84200864 <Lc_vol_ctlr_connect_11>:
        {
            opmgr_op_suspend_processing(op_data);
84200864:	4a 08       	r0 = r7 + Null;
84200866:	ff fd 27 f0 	call (m) 0x570c;
8420086a:	27 e5 
            op_extra_data->aux_connected |= (1<<term_idx);
8420086c:	51 08       	rMAC = r8 + Null;
8420086e:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200872:	61 f0 b7 88 	rMAC = M[r4 + 732];
84200876:	89 12       	rMAC = rMAC OR r0;
84200878:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = pterminal_buf;
8420087c:	02 fa d2 c8 	r0 = r8 LSHIFT 4;
84200880:	31 00       	rMAC = r4 + Null;
84200882:	51 00       	rMAC = r0 + rMAC;
84200884:	17 f0 6c 20 	r5 = rMAC + 108;
84200888:	78 f0 00 ee 	M[r5 + Null] = r6;
            opmgr_op_resume_processing(op_data);
8420088c:	4a 08       	r0 = r7 + Null;
8420088e:	ff fd 27 f0 	call (m) 0x573a;
84200892:	2d e5 
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_aux_channel == NULL)
84200894:	31 a9       	rMAC = M[r4 + 80];
84200896:	05 62       	if NE jump (m) Lc_vol_ctlr_connect_14;

84200898 <Lc_vol_ctlr_connect_12>:
            {
                if (buff_has_metadata(op_extra_data->aux_channel[term_idx].buffer))
84200898:	39 e8       	rMAC = M[r5 + Null];
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
8420089a:	89 89       	rMAC = M[rMAC + 24];
8420089c:	02 60       	if EQ jump (m) Lc_vol_ctlr_connect_14;

8420089e <Lc_vol_ctlr_connect_13>:
                {
                    op_extra_data->metadata_aux_channel = &op_extra_data->aux_channel[term_idx];
8420089e:	37 af       	M[r4 + 80] = r5;

842008a0 <Lc_vol_ctlr_connect_14>:
                }
            }
#endif /* INSTALL_METADATA */
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
842008a0:	32 00       	r0 = r4 + Null;
842008a2:	06 f0 25 e1 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
842008a6:	10 6e       	jump (m) Lc_vol_ctlr_connect_19;

842008a8 <Lc_vol_ctlr_connect_15>:
        }
        else
        {
            op_extra_data->input_buffer[term_idx] = pterminal_buf;
842008a8:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
842008ac:	68 f0 02 ee 	M[r4 + r0] = r6;
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_ip_buffer == NULL)
842008b0:	b1 a8       	rMAC = M[r4 + 72];
842008b2:	06 62       	if NE jump (m) Lc_vol_ctlr_connect_18;

842008b4 <Lc_vol_ctlr_connect_16>:
842008b4:	81 f0 06 88 	rMAC = M[r6 + 24];
842008b8:	03 60       	if EQ jump (m) Lc_vol_ctlr_connect_18;

842008ba <Lc_vol_ctlr_connect_17>:
            {
                if (buff_has_metadata(op_extra_data->input_buffer[term_idx]))
                {
                    op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[term_idx];
842008ba:	68 f0 12 8e 	M[r4 + 72] = r6;

842008be <Lc_vol_ctlr_connect_18>:
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
            }
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842008be:	3b 00       	r1 = r5 + Null;
842008c0:	32 00       	r0 = r4 + Null;
842008c2:	06 f0 23 e0 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;

842008c6 <Lc_vol_ctlr_connect_19>:
    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
842008c6:	42 20       	r0 = Null + 1;
842008c8:	0f 6e       	jump (m) Lc_vol_ctlr_connect_23;

842008ca <Lc_vol_ctlr_connect_20>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842008ca:	ba c2       	r0 = r5 AND 0x3f;
        op_extra_data->output_buffer[term_idx] = pterminal_buf;
842008cc:	52 54       	r0 = r0 LSHIFT 2;
842008ce:	31 00       	rMAC = r4 + Null;
842008d0:	51 00       	rMAC = r0 + rMAC;
842008d2:	18 f0 08 8e 	M[rMAC + 32] = r6;
#ifdef INSTALL_METADATA
        if(op_extra_data->metadata_op_buffer == NULL)
842008d6:	f1 a8       	rMAC = M[r4 + 76];
842008d8:	f3 63       	if NE jump (m) Lc_vol_ctlr_connect_18;

842008da <Lc_vol_ctlr_connect_21>:
842008da:	81 f0 06 88 	rMAC = M[r6 + 24];
842008de:	f0 61       	if EQ jump (m) Lc_vol_ctlr_connect_18;

842008e0 <Lc_vol_ctlr_connect_22>:
        {
            if (buff_has_metadata(op_extra_data->output_buffer[term_idx]))
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
842008e0:	68 f0 13 8e 	M[r4 + 76] = r6;
842008e4:	ed 6f       	jump (m) Lc_vol_ctlr_connect_18;

842008e6 <Lc_vol_ctlr_connect_23>:
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }
    return TRUE;
}
842008e6:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842008e8:	d8 4c       	rts;

842008ea <$_vol_ctlr_disconnect>:

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842008ea:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842008ec:	10 09       	r6 = r0 + Null;
842008ee:	1f 00       	r5 = r1 + Null;
842008f0:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842008f2:	ef fd fd ff 	call (m) 0x4e6;
842008f6:	35 ef 
842008f8:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
842008fa:	3f e8       	r5 = M[r5 + Null];

    /* Setup Response to Disconnection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842008fc:	03 00       	r1 = Null + Null;
842008fe:	4c 08       	r2 = r7 + Null;
84200900:	42 08       	r0 = r6 + Null;
84200902:	ef fd fd ff 	call (m) 0x4bc;
84200906:	3b ed 
84200908:	10 04       	Null = r0 - Null;
8420090a:	03 62       	if NE jump (m) Lc_vol_ctlr_disconnect_3;

8420090c <Lc_vol_ctlr_disconnect_2>:
    {
        return FALSE;
8420090c:	02 00       	r0 = Null + Null;
8420090e:	92 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

84200910 <Lc_vol_ctlr_disconnect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id))
84200910:	3b 00       	r1 = r5 + Null;
84200912:	42 08       	r0 = r6 + Null;
84200914:	ef fd fd ff 	call (m) 0x496;
84200918:	23 ec 
8420091a:	10 04       	Null = r0 - Null;
8420091c:	08 62       	if NE jump (m) Lc_vol_ctlr_disconnect_6;

8420091e <Lc_vol_ctlr_disconnect_4>:
8420091e:	01 f0 00 60 	rMAC = Null + 4096;
84200922:	92 f0 00 e8 	r0 = M[r7 + Null];
84200926:	51 8e       	M[r0 + 4] = rMAC;

84200928 <Lc_vol_ctlr_disconnect_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84200928:	42 20       	r0 = Null + 1;
8420092a:	84 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

8420092c <Lc_vol_ctlr_disconnect_6>:
    }

    if (opmgr_op_is_running(op_data))
8420092c:	42 08       	r0 = r6 + Null;
8420092e:	ff fd 26 f0 	call (m) 0x5700;
84200932:	33 ee 
84200934:	10 04       	Null = r0 - Null;
84200936:	07 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_9;

84200938 <Lc_vol_ctlr_disconnect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
84200938:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420093c:	00 00 
8420093e:	f0 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

84200940 <Lc_vol_ctlr_disconnect_8>:
84200940:	39 c0       	rMAC = r5 AND 0x1;
84200942:	ee 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

84200944 <Lc_vol_ctlr_disconnect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
84200944:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200948:	00 00 
8420094a:	50 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_28;

8420094c <Lc_vol_ctlr_disconnect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
8420094c:	3a 50       	r0 = r5 LSHIFT -1;
8420094e:	29 f0 1f 00 	r7 = r0 AND 0x1f;

        if(terminal_id&0x1)
84200952:	39 c0       	rMAC = r5 AND 0x1;
84200954:	2f 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_19;

84200956 <Lc_vol_ctlr_disconnect_11>:
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_aux_channel == &op_extra_data->aux_channel[term_idx])
84200956:	02 f9 d2 c8 	r0 = r7 LSHIFT 4;
8420095a:	31 00       	rMAC = r4 + Null;
8420095c:	51 00       	rMAC = r0 + rMAC;
8420095e:	17 f0 6c 20 	r5 = rMAC + 108;
84200962:	31 a9       	rMAC = M[r4 + 80];
84200964:	c8 05       	Null = rMAC - r5;
84200966:	10 62       	if NE jump (m) Lc_vol_ctlr_disconnect_18;

84200968 <Lc_vol_ctlr_disconnect_12>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
84200968:	01 00       	rMAC = Null + Null;
8420096a:	62 f0 6c 20 	r0 = r4 + 108;

8420096e <Lc_vol_ctlr_disconnect_13>:
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
                {
                    if (i == term_idx)
8420096e:	9f f1 00 c2 	Null = rMAC - r7;
84200972:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

84200974 <Lc_vol_ctlr_disconnect_14>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
84200974:	13 e8       	r1 = M[r0 + Null];
84200976:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

84200978 <Lc_vol_ctlr_disconnect_15>:
84200978:	9b 89       	r1 = M[r1 + 24];
8420097a:	50 62       	if NE jump (m) Lc_vol_ctlr_disconnect_36;

8420097c <Lc_vol_ctlr_disconnect_16>:
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
8420097c:	49 20       	rMAC = rMAC + 1;
8420097e:	12 28       	r0 = r0 + 16;
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
84200980:	08 26       	Null = rMAC - 8;
84200982:	f6 65       	if NC jump (m) Lc_vol_ctlr_disconnect_13;

84200984 <Lc_vol_ctlr_disconnect_17>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_aux_channel = NULL;
84200984:	30 af       	M[r4 + 80] = Null;

84200986 <Lc_vol_ctlr_disconnect_18>:
                }
            }
#endif /* INSTALL_METADATA */
            opmgr_op_suspend_processing(op_data);
84200986:	42 08       	r0 = r6 + Null;
84200988:	ff fd 26 f0 	call (m) 0x570c;
8420098c:	25 ec 
            op_extra_data->aux_connected &= ~(1<<term_idx);
8420098e:	00 f9 92 de 	r0 = 0x1 LSHIFT r7;
84200992:	ff f2 51 d6 	rMAC = -1 - r0;
84200996:	62 f0 b7 88 	r0 = M[r4 + 732];
8420099a:	89 10       	rMAC = rMAC AND r0;
8420099c:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = NULL;
842009a0:	38 ee       	M[r5 + Null] = Null;
            opmgr_op_resume_processing(op_data);
842009a2:	42 08       	r0 = r6 + Null;
842009a4:	ff fd 26 f0 	call (m) 0x573a;
842009a8:	37 ec 
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
842009aa:	32 00       	r0 = r4 + Null;
842009ac:	05 f0 3b e8 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
842009b0:	bc 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

842009b2 <Lc_vol_ctlr_disconnect_19>:
        }
        else
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
842009b2:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842009b6:	31 00       	rMAC = r4 + Null;
842009b8:	51 00       	rMAC = r0 + rMAC;
842009ba:	b2 a8       	r0 = M[r4 + 72];
842009bc:	0b e8       	r1 = M[rMAC + Null];
842009be:	d0 04       	Null = r0 - r1;
842009c0:	0f 62       	if NE jump (m) Lc_vol_ctlr_disconnect_26;

842009c2 <Lc_vol_ctlr_disconnect_20>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009c2:	03 00       	r1 = Null + Null;
842009c4:	32 00       	r0 = r4 + Null;

842009c6 <Lc_vol_ctlr_disconnect_21>:
                {
                    if (i == term_idx)
842009c6:	9f f3 00 c2 	Null = r1 - r7;
842009ca:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009cc <Lc_vol_ctlr_disconnect_22>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
842009cc:	14 e8       	r2 = M[r0 + Null];
842009ce:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009d0 <Lc_vol_ctlr_disconnect_23>:
842009d0:	a4 89       	r2 = M[r2 + 24];
842009d2:	26 62       	if NE jump (m) Lc_vol_ctlr_disconnect_37;

842009d4 <Lc_vol_ctlr_disconnect_24>:
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009d4:	5b 20       	r1 = r1 + 1;
842009d6:	12 21       	r0 = r0 + 4;
842009d8:	18 26       	Null = r1 - 8;
842009da:	f6 65       	if NC jump (m) Lc_vol_ctlr_disconnect_21;

842009dc <Lc_vol_ctlr_disconnect_25>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_ip_buffer = NULL;
842009dc:	b0 ae       	M[r4 + 72] = Null;

842009de <Lc_vol_ctlr_disconnect_26>:
                }
            }
#endif /* INSTALL_METADATA */
            op_extra_data->input_buffer[term_idx] = NULL;
842009de:	08 ee       	M[rMAC + Null] = Null;

842009e0 <Lc_vol_ctlr_disconnect_27>:
                op_extra_data->metadata_op_buffer = NULL;
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842009e0:	3b 00       	r1 = r5 + Null;
842009e2:	32 00       	r0 = r4 + Null;
842009e4:	05 f0 21 e7 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;
842009e8:	a0 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

842009ea <Lc_vol_ctlr_disconnect_28>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842009ea:	ba c2       	r0 = r5 AND 0x3f;
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
842009ec:	53 54       	r1 = r0 LSHIFT 2;
842009ee:	31 00       	rMAC = r4 + Null;
842009f0:	59 00       	rMAC = r1 + rMAC;
842009f2:	09 30       	rMAC = rMAC + 32;
842009f4:	f3 a8       	r1 = M[r4 + 76];
842009f6:	0c e8       	r2 = M[rMAC + Null];
842009f8:	18 05       	Null = r1 - r2;
842009fa:	0e 62       	if NE jump (m) Lc_vol_ctlr_disconnect_35;

842009fc <Lc_vol_ctlr_disconnect_29>:
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009fc:	03 00       	r1 = Null + Null;
842009fe:	34 30       	r2 = r4 + 32;

84200a00 <Lc_vol_ctlr_disconnect_30>:
            {
                if (i == term_idx)
84200a00:	98 04       	Null = r1 - r0;
84200a02:	05 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

84200a04 <Lc_vol_ctlr_disconnect_31>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
84200a04:	25 e8       	r3 = M[r2 + Null];
84200a06:	03 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

84200a08 <Lc_vol_ctlr_disconnect_32>:
84200a08:	ad 89       	r3 = M[r3 + 24];
84200a0a:	0e 62       	if NE jump (m) Lc_vol_ctlr_disconnect_38;

84200a0c <Lc_vol_ctlr_disconnect_33>:
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
84200a0c:	5b 20       	r1 = r1 + 1;
84200a0e:	24 21       	r2 = r2 + 4;
84200a10:	18 26       	Null = r1 - 8;
84200a12:	f7 65       	if NC jump (m) Lc_vol_ctlr_disconnect_30;

84200a14 <Lc_vol_ctlr_disconnect_34>:
                    break;
                }
            }
            if (!found_alternative)
            {
                op_extra_data->metadata_op_buffer = NULL;
84200a14:	f0 ae       	M[r4 + 76] = Null;

84200a16 <Lc_vol_ctlr_disconnect_35>:
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
84200a16:	08 ee       	M[rMAC + Null] = Null;
84200a18:	e4 6f       	jump (m) Lc_vol_ctlr_disconnect_27;

84200a1a <Lc_vol_ctlr_disconnect_36>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
                    {
                        op_extra_data->metadata_aux_channel = aux_chan;
84200a1a:	32 af       	M[r4 + 80] = r0;
                        found_alternative = TRUE;
                        break;
84200a1c:	b5 6f       	jump (m) Lc_vol_ctlr_disconnect_18;

84200a1e <Lc_vol_ctlr_disconnect_37>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
                    {
                        op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[i];
84200a1e:	5a 54       	r0 = r1 LSHIFT 2;
84200a20:	b2 e8       	r0 = M[r4 + r0];
84200a22:	b2 ae       	M[r4 + 72] = r0;
                        found_alternative = TRUE;
                        break;
84200a24:	dd 6f       	jump (m) Lc_vol_ctlr_disconnect_26;

84200a26 <Lc_vol_ctlr_disconnect_38>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
                {
                    op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[i];
84200a26:	5b 54       	r1 = r1 LSHIFT 2;
84200a28:	32 00       	r0 = r4 + Null;
84200a2a:	9a 00       	r0 = r1 + r0;
84200a2c:	12 98       	r0 = M[r0 + 32];
84200a2e:	f2 ae       	M[r4 + 76] = r0;
                    found_alternative = TRUE;
                    break;
84200a30:	f3 6f       	jump (m) Lc_vol_ctlr_disconnect_35;

84200a32 <Lc_vol_ctlr_disconnect_39>:
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }

    return TRUE;
}
84200a32:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200a34:	d8 4c       	rts;

84200a36 <$_vol_ctlr_start>:

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200a36:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200a38:	17 00       	r5 = r0 + Null;
84200a3a:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200a3c:	ef fd fd ff 	call (m) 0x4e6;
84200a40:	2b e5 
84200a42:	16 00       	r4 = r0 + Null;

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    /* Setup Response to Start Request.   Assume Failure*/
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200a44:	03 00       	r1 = Null + Null;
84200a46:	44 08       	r2 = r6 + Null;
84200a48:	3a 00       	r0 = r5 + Null;
84200a4a:	ef fd fd ff 	call (m) 0x4bc;
84200a4e:	33 e3 
84200a50:	10 04       	Null = r0 - Null;
84200a52:	03 62       	if NE jump (m) Lc_vol_ctlr_start_3;

84200a54 <Lc_vol_ctlr_start_2>:
    {
        return FALSE;
84200a54:	02 00       	r0 = Null + Null;
84200a56:	39 6e       	jump (m) Lc_vol_ctlr_start_11;

84200a58 <Lc_vol_ctlr_start_3>:
    }

    if (opmgr_op_is_running(op_data))
84200a58:	3a 00       	r0 = r5 + Null;
84200a5a:	ff fd 26 f0 	call (m) 0x5700;
84200a5e:	27 e5 
84200a60:	10 04       	Null = r0 - Null;
84200a62:	32 62       	if NE jump (m) Lc_vol_ctlr_start_10;

84200a64 <Lc_vol_ctlr_start_4>:
    {
        return TRUE;
    }

    if (!setup_processing(op_extra_data))
84200a64:	32 00       	r0 = r4 + Null;
84200a66:	fd ff 2b ec 	call (m) .L0;
84200a6a:	10 04       	Null = r0 - Null;
84200a6c:	06 62       	if NE jump (m) Lc_vol_ctlr_start_6;

84200a6e <Lc_vol_ctlr_start_5>:
84200a6e:	01 f0 00 60 	rMAC = Null + 4096;
84200a72:	82 f0 00 e8 	r0 = M[r6 + Null];
84200a76:	51 8e       	M[r0 + 4] = rMAC;

84200a78 <Lc_vol_ctlr_start_6>:
     *
     * User can set that via DOWNSTREAM_LATENCY_EST parameter, if hasn't
     * been set by the user we will find a suitable value.
     */
    op_extra_data->downstream_latency_estimate =
        VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data)*MILLISECOND;
84200a78:	61 f0 d2 88 	rMAC = M[r4 + 840];
84200a7c:	03 f0 e8 f1 	rMAC = rMAC * 1000 (int);
84200a80:	91 d9 
    if(0 == op_extra_data->downstream_latency_estimate &&
       NULL != op_extra_data->metadata_op_buffer)
84200a82:	61 f0 d0 8e 	M[r4 + 832] = rMAC;
84200a86:	18 62       	if NE jump (m) Lc_vol_ctlr_start_9;

84200a88 <Lc_vol_ctlr_start_7>:
84200a88:	f2 a8       	r0 = M[r4 + 76];
84200a8a:	16 60       	if EQ jump (m) Lc_vol_ctlr_start_9;

84200a8c <Lc_vol_ctlr_start_8>:
        /* user hasn't set the parameter, a good achievable latency with the
         * assumption that the operator's output buffer is directly consumed
         * by a timed playback module at the end of chain is 75% of the buffers
         * size plus one system kick period.
         */
        unsigned buf_size = cbuffer_get_size_in_words(op_extra_data->metadata_op_buffer);
84200a8c:	ff fd 9c f0 	call (m) 0x14450;
84200a90:	25 ee 
84200a92:	10 09       	r6 = r0 + Null;
        op_extra_data->downstream_latency_estimate =
            convert_samples_to_time(buf_size, op_extra_data->sample_rate)*3/4 +
            stream_if_get_system_kick_period();
84200a94:	ff fd 3b f0 	call (m) 0x8146;
84200a98:	33 e5 
84200a9a:	17 00       	r5 = r0 + Null;
84200a9c:	63 f0 3b 88 	r1 = M[r4 + 236];
84200aa0:	42 08       	r0 = r6 + Null;
84200aa2:	ff fd bc f0 	call (m) 0x183fe;
84200aa6:	3d ea 
84200aa8:	d2 40       	r0 = r0 * 3 (int);
84200aaa:	01 21       	rMAC = Null + 4;
84200aac:	8a 4c       	Div = r0 / rMAC;
84200aae:	c1 4c       	rMAC = DivResult;
84200ab0:	79 00       	rMAC = r5 + rMAC;
84200ab2:	61 f0 d0 8e 	M[r4 + 832] = rMAC;

84200ab6 <Lc_vol_ctlr_start_9>:
    }
    /* Reset timestamp references used for aux TTP*/
    op_extra_data->current_timestamp_valid = FALSE;
84200ab6:	60 f0 cd 8e 	M[r4 + 820] = Null;
    op_extra_data->main_timestamp_valid = FALSE;
84200aba:	60 f0 ca 8e 	M[r4 + 808] = Null;
    op_extra_data->prev_consumed_samples = 0;
84200abe:	60 f0 cf 8e 	M[r4 + 828] = Null;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
84200ac2:	60 f0 c8 8e 	M[r4 + 800] = Null;

84200ac6 <Lc_vol_ctlr_start_10>:
        return FALSE;
    }

    if (opmgr_op_is_running(op_data))
    {
        return TRUE;
84200ac6:	42 20       	r0 = Null + 1;

84200ac8 <Lc_vol_ctlr_start_11>:
    op_extra_data->prev_consumed_samples = 0;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
#endif /* VOLUME_CONTROL_AUX_TTP_SUPPORT */

    return TRUE;
}
84200ac8:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200aca:	d8 4c       	rts;

84200acc <$_vol_ctlr_buffer_details>:
    return TRUE;
}


bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200acc:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200ace:	12 09       	r8 = r0 + Null;
84200ad0:	1e 00       	r4 = r1 + Null;
84200ad2:	23 09       	r9 = r2 + Null;
84200ad4:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200ad6:	ef fd fd ff 	call (m) 0x4e6;
84200ada:	31 e0 
84200adc:	10 09       	r6 = r0 + Null;
bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T* opx_data = get_instance_data(op_data);
    OP_BUF_DETAILS_RSP *resp;
    unsigned buffer_size, base_buffer_size;
    unsigned terminal_id = OPMGR_GET_OP_BUF_DETAILS_TERMINAL_ID(message_data);
84200ade:	69 f0 00 e8 	r7 = M[r4 + Null];
#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    unsigned term_idx;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200ae2:	3d 00       	r3 = r5 + Null;
84200ae4:	5c 08       	r2 = r9 + Null;
84200ae6:	33 00       	r1 = r4 + Null;
84200ae8:	52 08       	r0 = r8 + Null;
84200aea:	ef fd fc ff 	call (m) 0x37c;
84200aee:	33 e4 
84200af0:	10 04       	Null = r0 - Null;
84200af2:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_3;

84200af4 <Lc_vol_ctlr_buffer_details_2>:
    {
        return FALSE;
84200af4:	02 00       	r0 = Null + Null;
84200af6:	86 6e       	jump (m) Lc_vol_ctlr_buffer_details_25;

84200af8 <Lc_vol_ctlr_buffer_details_3>:
    }

    resp = (OP_BUF_DETAILS_RSP*)*response_data;
84200af8:	3e e8       	r4 = M[r5 + Null];
    base_buffer_size = resp->b.buffer_size + VOL_CTRL_BUFFER_SIZE_PROVISION;
84200afa:	31 89       	rMAC = M[r4 + 16];
84200afc:	89 21       	rMAC = rMAC + 6;
        /* If an input/output connection is already present and has metadata then
         * we are obliged to return that buffer so that metadata can be shared
         * between channels. */
        tCbuffer *meta_buff;

        if ((terminal_id & TERMINAL_SINK_MASK) == TERMINAL_SINK_MASK)
84200afe:	40 f0 92 f0 	r0 = r7 AND 0x800000;
84200b02:	00 00 
84200b04:	5b 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_21;

84200b06 <Lc_vol_ctlr_buffer_details_4>:
        {
            /* Only the main input channels consume metadata, the aux inputs do not */
            if ((terminal_id & 0x1) == 0)
84200b06:	92 f0 01 00 	r0 = r7 AND 0x1;
84200b0a:	04 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_6;

84200b0c <Lc_vol_ctlr_buffer_details_5>:
            {
                meta_buff = opx_data->metadata_ip_buffer;
84200b0c:	82 f0 12 88 	r0 = M[r6 + 72];
84200b10:	07 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b12 <Lc_vol_ctlr_buffer_details_6>:
                resp->supports_metadata = TRUE;
            }
            else
            {
                if(NULL != opx_data->metadata_aux_channel)
84200b12:	82 f0 14 88 	r0 = M[r6 + 80];
84200b16:	03 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_8;

84200b18 <Lc_vol_ctlr_buffer_details_7>:
                {
                    meta_buff = opx_data->metadata_aux_channel->buffer;
84200b18:	12 e8       	r0 = M[r0 + Null];
84200b1a:	02 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b1c <Lc_vol_ctlr_buffer_details_8>:
                }
                else
                {
                    meta_buff = NULL;
84200b1c:	02 00       	r0 = Null + Null;

84200b1e <Lc_vol_ctlr_buffer_details_9>:
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
            resp->supports_metadata = TRUE;
84200b1e:	33 92       	r1 = MBU[r4 + 8];
84200b20:	33 ff ef 1f 	r1 = r1 AND 0xffffffef;
84200b24:	db c9       	r1 = r1 OR 0x10;
84200b26:	33 9a       	MB[r4 + 8] = r1;
        }

        resp->metadata_buffer = meta_buff;
84200b28:	f2 8e       	M[r4 + 12] = r0;

    }
#endif /* INSTALL_METADATA */

    /* buffer size of 2.5ms worth at the sample rate of the operator */
    buffer_size = frac_mult(opx_data->sample_rate,FRACTIONAL(0.0025));
84200b2a:	82 f0 3b 88 	r0 = M[r6 + 236];
84200b2e:	05 f0 f3 f0 	r1 = Null + 5368709;
84200b32:	85 53 
84200b34:	3f f2 47 c9 	r5 = r0 * r1 (frac);

    if (buffer_size==0)
84200b38:	38 04       	Null = r5 - Null;
84200b3a:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_11;

84200b3c <Lc_vol_ctlr_buffer_details_10>:
    {
        buffer_size = VOL_CTRL_BUFFER_SIZE;
84200b3c:	07 f0 80 40 	r5 = Null + 128;

84200b40 <Lc_vol_ctlr_buffer_details_11>:
    }

    if (buffer_size < base_buffer_size)
84200b40:	78 04       	Null = r5 - rMAC;
84200b42:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_13;

84200b46 <Lc_vol_ctlr_buffer_details_12>:
    {
        buffer_size = base_buffer_size;
84200b46:	0f 00       	r5 = rMAC + Null;

84200b48 <Lc_vol_ctlr_buffer_details_13>:
    }

#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    if(terminal_id&TERMINAL_SINK_MASK)
84200b48:	40 f0 91 f0 	rMAC = r7 AND 0x800000;
84200b4c:	00 00 
84200b4e:	43 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_23;

84200b50 <Lc_vol_ctlr_buffer_details_14>:
    {
        if(terminal_id&0x1)
84200b50:	91 f0 01 00 	rMAC = r7 AND 0x1;
84200b54:	36 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_22;

84200b56 <Lc_vol_ctlr_buffer_details_15>:
            unsigned aux_min_size, main_buff_size = 0;

            /* Aux input : If we have a main input connected, 
             * try to make sure the aux buffer is at least as big
             */
            if (opx_data->metadata_ip_buffer != NULL)
84200b56:	82 f0 12 88 	r0 = M[r6 + 72];
84200b5a:	08 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_18;

84200b5c <Lc_vol_ctlr_buffer_details_16>:
            {
                main_buff_size = cbuffer_get_size_in_words(opx_data->metadata_ip_buffer);
84200b5c:	ff fd 9c f0 	call (m) 0x14450;
84200b60:	35 e7 
            }

            if (buffer_size < main_buff_size)
84200b62:	b8 04       	Null = r5 - r0;
84200b64:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_18;

84200b68 <Lc_vol_ctlr_buffer_details_17>:
            {
                buffer_size = main_buff_size;
84200b68:	17 00       	r5 = r0 + Null;

84200b6a <Lc_vol_ctlr_buffer_details_18>:
            }

            /* Aux buffer should be at least 2 kick periods at the system sample rate */
            aux_min_size = 2 * (uint32)(((uint64)stream_if_get_system_kick_period() 
                * opx_data->sample_rate) / SECOND);
84200b6a:	ff fd 3a f0 	call (m) 0x8146;
84200b6e:	3d ee 
84200b70:	84 f0 3b 88 	r2 = M[r6 + 236];
84200b74:	93 5b       	r1 = r0 ASHIFT -31;
84200b76:	05 00       	r3 = Null + Null;
84200b78:	3f f4 01 cc 	rMAC = r2 * r1 (UU);
84200b7c:	c9 57       	rMAC = rMAC LSHIFT 32 (56bit);
84200b7e:	2f f4 01 ca 	rMAC = rMAC + r2 * r0 (UU);
84200b82:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
84200b84:	00 f0 a4 f7 	r2 = Null + 1000000;
84200b88:	40 42 
84200b8a:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
84200b8e:	ca 57       	r0 = rMAC LSHIFT 32;
84200b90:	ff fd cb f0 	call (m) 0x1a208;
84200b94:	39 e3 
84200b96:	12 54       	r0 = r0 LSHIFT 1;
            
            if (buffer_size < aux_min_size)
84200b98:	b8 04       	Null = r5 - r0;
84200b9a:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_20;

84200b9e <Lc_vol_ctlr_buffer_details_19>:
            {
                buffer_size = aux_min_size;
84200b9e:	17 00       	r5 = r0 + Null;

84200ba0 <Lc_vol_ctlr_buffer_details_20>:
            }

            /* Don't run in place on the aux inputs. */
            resp->runs_in_place = FALSE;
84200ba0:	31 92       	rMAC = MBU[r4 + 8];
84200ba2:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200ba6:	31 9a       	MB[r4 + 8] = rMAC;

            /* Set the asked buffer size. */
            resp->b.buffer_size = buffer_size;
84200ba8:	37 8f       	M[r4 + 16] = r5;
            opx_data->aux_buff_size = buffer_size;
84200baa:	87 f0 bb 8e 	M[r6 + 748] = r5;

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200bae:	34 00       	r2 = r4 + Null;
84200bb0:	4b 08       	r1 = r7 + Null;
84200bb2:	42 08       	r0 = r6 + Null;
84200bb4:	04 f0 2d e8 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;
84200bb8:	25 6e       	jump (m) Lc_vol_ctlr_buffer_details_25;

84200bba <Lc_vol_ctlr_buffer_details_21>:
                resp->supports_metadata = TRUE;
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
84200bba:	82 f0 13 88 	r0 = M[r6 + 76];
84200bbe:	b0 6f       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200bc0 <Lc_vol_ctlr_buffer_details_22>:

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
        }
        else
        {
            term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
84200bc0:	7f f9 d2 d8 	r0 = r7 LSHIFT -1;
84200bc4:	12 c2       	r0 = r0 AND 0x1f;

            /*input terminal. give the output buffer for the channel */
            resp->b.in_place_buff_params.buffer = opx_data->output_buffer[term_idx] ;
84200bc6:	53 54       	r1 = r0 LSHIFT 2;
84200bc8:	41 08       	rMAC = r6 + Null;
84200bca:	59 00       	rMAC = r1 + rMAC;
84200bcc:	09 98       	rMAC = M[rMAC + 32];
84200bce:	b1 8f       	M[r4 + 24] = rMAC;

            /* Choose terminal associated with the term_idx. */
            resp->b.in_place_buff_params.in_place_terminal = term_idx;
84200bd0:	32 8f       	M[r4 + 16] = r0;
84200bd2:	0d 6e       	jump (m) Lc_vol_ctlr_buffer_details_24;

84200bd4 <Lc_vol_ctlr_buffer_details_23>:
        }
    }
    else
    {
        /* The output terminal index is directly mapped to the input_buffer array */
        unsigned buffer_idx = (terminal_id&TERMINAL_NUM_MASK);
84200bd4:	92 f0 3f 00 	r0 = r7 AND 0x3f;
        /* The input terminal index is the buffer index multiplied by 2. */
        term_idx = buffer_idx << 1;
84200bd8:	13 54       	r1 = r0 LSHIFT 1;

        /*output terminal. give the input buffer for the channel */
        resp->b.in_place_buff_params.buffer = opx_data->input_buffer[buffer_idx];
84200bda:	52 54       	r0 = r0 LSHIFT 2;
84200bdc:	81 f0 02 e8 	rMAC = M[r6 + r0];
84200be0:	b1 8f       	M[r4 + 24] = rMAC;

        /* Choose terminal associated with the term_idx. */
        resp->b.in_place_buff_params.in_place_terminal = term_idx | TERMINAL_SINK_MASK;
84200be2:	08 f0 00 f0 	rMAC = r1 OR 0x800000;
84200be6:	00 f3 51 c8 
84200bea:	31 8f       	M[r4 + 16] = rMAC;

84200bec <Lc_vol_ctlr_buffer_details_24>:
    }

    /* Run in place*/
    resp->runs_in_place = TRUE;
84200bec:	31 92       	rMAC = MBU[r4 + 8];
84200bee:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200bf2:	49 c9       	rMAC = rMAC OR 0x8;
84200bf4:	31 9a       	MB[r4 + 8] = rMAC;

    /* Set the asked buffer size. */
    resp->b.in_place_buff_params.size = buffer_size;
84200bf6:	77 8f       	M[r4 + 20] = r5;

#else  /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */
    resp->b.buffer_size = buffer_size;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200bf8:	34 00       	r2 = r4 + Null;
84200bfa:	4b 08       	r1 = r7 + Null;
84200bfc:	42 08       	r0 = r6 + Null;
84200bfe:	04 f0 23 e6 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;

84200c02 <Lc_vol_ctlr_buffer_details_25>:
}
84200c02:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200c04:	d8 4c       	rts;

84200c06 <$_vol_ctlr_get_sched_info>:

    return TRUE;
}

bool vol_ctlr_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200c06:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200c08:	17 00       	r5 = r0 + Null;
84200c0a:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84200c0c:	ef fd fc ff 	call (m) 0x41c;
84200c10:	31 e0 
    if (resp == NULL)
84200c12:	10 04       	Null = r0 - Null;
84200c14:	09 62       	if NE jump (m) Lc_vol_ctlr_get_sched_info_3;

84200c16 <Lc_vol_ctlr_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200c16:	03 f0 00 60 	r1 = Null + 4096;
84200c1a:	34 00       	r2 = r4 + Null;
84200c1c:	3a 00       	r0 = r5 + Null;
84200c1e:	ef fd fc ff 	call (m) 0x4bc;
84200c22:	3f e4 
84200c24:	05 6e       	jump (m) Lc_vol_ctlr_get_sched_info_4;

84200c26 <Lc_vol_ctlr_get_sched_info_3>:
    }
    *response_data = resp;
84200c26:	32 ee       	M[r4 + Null] = r0;

    resp->block_size = VOL_CTRL_BLOCK_SIZE;
84200c28:	41 20       	rMAC = Null + 1;
84200c2a:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84200c2c:	0a 00       	r0 = rMAC + Null;

84200c2e <Lc_vol_ctlr_get_sched_info_4>:
}
84200c2e:	f2 48       	popm <FP, r4, r5, rLink>;
84200c30:	d8 4c       	rts;

84200c32 <$_vol_ctlr_timer_task>:

    return TRUE;
}

void vol_ctlr_timer_task(void *kick_object)
{
84200c32:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200c34:	16 00       	r4 = r0 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200c36:	ef fd fc ff 	call (m) 0x4e6;
84200c3a:	31 e5 
84200c3c:	17 00       	r5 = r0 + Null;
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) kick_object;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    base_op_profiler_start(op_data);
84200c3e:	32 00       	r0 = r4 + Null;
84200c40:	ef fd fc ff 	call (m) 0x51e;
84200c44:	3f e6 

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200c46:	70 f0 be 8e 	M[r5 + 760] = Null;

    /* Raise a bg int to process */
    opmgr_kick_operator(op_data);
84200c4a:	32 00       	r0 = r4 + Null;
84200c4c:	ff fd 15 f0 	call (m) 0x374a;
84200c50:	3f e7 

    base_op_profiler_stop(op_data);
84200c52:	32 00       	r0 = r4 + Null;
84200c54:	ef fd fc ff 	call (m) 0x52c;
84200c58:	39 e6 

84200c5a <Lc_vol_ctlr_timer_task_2>:
}
84200c5a:	f2 48       	popm <FP, r4, r5, rLink>;
84200c5c:	d8 4c       	rts;

84200c5e <$_vol_ctlr_process_data>:
}
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */

RUN_FROM_PM_RAM
void vol_ctlr_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200c5e:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200c60:	42 de       	M[FP + 32] = r0;
84200c62:	4b de       	M[FP + 36] = r1;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200c64:	ef fd fc ff 	call (m) 0x4e6;
84200c68:	23 e4 
84200c6a:	12 09       	r8 = r0 + Null;
    unsigned         i,samples_to_process,num_channels,amount,touched_sink;
    unsigned         block_size = VOL_CTRL_BLOCK_SIZE;

    patch_fn(volume_control_process_data_patch);

    op_extra_data->used_all_input = FALSE;
84200c6c:	a0 f0 bd 8e 	M[r8 + 756] = Null;

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    uint32 packed_aux_state = pack_aux_state(op_extra_data);
84200c70:	06 f0 29 e0 	call (m) Lc_pack_aux_state_1;
84200c74:	52 de       	M[FP + 40] = r0;
#endif

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update timestamp for using aux TTP */
    vol_ctrl_update_current_timestamp(op_extra_data);
84200c76:	52 08       	r0 = r8 + Null;
84200c78:	05 f0 21 e0 	call (m) Lc_vol_ctrl_update_current_timestamp_1;
#endif

    /* Accelerators for data/space */
    samples_to_process = MAXINT;
84200c7c:	ff f7 f8 f7 	r6 = Null + 2147483647;
84200c80:	ff 7b 
    if(op_extra_data->stream_based)
84200c82:	a0 f0 c3 88 	Null = M[r8 + 780];
84200c86:	03 60       	if EQ jump (m) Lc_vol_ctlr_process_data_3;

84200c88 <Lc_vol_ctlr_process_data_2>:
    {
        num_channels = 1;
84200c88:	0b 71       	r9 = Null + 1;
84200c8a:	25 6e       	jump (m) Lc_vol_ctlr_process_data_12;

84200c8c <Lc_vol_ctlr_process_data_3>:
    }
    else
    {
        if(op_extra_data->wait_on_space_buffer)
84200c8c:	a2 f0 10 88 	r0 = M[r8 + 64];
84200c90:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_7;

84200c92 <Lc_vol_ctlr_process_data_4>:
        {
            samples_to_process = cbuffer_calc_amount_space_in_words(op_extra_data->wait_on_space_buffer);
84200c92:	ff fd c8 f1 	call (m) 0x39d88;
84200c96:	37 e7 
84200c98:	10 09       	r6 = r0 + Null;
            if(samples_to_process<block_size)
84200c9a:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_6;

84200c9c <Lc_vol_ctlr_process_data_5>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE_LATE);
84200c9c:	c4 20       	r2 = Null + 3;
84200c9e:	52 08       	r0 = r8 + Null;
84200ca0:	4b d8       	r1 = M[FP + 36];
84200ca2:	04 f0 39 e2 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200ca6:	0f f0 8f e7 	jump (m) Lc_vol_ctlr_process_data_79;

84200caa <Lc_vol_ctlr_process_data_6>:
                return;
            }
            op_extra_data->wait_on_space_buffer=NULL;
84200caa:	a0 f0 10 8e 	M[r8 + 64] = Null;

84200cae <Lc_vol_ctlr_process_data_7>:
        }
        if(op_extra_data->wait_on_data_buffer)
84200cae:	a2 f0 11 88 	r0 = M[r8 + 68];
84200cb2:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_11;

84200cb4 <Lc_vol_ctlr_process_data_8>:
        {
            amount = cbuffer_calc_amount_data_in_words(op_extra_data->wait_on_data_buffer);
84200cb4:	ff fd c8 f1 	call (m) 0x39dd4;
84200cb8:	21 e9 
            if(amount<block_size)
84200cba:	10 04       	Null = r0 - Null;
84200cbc:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_10;

84200cbe <Lc_vol_ctlr_process_data_9>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA_LATE);
84200cbe:	84 20       	r2 = Null + 2;
84200cc0:	52 08       	r0 = r8 + Null;
84200cc2:	4b d8       	r1 = M[FP + 36];
84200cc4:	04 f0 37 e1 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200cc8:	0f f0 ed e6 	jump (m) Lc_vol_ctlr_process_data_79;

84200ccc <Lc_vol_ctlr_process_data_10>:
                return;
            }
            op_extra_data->wait_on_data_buffer=NULL;
84200ccc:	a0 f0 11 8e 	M[r8 + 68] = Null;

84200cd0 <Lc_vol_ctlr_process_data_11>:
        }
        num_channels = op_extra_data->num_channels;
84200cd0:	ab f0 17 88 	r9 = M[r8 + 92];

84200cd4 <Lc_vol_ctlr_process_data_12>:
84200cd4:	41 20       	rMAC = Null + 1;
84200cd6:	59 de       	M[FP + 44] = rMAC;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200cd8:	06 00       	r4 = Null + Null;
84200cda:	05 6e       	jump (m) Lc_vol_ctlr_process_data_15;

84200cdc <Lc_vol_ctlr_process_data_13>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
                return;
            }
            samples_to_process=amount;
84200cdc:	10 09       	r6 = r0 + Null;
            op_extra_data->used_all_input = FALSE;
84200cde:	a0 f0 bd 8e 	M[r8 + 756] = Null;

84200ce2 <Lc_vol_ctlr_process_data_14>:
        }
        num_channels = op_extra_data->num_channels;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200ce2:	76 20       	r4 = r4 + 1;

84200ce4 <Lc_vol_ctlr_process_data_15>:
84200ce4:	bf f6 00 c2 	Null = r4 - r9;
84200ce8:	02 f0 f1 e0 	if C jump (m) Lc_vol_ctlr_process_data_23;

84200cec <Lc_vol_ctlr_process_data_16>:
    {
        unsigned term_idx = op_extra_data->channels[i].chan_idx;
84200cec:	a1 f0 1a 88 	rMAC = M[r8 + 104];
84200cf0:	12 f6 92 c9 	r0 = r4 * 36 (int);
84200cf4:	8a e8       	r0 = M[rMAC + r0];
        tCbuffer *buffer;

      buffer = op_extra_data->input_buffer[term_idx];
84200cf6:	52 54       	r0 = r0 LSHIFT 2;
84200cf8:	51 08       	rMAC = r8 + Null;
84200cfa:	51 00       	rMAC = r0 + rMAC;
84200cfc:	0f 00       	r5 = rMAC + Null;
84200cfe:	79 f0 00 e8 	r7 = M[r5 + Null];
      amount = cbuffer_calc_amount_data_in_words(buffer);
84200d02:	4a 08       	r0 = r7 + Null;
84200d04:	ff fd c8 f1 	call (m) 0x39dd4;
84200d08:	31 e6 
      if(amount<=samples_to_process)
84200d0a:	8f f2 00 c2 	Null = r0 - r6;
84200d0e:	08 f0 a3 e0 	if HI jump (m) Lc_vol_ctlr_process_data_20;

84200d12 <Lc_vol_ctlr_process_data_17>:
      {
            if(amount < block_size)
84200d12:	10 04       	Null = r0 - Null;
84200d14:	0a 62       	if NE jump (m) Lc_vol_ctlr_process_data_19;

84200d16 <Lc_vol_ctlr_process_data_18>:
            {
                op_extra_data->wait_on_data_buffer = buffer;
84200d16:	a9 f0 11 8e 	M[r8 + 68] = r7;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA);
84200d1a:	04 00       	r2 = Null + Null;
84200d1c:	52 08       	r0 = r8 + Null;
84200d1e:	4b d8       	r1 = M[FP + 36];
84200d20:	03 f0 3b ee 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200d24:	0f f0 91 e6 	jump (m) Lc_vol_ctlr_process_data_79;

84200d28 <Lc_vol_ctlr_process_data_19>:
                return;
            }
            samples_to_process=amount;
84200d28:	10 09       	r6 = r0 + Null;
            op_extra_data->used_all_input = TRUE;
84200d2a:	59 d8       	rMAC = M[FP + 44];
84200d2c:	a1 f0 bd 8e 	M[r8 + 756] = rMAC;

84200d30 <Lc_vol_ctlr_process_data_20>:
        }

        buffer = op_extra_data->output_buffer[term_idx];
84200d30:	3f 98       	r5 = M[r5 + 32];
        amount = cbuffer_calc_amount_space_in_words(buffer);
84200d32:	3a 00       	r0 = r5 + Null;
84200d34:	ff fd c8 f1 	call (m) 0x39d88;
84200d38:	35 e2 

        /* Relatively likely to need changes below */
        patch_fn(volume_control_adjust_amount);

        if(amount<samples_to_process)
84200d3a:	8f f2 00 c2 	Null = r0 - r6;
84200d3e:	f2 ff a5 ef 	if C jump (m) Lc_vol_ctlr_process_data_14;

84200d42 <Lc_vol_ctlr_process_data_21>:
        {
            if(amount<block_size)
84200d42:	10 04       	Null = r0 - Null;
84200d44:	cc 63       	if NE jump (m) Lc_vol_ctlr_process_data_13;

84200d46 <Lc_vol_ctlr_process_data_22>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
84200d46:	a7 f0 10 8e 	M[r8 + 64] = r5;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
84200d4a:	44 20       	r2 = Null + 1;
84200d4c:	52 08       	r0 = r8 + Null;
84200d4e:	4b d8       	r1 = M[FP + 36];
84200d50:	03 f0 2b ed 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200d54:	0f f0 e1 e5 	jump (m) Lc_vol_ctlr_process_data_79;

84200d58 <Lc_vol_ctlr_process_data_23>:
    }

    /* Update AUX state.
       If the aux stream doesn't have enough data it indicates a state change */
    unsigned aux_check = (op_extra_data->aux_active | op_extra_data->aux_connected)
        & VOL_CTRL_CHANNEL_MASK;
84200d58:	a1 f0 b8 88 	rMAC = M[r8 + 736];
84200d5c:	a2 f0 b7 88 	r0 = M[r8 + 732];
84200d60:	89 12       	rMAC = rMAC OR r0;
84200d62:	89 c3       	rMAC = rMAC AND 0xff;
84200d64:	61 de       	M[FP + 48] = rMAC;

    /* Relatively likely to need changes below */
    patch_fn(volume_control_aux_check);

    op_extra_data->tc.num_words = samples_to_process;
84200d66:	a8 f0 b2 8e 	M[r8 + 712] = r6;
    
    if (aux_check != 0)
84200d6a:	08 04       	Null = rMAC - Null;
84200d6c:	ed 60       	if EQ jump (m) Lc_vol_ctlr_process_data_58;

84200d6e <Lc_vol_ctlr_process_data_24>:
    {
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
84200d6e:	03 09       	r9 = Null + Null;
        unsigned aux_limit = MAXINT;
84200d70:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84200d74:	ff 7b 
84200d76:	69 de       	M[FP + 52] = rMAC;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
84200d78:	07 00       	r5 = Null + Null;
84200d7a:	a6 f0 6c 20 	r4 = r8 + 108;

84200d7e <Lc_vol_ctlr_process_data_25>:
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
        {
            if (aux_ch->buffer == NULL)
84200d7e:	32 e8       	r0 = M[r4 + Null];
84200d80:	03 62       	if NE jump (m) Lc_vol_ctlr_process_data_27;

84200d82 <Lc_vol_ctlr_process_data_26>:
            {
                aux_ch->advance_buffer = 0;
84200d82:	f0 8e       	M[r4 + 12] = Null;
84200d84:	2f 6e       	jump (m) Lc_vol_ctlr_process_data_34;

84200d86 <Lc_vol_ctlr_process_data_27>:
            }
            else
            {
                amount = cbuffer_calc_amount_data_in_words(aux_ch->buffer);
84200d86:	ff fd c8 f1 	call (m) 0x39dd4;
84200d8a:	2f e2 
84200d8c:	11 09       	r7 = r0 + Null;
                if (op_extra_data->metadata_aux_channel == aux_ch)
84200d8e:	a1 f0 14 88 	rMAC = M[r8 + 80];
84200d92:	88 05       	Null = rMAC - r4;
84200d94:	0b 62       	if NE jump (m) Lc_vol_ctlr_process_data_29;

84200d96 <Lc_vol_ctlr_process_data_28>:
                {
                    amount = pl_min(
                            amount,
                            buff_metadata_available_octets(
                                    aux_ch->buffer)
                                    / OCTETS_PER_SAMPLE);
84200d96:	32 e8       	r0 = M[r4 + Null];
84200d98:	ff fd 9d f0 	call (m) 0x14958;
84200d9c:	21 ee 
84200d9e:	13 00       	r1 = r0 + Null;
84200da0:	4a 08       	r0 = r7 + Null;
84200da2:	5b 50       	r1 = r1 LSHIFT -2;
84200da4:	5f f3 42 ce 	r0 = MIN r1;
84200da8:	11 09       	r7 = r0 + Null;

84200daa <Lc_vol_ctlr_process_data_29>:

                /* Kick back any aux inputs which have no data, regardless
                 * of state. This helps to prime aux sources which have not
                 * started yet, or recover from false stall detections.
                 */
                if (amount == 0)
84200daa:	69 f0 03 8e 	M[r4 + 12] = r7;
84200dae:	09 62       	if NE jump (m) Lc_vol_ctlr_process_data_31;

84200db0 <Lc_vol_ctlr_process_data_30>:
                {
                    touched->sinks |= (2 << (2 * i));
84200db0:	3a 54       	r0 = r5 LSHIFT 1;
84200db2:	49 d8       	rMAC = M[FP + 36];
84200db4:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200db8:	49 88       	rMAC = M[rMAC + 4];
84200dba:	89 12       	rMAC = rMAC OR r0;
84200dbc:	4a d8       	r0 = M[FP + 36];
84200dbe:	51 8e       	M[r0 + 4] = rMAC;

84200dc0 <Lc_vol_ctlr_process_data_31>:
                }

                /* Only active aux inputs limit the amount of data to process,
                 * because in other states, aux data is not consumed.
                 */
                if (aux_ch->state == AUX_STATE_IN_AUX)
84200dc0:	31 81       	rMAC = MBS[r4 + 4];
84200dc2:	88 24       	Null = rMAC - 2;
84200dc4:	0f 62       	if NE jump (m) Lc_vol_ctlr_process_data_34;

84200dc6 <Lc_vol_ctlr_process_data_32>:
                {
                    aux_limit = pl_min(aux_limit, amount);
84200dc6:	6b d8       	r1 = M[FP + 52];
84200dc8:	4a 08       	r0 = r7 + Null;
84200dca:	5f f2 43 ce 	r1 = MIN r0;
84200dce:	6b de       	M[FP + 52] = r1;
                    if (amount < samples_to_process)
84200dd0:	8f f9 00 c2 	Null = r7 - r6;
84200dd4:	02 f0 8f e0 	if C jump (m) Lc_vol_ctlr_process_data_34;

84200dd8 <Lc_vol_ctlr_process_data_33>:
                    {
                        aux_kick |= (2 << (2 * i));
84200dd8:	3a 54       	r0 = r5 LSHIFT 1;
84200dda:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200dde:	00 f2 7b c8 	r9 = r9 OR r0;

84200de2 <Lc_vol_ctlr_process_data_34>:
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
84200de2:	7f 20       	r5 = r5 + 1;
84200de4:	36 28       	r4 = r4 + 16;
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
84200de6:	38 26       	Null = r5 - 8;
84200de8:	cb 65       	if NC jump (m) Lc_vol_ctlr_process_data_25;

84200dea <Lc_vol_ctlr_process_data_35>:
         * 1/2 kick period of being kicked backwards (details see B-255916).
         * Currently there is one overall state for aux_pending, which means
         * that the handling of more than one independent aux source is
         * likely to be flawed (B-255917).
         */
        if (aux_limit >= samples_to_process)
84200dea:	69 d8       	rMAC = M[FP + 52];
84200dec:	8f f1 00 c2 	Null = rMAC - r6;
84200df0:	04 64       	if NC jump (m) Lc_vol_ctlr_process_data_37;

84200df2 <Lc_vol_ctlr_process_data_36>:
        {
            op_extra_data->aux_pending = FALSE;
84200df2:	a0 f0 bc 8e 	M[r8 + 752] = Null;
84200df6:	45 6e       	jump (m) Lc_vol_ctlr_process_data_45;

84200df8 <Lc_vol_ctlr_process_data_37>:
        }
        else
        {
            if (op_extra_data->aux_pending && (aux_limit == 0))
84200df8:	a0 f0 bc 88 	Null = M[r8 + 752];
84200dfc:	1d 60       	if EQ jump (m) Lc_vol_ctlr_process_data_44;

84200dfe <Lc_vol_ctlr_process_data_38>:
84200dfe:	69 d8       	rMAC = M[FP + 52];
84200e00:	0b 62       	if NE jump (m) Lc_vol_ctlr_process_data_41;

84200e02 <Lc_vol_ctlr_process_data_39>:
            {
                /* Since entering aux_pending state, no aux data has arrived */
                if (op_extra_data->pending_timer != TIMER_ID_INVALID)
84200e02:	a0 f0 be 88 	Null = M[r8 + 760];
84200e06:	f6 61       	if EQ jump (m) Lc_vol_ctlr_process_data_36;

84200e08 <Lc_vol_ctlr_process_data_40>:
                {
                    vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_STILL_AUX_PENDING);
84200e08:	44 21       	r2 = Null + 5;
84200e0a:	52 08       	r0 = r8 + Null;
84200e0c:	4b d8       	r1 = M[FP + 36];
84200e0e:	03 f0 2d e7 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200e12:	0f f0 a3 e4 	jump (m) Lc_vol_ctlr_process_data_79;

84200e16 <Lc_vol_ctlr_process_data_41>:
            else
            {
                if (op_extra_data->aux_pending)
                {
                    /* Cleanup the timer before restarting it */
                    timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200e16:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200e1a:	ff fd cf f1 	call (m) 0x3ad3a;
84200e1e:	21 e9 
    if (*timer_id != TIMER_ID_INVALID)
84200e20:	32 e8       	r0 = M[r4 + Null];
84200e22:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_43;

84200e24 <Lc_vol_ctlr_process_data_42>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200e24:	04 00       	r2 = Null + Null;
84200e26:	03 00       	r1 = Null + Null;
84200e28:	ff fd 2a f0 	call (m) 0x6292;
84200e2c:	2b e3 
        *timer_id = TIMER_ID_INVALID;
84200e2e:	30 ee       	M[r4 + Null] = Null;

84200e30 <Lc_vol_ctlr_process_data_43>:
    }
    interrupt_unblock();
84200e30:	ff fd cf f1 	call (m) 0x3ad56;
84200e34:	27 e9 

84200e36 <Lc_vol_ctlr_process_data_44>:
                }

                /* (Re-)Start aux_pending */
                touched->sinks |= aux_kick;
84200e36:	49 d8       	rMAC = M[FP + 36];
84200e38:	0a 00       	r0 = rMAC + Null;
84200e3a:	49 88       	rMAC = M[rMAC + 4];
84200e3c:	00 fb 71 c8 	rMAC = rMAC OR r9;
84200e40:	51 8e       	M[r0 + 4] = rMAC;
                op_extra_data->pending_timer = timer_schedule_event_in(
                    stream_if_get_system_kick_period() / 2,
                    vol_ctlr_timer_task, (void*)op_data );
84200e42:	ff fd 39 f0 	call (m) 0x8146;
84200e46:	25 e8 
84200e48:	42 f0 06 f0 	r4 = Null + 69209139;
84200e4c:	33 58 
84200e4e:	93 53       	r1 = r0 LSHIFT -31;
84200e50:	9a 00       	r0 = r1 + r0;
84200e52:	17 58       	r5 = r0 ASHIFT -1;
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200e54:	ff fd 29 f0 	call (m) 0x6100;
84200e58:	2d e5 
84200e5a:	ba 00       	r0 = r5 + r0;
84200e5c:	33 00       	r1 = r4 + Null;
84200e5e:	44 d8       	r2 = M[FP + 32];
84200e60:	ff fd 29 f0 	call (m) 0x610a;
84200e64:	2b e5 
}
84200e66:	a2 f0 be 8e 	M[r8 + 760] = r0;
                op_extra_data->aux_pending = TRUE;
84200e6a:	41 20       	rMAC = Null + 1;
84200e6c:	a1 f0 bc 8e 	M[r8 + 752] = rMAC;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_AUX_PENDING);
84200e70:	04 21       	r2 = Null + 4;
84200e72:	52 08       	r0 = r8 + Null;
84200e74:	4b d8       	r1 = M[FP + 36];
84200e76:	03 f0 25 e4 	call (m) Lc_vol_ctrl_kick_waiting_1;

                /* Proceed with processing; consume all data from at least one
                 * of the active aux inputs.
                 */
                op_extra_data->tc.num_words = aux_limit;
84200e7a:	69 d8       	rMAC = M[FP + 52];
84200e7c:	a1 f0 b2 8e 	M[r8 + 712] = rMAC;

84200e80 <Lc_vol_ctlr_process_data_45>:
        }

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200e80:	a4 f0 c8 22 	r2 = r8 + 712;
84200e84:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200e88:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200e8c:	05 f0 37 ef 	call (m) $_vol_ctrl_compute_time_constants;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* There is a possibility that vol_ctrl_update_aux_state
         * limits the number of samples to process, so keep a copy
         * of that now.
         */
        samples_to_process = op_extra_data->tc.num_words;
84200e90:	a6 f0 b2 88 	r4 = M[r8 + 712];
#endif

        vol_ctrl_update_aux_state(op_extra_data, aux_check, &op_extra_data->tc);
84200e94:	a4 f0 c8 22 	r2 = r8 + 712;
84200e98:	52 08       	r0 = r8 + Null;
84200e9a:	63 d8       	r1 = M[FP + 48];
84200e9c:	05 f0 2d e3 	call (m) $_vol_ctrl_update_aux_state;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* whole of this block is for debugging purpose only,
         * showing to user whether aux is being mixed in timed mode
         * or normal mode.
         */
        if(op_extra_data->dbg_aux_mixing_started)
84200ea0:	a0 f0 d1 88 	Null = M[r8 + 836];
84200ea4:	33 60       	if EQ jump (m) Lc_vol_ctlr_process_data_55;

84200ea6 <Lc_vol_ctlr_process_data_46>:
        {
            if(op_extra_data->current_timestamp_valid && op_extra_data->aux0_ttp.enabled)
84200ea6:	a0 f0 cd 88 	Null = M[r8 + 820];
84200eaa:	1d 60       	if EQ jump (m) Lc_vol_ctlr_process_data_51;

84200eac <Lc_vol_ctlr_process_data_47>:
84200eac:	a0 f0 c4 88 	Null = M[r8 + 784];
84200eb0:	1a 60       	if EQ jump (m) Lc_vol_ctlr_process_data_51;

84200eb2 <Lc_vol_ctlr_process_data_48>:
                L2_DBG_MSG3("Volume Control: Started mixing auxiliary input in playback mode, "
                            "requested ttp: %d, mixed at=%d, diff=%d",
                            op_extra_data->aux0_ttp.time_to_play,
                            op_extra_data->current_timestamp,
                            time_sub(op_extra_data->current_timestamp,
                                     op_extra_data->aux0_ttp.time_to_play));
84200eb2:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200eb6:	88 24       	Null = rMAC - 2;
84200eb8:	0c 68       	if LT jump (m) Lc_vol_ctlr_process_data_50;

84200eba <Lc_vol_ctlr_process_data_49>:
84200eba:	a3 f0 c5 88 	r1 = M[r8 + 788];
84200ebe:	a4 f0 cc 88 	r2 = M[r8 + 816];
84200ec2:	e5 04       	r3 = r2 - r1;
84200ec4:	55 f1 02 f0 	r0 = Null + 357564595;
84200ec8:	b3 40 
84200eca:	ef fd ff ff 	call (m) 0xd08;
84200ece:	3f e1 

84200ed0 <Lc_vol_ctlr_process_data_50>:

                record_aux_ttr_event(op_data,
                                     VOL_CTRL_TTR_EVENT_AUX_STARTED_MIXING,
                                     op_extra_data->aux0_ttp.time_to_play,
                                     op_extra_data->current_timestamp);
84200ed0:	a5 f0 cc 88 	r3 = M[r8 + 816];
84200ed4:	a4 f0 c5 88 	r2 = M[r8 + 788];
84200ed8:	03 f0 45 40 	r1 = Null + 69;
84200edc:	42 d8       	r0 = M[FP + 32];
84200ede:	04 f0 3d ed 	call (m) Lc_record_aux_ttr_event_1;
84200ee2:	12 6e       	jump (m) Lc_vol_ctlr_process_data_54;

84200ee4 <Lc_vol_ctlr_process_data_51>:
            }
            else
            {
                L2_DBG_MSG("Volume Control: Started mixing auxiliary input in non-timed playback mode");
84200ee4:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200ee8:	88 24       	Null = rMAC - 2;
84200eea:	07 68       	if LT jump (m) Lc_vol_ctlr_process_data_53;

84200eec <Lc_vol_ctlr_process_data_52>:
84200eec:	55 f1 02 f0 	r0 = Null + 357564700;
84200ef0:	1c 41 
84200ef2:	ef fd fe ff 	call (m) 0xccc;
84200ef6:	3b ee 

84200ef8 <Lc_vol_ctlr_process_data_53>:

                record_aux_ttr_event(op_data,
                                     VOL_CTRL_TTR_EVENT_AUX_STARTED_MIXING,
                                     0,
                                     0);
84200ef8:	03 f0 45 40 	r1 = Null + 69;
84200efc:	05 00       	r3 = Null + Null;
84200efe:	04 00       	r2 = Null + Null;
84200f00:	42 d8       	r0 = M[FP + 32];
84200f02:	04 f0 39 ec 	call (m) Lc_record_aux_ttr_event_1;

84200f06 <Lc_vol_ctlr_process_data_54>:
            }
            op_extra_data->dbg_aux_mixing_started = FALSE;
84200f06:	a0 f0 d1 8e 	M[r8 + 836] = Null;

84200f0a <Lc_vol_ctlr_process_data_55>:
        }

        if(samples_to_process > op_extra_data->tc.num_words)
84200f0a:	a1 f0 b2 88 	rMAC = M[r8 + 712];
84200f0e:	70 04       	Null = r4 - rMAC;
84200f10:	09 f0 cb e0 	if LS jump (m) Lc_vol_ctlr_process_data_59;

84200f14 <Lc_vol_ctlr_process_data_56>:
             */

            /* recalculate time constants based on limited amount */
            vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                            op_extra_data->parameters.OFFSET_VOLUME_TC,
                                            &op_extra_data->tc);
84200f14:	a4 f0 c8 22 	r2 = r8 + 712;
84200f18:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200f1c:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200f20:	05 f0 23 eb 	call (m) $_vol_ctrl_compute_time_constants;

            /* Also do a self kick to process the rest of chunk immediately.*/
            if (op_extra_data->pending_timer == TIMER_ID_INVALID)
84200f24:	a0 f0 be 88 	Null = M[r8 + 760];
84200f28:	19 62       	if NE jump (m) Lc_vol_ctlr_process_data_59;

84200f2a <Lc_vol_ctlr_process_data_57>:
            {
                op_extra_data->pending_timer =
                    timer_schedule_event_in(0, vol_ctlr_timer_task, (void*)op_data );
84200f2a:	42 f0 06 f0 	r4 = Null + 69209139;
84200f2e:	33 58 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200f30:	ff fd 28 f0 	call (m) 0x6100;
84200f34:	31 ee 
84200f36:	33 00       	r1 = r4 + Null;
84200f38:	44 d8       	r2 = M[FP + 32];
84200f3a:	ff fd 28 f0 	call (m) 0x610a;
84200f3e:	31 ee 
}
84200f40:	a2 f0 be 8e 	M[r8 + 760] = r0;
84200f44:	0b 6e       	jump (m) Lc_vol_ctlr_process_data_59;

84200f46 <Lc_vol_ctlr_process_data_58>:
#endif  /* VOLUME_CONTROL_AUX_TTP_SUPPORT  */

    }
    else
    {
        op_extra_data->aux_pending = FALSE;
84200f46:	a0 f0 bc 8e 	M[r8 + 752] = Null;

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200f4a:	a4 f0 c8 22 	r2 = r8 + 712;
84200f4e:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200f52:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200f56:	05 f0 2d e9 	call (m) $_vol_ctrl_compute_time_constants;

84200f5a <Lc_vol_ctlr_process_data_59>:
    }

    if (! op_extra_data->aux_pending)
84200f5a:	a0 f0 bc 88 	Null = M[r8 + 752];
84200f5e:	11 62       	if NE jump (m) Lc_vol_ctlr_process_data_63;

84200f60 <Lc_vol_ctlr_process_data_60>:
    {
        timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200f60:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200f64:	ff fd ce f1 	call (m) 0x3ad3a;
84200f68:	37 ee 
    if (*timer_id != TIMER_ID_INVALID)
84200f6a:	32 e8       	r0 = M[r4 + Null];
84200f6c:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_62;

84200f6e <Lc_vol_ctlr_process_data_61>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200f6e:	04 00       	r2 = Null + Null;
84200f70:	03 00       	r1 = Null + Null;
84200f72:	ff fd 29 f0 	call (m) 0x6292;
84200f76:	21 e9 
        *timer_id = TIMER_ID_INVALID;
84200f78:	30 ee       	M[r4 + Null] = Null;

84200f7a <Lc_vol_ctlr_process_data_62>:
    }
    interrupt_unblock();
84200f7a:	ff fd ce f1 	call (m) 0x3ad56;
84200f7e:	3d ee 

84200f80 <Lc_vol_ctlr_process_data_63>:
    }

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update amount that is consumed this run */
    op_extra_data->prev_consumed_samples = op_extra_data->tc.num_words;
84200f80:	a1 f0 b2 88 	rMAC = M[r8 + 712];
#endif
    if (op_extra_data->tc.num_words > 0)
84200f84:	a1 f0 cf 8e 	M[r8 + 828] = rMAC;
84200f88:	11 60       	if EQ jump (m) Lc_vol_ctlr_process_data_65;

84200f8a <Lc_vol_ctlr_process_data_64>:
    {
#ifdef INSTALL_METADATA
        metadata_tag* eoftag = vol_ctrl_handle_aux_metadata(op_extra_data);
84200f8a:	52 08       	r0 = r8 + Null;
84200f8c:	02 f0 31 eb 	call (m) Lc_vol_ctrl_handle_aux_metadata_1;
        vol_ctrl_handle_input_metadata(op_extra_data, eoftag);
84200f90:	13 00       	r1 = r0 + Null;
84200f92:	52 08       	r0 = r8 + Null;
84200f94:	02 f0 3d ed 	call (m) Lc_vol_ctrl_handle_input_metadata_1;
#endif  /* INSTALL_METADATA */

        /* Update Main Channels */
        vol_ctrl_update_channel(op_extra_data,op_extra_data->channels,op_extra_data->lpvols,&op_extra_data->tc);
84200f98:	a5 f0 c8 22 	r3 = r8 + 712;
84200f9c:	a4 f0 62 88 	r2 = M[r8 + 392];
84200fa0:	a3 f0 1a 88 	r1 = M[r8 + 104];
84200fa4:	52 08       	r0 = r8 + Null;
84200fa6:	f8 ff 3a e2 	call $_vol_ctrl_update_channel;

84200faa <Lc_vol_ctlr_process_data_65>:
    }

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    uint32 updated_aux_state = pack_aux_state(op_extra_data);
84200faa:	52 08       	r0 = r8 + Null;
84200fac:	04 f0 2d e6 	call (m) Lc_pack_aux_state_1;
    if (updated_aux_state != packed_aux_state)
84200fb0:	51 d8       	rMAC = M[FP + 40];
84200fb2:	50 04       	Null = r0 - rMAC;
84200fb4:	08 60       	if EQ jump (m) Lc_vol_ctlr_process_data_67;

84200fb6 <Lc_vol_ctlr_process_data_66>:
    {
        record_aux_ttr_event(op_data, VOL_CTRL_TTR_EVENT_AUX_STATE,
                             updated_aux_state, 0);
84200fb6:	03 f0 44 40 	r1 = Null + 68;
84200fba:	05 00       	r3 = Null + Null;
84200fbc:	14 00       	r2 = r0 + Null;
84200fbe:	42 d8       	r0 = M[FP + 32];
84200fc0:	04 f0 3b e6 	call (m) Lc_record_aux_ttr_event_1;

84200fc4 <Lc_vol_ctlr_process_data_67>:
    }
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */

    /* Handle backwards kicks for main channels */
    touched_sink = (op_extra_data->used_all_input) ? op_extra_data->touched_sink : 0;
84200fc4:	a0 f0 bd 88 	Null = M[r8 + 756];
84200fc8:	04 60       	if EQ jump (m) Lc_vol_ctlr_process_data_69;

84200fca <Lc_vol_ctlr_process_data_68>:
84200fca:	a6 f0 18 88 	r4 = M[r8 + 96];
84200fce:	02 6e       	jump (m) Lc_vol_ctlr_process_data_70;

84200fd0 <Lc_vol_ctlr_process_data_69>:
84200fd0:	06 00       	r4 = Null + Null;

84200fd2 <Lc_vol_ctlr_process_data_70>:

    /* Update Aux Buffers */
    op_extra_data->aux_state   = 0;
84200fd2:	a0 f0 b9 8e 	M[r8 + 740] = Null;
    amount    = op_extra_data->aux_connected;
    if(amount)
84200fd6:	a8 f0 b7 88 	r6 = M[r8 + 732];
84200fda:	25 60       	if EQ jump (m) Lc_vol_ctlr_process_data_78;

84200fdc <Lc_vol_ctlr_process_data_71>:
    {
        vol_ctrl_aux_channel_t *aux_ptr=op_extra_data->aux_channel;
84200fdc:	a7 f0 6c 20 	r5 = r8 + 108;
        i = 0;
84200fe0:	01 09       	r7 = Null + Null;

84200fe2 <Lc_vol_ctlr_process_data_72>:
        do
        {
            if(aux_ptr->state==AUX_STATE_IN_AUX)
84200fe2:	39 81       	rMAC = MBS[r5 + 4];
84200fe4:	88 24       	Null = rMAC - 2;
84200fe6:	0e 62       	if NE jump (m) Lc_vol_ctlr_process_data_75;

84200fe8 <Lc_vol_ctlr_process_data_73>:
            {
                unsigned index_mask = (1<<i);
84200fe8:	49 08       	rMAC = r7 + Null;
84200fea:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
                op_extra_data->aux_state |= index_mask;
84200fee:	a1 f0 b9 88 	rMAC = M[r8 + 740];
84200ff2:	89 12       	rMAC = rMAC OR r0;
84200ff4:	a1 f0 b9 8e 	M[r8 + 740] = rMAC;
                // only advance if used by a channel?
                if(!(op_extra_data->aux_in_use&index_mask))
84200ff8:	a1 f0 ba 88 	rMAC = M[r8 + 744];
84200ffc:	89 10       	rMAC = rMAC AND r0;
84200ffe:	02 62       	if NE jump (m) Lc_vol_ctlr_process_data_75;

84201000 <Lc_vol_ctlr_process_data_74>:
                {
                    aux_ptr->advance_buffer=0;
84201000:	f8 8e       	M[r5 + 12] = Null;

84201002 <Lc_vol_ctlr_process_data_75>:
                }
            }
            if(aux_ptr->advance_buffer)
84201002:	fb 88       	r1 = M[r5 + 12];
84201004:	0b 60       	if EQ jump (m) Lc_vol_ctlr_process_data_77;

84201006 <Lc_vol_ctlr_process_data_76>:
            {
                touched_sink |= ( TOUCHED_SINK_0 << ((i<<1)+1) );
84201006:	00 f9 d2 d8 	r0 = r7 LSHIFT 1;
8420100a:	51 20       	rMAC = r0 + 1;
8420100c:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84201010:	b6 12       	r4 = r4 OR r0;
                cbuffer_advance_read_ptr(aux_ptr->buffer,aux_ptr->advance_buffer);
84201012:	3a e8       	r0 = M[r5 + Null];
84201014:	ff fd c6 f1 	call (m) 0x39de2;
84201018:	2f ee 

8420101a <Lc_vol_ctlr_process_data_77>:
            }
            i++;
8420101a:	09 75       	r7 = r7 + 1;
            aux_ptr++;
8420101c:	3f 28       	r5 = r5 + 16;
            amount>>=1;
        }while(amount);
8420101e:	7f f8 d8 d8 	r6 = r6 LSHIFT -1;
84201022:	e0 63       	if NE jump (m) Lc_vol_ctlr_process_data_72;

84201024 <Lc_vol_ctlr_process_data_78>:
    }

   touched->sinks |= touched_sink;
84201024:	49 d8       	rMAC = M[FP + 36];
84201026:	0a 00       	r0 = rMAC + Null;
84201028:	49 88       	rMAC = M[rMAC + 4];
8420102a:	89 13       	rMAC = rMAC OR r4;
8420102c:	51 8e       	M[r0 + 4] = rMAC;
   touched->sources = op_extra_data->touched_src;
8420102e:	a1 f0 19 88 	rMAC = M[r8 + 100];
84201032:	11 ee       	M[r0 + Null] = rMAC;

84201034 <Lc_vol_ctlr_process_data_79>:

}
84201034:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201036:	d8 4c       	rts;

84201038 <$_vol_ctlr_opmsg_obpm_set_control>:


/* **************************** Operator message handlers ******************************** */

bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201038:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
8420103a:	11 09       	r7 = r0 + Null;
8420103c:	43 de       	M[FP + 32] = r1;
8420103e:	27 00       	r5 = r2 + Null;
84201040:	4d de       	M[FP + 36] = r3;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201042:	ef fd fa ff 	call (m) 0x4e6;
84201046:	25 e5 
84201048:	16 00       	r4 = r0 + Null;
bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T    *op_extra_data = get_instance_data(op_data);
    unsigned            i,num_controls,cntrl_value;
    CPS_CONTROL_SOURCE  cntrl_src;
    OPMSG_RESULT_STATES result = OPMSG_RESULT_STATES_NORMAL_STATE;
8420104a:	50 de       	M[FP + 40] = Null;
    vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
8420104c:	68 f0 f8 20 	r6 = r4 + 248;
    bool              bIsOBPM=FALSE;
84201050:	02 09       	r8 = Null + Null;

    patch_fn(volume_control_opmsg_obpm_set_control_patch);

    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
84201052:	c5 12       	r3 = FP + 44;
84201054:	3b 00       	r1 = r5 + Null;
84201056:	4c d8       	r2 = M[FP + 36];
84201058:	42 d8       	r0 = M[FP + 32];
8420105a:	ef fd fd ff 	call (m) 0xab2;
8420105e:	39 e2 
84201060:	10 04       	Null = r0 - Null;
84201062:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_3;

84201064 <Lc_vol_ctlr_opmsg_obpm_set_control_2>:
84201064:	02 00       	r0 = Null + Null;
84201066:	8b 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_31;

84201068 <Lc_vol_ctlr_opmsg_obpm_set_control_3>:
84201068:	0b 71       	r9 = Null + 1;
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
8420106a:	07 00       	r5 = Null + Null;
8420106c:	0e 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_8;

8420106e <Lc_vol_ctlr_opmsg_obpm_set_control_4>:
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL8) )
8420106e:	10 3c       	Null = r0 - 48;
84201070:	29 64       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84201072 <Lc_vol_ctlr_opmsg_obpm_set_control_5>:
84201072:	d0 3d       	Null = r0 - 55;
84201074:	08 f0 cf e0 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84201078 <Lc_vol_ctlr_opmsg_obpm_set_control_6>:
        {
            lpvols->auxiliary_gain[cntrl_id-VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1] = cntrl_value;
84201078:	63 d8       	r1 = M[FP + 48];
8420107a:	f2 f7 d0 7f 	r0 = r0 + -48;
8420107e:	41 08       	rMAC = r6 + Null;
84201080:	52 54       	r0 = r0 LSHIFT 2;
84201082:	51 00       	rMAC = r0 + rMAC;
84201084:	8b 8e       	M[rMAC + 8] = r1;

84201086 <Lc_vol_ctlr_opmsg_obpm_set_control_7>:
    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
84201086:	7f 20       	r5 = r5 + 1;

84201088 <Lc_vol_ctlr_opmsg_obpm_set_control_8>:
84201088:	59 d8       	rMAC = M[FP + 44];
8420108a:	78 04       	Null = r5 - rMAC;
8420108c:	02 f0 bb e0 	if C jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_15;

84201090 <Lc_vol_ctlr_opmsg_obpm_set_control_9>:
    {
        unsigned  cntrl_id=cps_control_get(message_data,i,&cntrl_value,&cntrl_src);
84201090:	45 13       	r3 = FP + 52;
84201092:	04 13       	r2 = FP + 48;
84201094:	3b 00       	r1 = r5 + Null;
84201096:	42 d8       	r0 = M[FP + 32];
84201098:	ef fd fd ff 	call (m) 0xb00;
8420109c:	29 e3 

        /* Check for OBPM and Override.   Override is all or none, not per control */
        if((i==0)&&(cntrl_src != CPS_SOURCE_HOST))
8420109e:	38 04       	Null = r5 - Null;
842010a0:	0c 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

842010a2 <Lc_vol_ctlr_opmsg_obpm_set_control_10>:
842010a2:	a1 d1       	rMAC = MBS[FP + 52];
842010a4:	0a 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

842010a6 <Lc_vol_ctlr_opmsg_obpm_set_control_11>:
        {
            bIsOBPM = TRUE;
842010a6:	5a 09       	r8 = r9 + Null;
            lpvols  = &op_extra_data->obpm_vol;
842010a8:	68 f0 40 21 	r6 = r4 + 320;
            /* Polarity of override enable/disable is inverted */
            op_extra_data->Ovr_Control = (cntrl_src == CPS_SOURCE_OBPM_DISABLE) ?  VOL_CTRL_CONTROL_VOL_OVERRIDE : 0;
842010ac:	03 00       	r1 = Null + Null;
842010ae:	c8 24       	Null = rMAC - 3;
842010b0:	20 f0 43 ce 	if EQ r1 = Null + 1;
842010b4:	63 f0 3c 8e 	M[r4 + 240] = r1;

842010b8 <Lc_vol_ctlr_opmsg_obpm_set_control_12>:
        }

        if(cntrl_id==VOL_CTRL_CONSTANT_POST_GAIN_CTRL)
842010b8:	10 34       	Null = r0 - 32;
842010ba:	1a 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_18;

842010bc <Lc_vol_ctlr_opmsg_obpm_set_control_13>:
        {
            if(bIsOBPM)
842010bc:	0f fa 00 c2 	Null = r8 - Null;
842010c0:	0c 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_17;

842010c2 <Lc_vol_ctlr_opmsg_obpm_set_control_14>:
            {
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
842010c2:	01 21       	rMAC = Null + 4;
842010c4:	51 de       	M[FP + 40] = rMAC;

842010c6 <Lc_vol_ctlr_opmsg_obpm_set_control_15>:
            result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
            break;
        }
    }

    if(op_extra_data->Ovr_Control&VOL_CTRL_CONTROL_VOL_OVERRIDE)
842010c6:	61 f0 3c 88 	rMAC = M[r4 + 240];
842010ca:	09 c0       	rMAC = rMAC AND 0x1;
842010cc:	48 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_29;

842010ce <Lc_vol_ctlr_opmsg_obpm_set_control_16>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
842010ce:	61 f0 40 21 	rMAC = r4 + 320;
842010d2:	61 f0 62 8e 	M[r4 + 392] = rMAC;
842010d6:	47 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_30;

842010d8 <Lc_vol_ctlr_opmsg_obpm_set_control_17>:
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
                break;
            }

            op_extra_data->post_gain = cntrl_value;
842010d8:	61 d8       	rMAC = M[FP + 48];
842010da:	61 f0 3d 8e 	M[r4 + 244] = rMAC;

            op_extra_data->shared_volume_ptr->inv_post_gain = dB60toLinearQ5(-op_extra_data->post_gain);
842010de:	42 04       	r0 = Null - rMAC;
842010e0:	ff fd b7 f1 	call (m) 0x37fbe;
842010e4:	3f e6 
842010e6:	61 f0 63 88 	rMAC = M[r4 + 396];
842010ea:	ca 8e       	M[rMAC + 12] = r0;
842010ec:	cd 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

842010ee <Lc_vol_ctlr_opmsg_obpm_set_control_18>:
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MASTER_GAIN_CTRL)
842010ee:	50 34       	Null = r0 - 33;
842010f0:	0d 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_21;

842010f2 <Lc_vol_ctlr_opmsg_obpm_set_control_19>:
        {
            lpvols->master_gain = cntrl_value;
842010f2:	61 d8       	rMAC = M[FP + 48];
842010f4:	81 f0 00 ee 	M[r6 + Null] = rMAC;
            if (!opmgr_op_is_running(op_data))
842010f8:	4a 08       	r0 = r7 + Null;
842010fa:	ff fd 23 f0 	call (m) 0x5700;
842010fe:	27 e0 
84201100:	10 04       	Null = r0 - Null;
84201102:	c2 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201104 <Lc_vol_ctlr_opmsg_obpm_set_control_20>:
            {
                op_extra_data->vol_initialised = 1;
84201104:	6b f0 bf 8e 	M[r4 + 764] = r9;
84201108:	bf 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420110a <Lc_vol_ctlr_opmsg_obpm_set_control_21>:
            }
        }
        else if(cntrl_id==OPMSG_CONTROL_MUTE_ID)
8420110a:	90 24       	Null = r0 - 2;
8420110c:	10 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_24;

8420110e <Lc_vol_ctlr_opmsg_obpm_set_control_22>:
        {
            lpvols->mute = cntrl_value;
8420110e:	61 d8       	rMAC = M[FP + 48];
84201110:	81 f0 01 8e 	M[r6 + 4] = rMAC;
            if (opmgr_op_is_running(op_data))
84201114:	4a 08       	r0 = r7 + Null;
84201116:	ff fd 22 f0 	call (m) 0x5700;
8420111a:	2b ef 
8420111c:	10 04       	Null = r0 - Null;
8420111e:	b4 61       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201120 <Lc_vol_ctlr_opmsg_obpm_set_control_23>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84201120:	83 f0 01 88 	r1 = M[r6 + 4];
84201124:	32 00       	r0 = r4 + Null;
84201126:	03 f0 2d e7 	call (m) Lc_vol_ctrl_setup_mute_1;
8420112a:	ae 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420112c <Lc_vol_ctlr_opmsg_obpm_set_control_24>:
            }
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MUTE_PERIOD_CTRL)
8420112c:	90 34       	Null = r0 - 34;
8420112e:	0b 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_26;

84201130 <Lc_vol_ctlr_opmsg_obpm_set_control_25>:
        {
            op_extra_data->mute_period = cntrl_value;
84201130:	61 d8       	rMAC = M[FP + 48];
84201132:	61 f0 c0 8e 	M[r4 + 768] = rMAC;
            if (opmgr_op_is_running(op_data))
84201136:	4a 08       	r0 = r7 + Null;
84201138:	ff fd 22 f0 	call (m) 0x5700;
8420113c:	29 ee 
8420113e:	10 04       	Null = r0 - Null;
84201140:	f0 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_23;

84201142 <Lc__ite_12>:
84201142:	a2 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201144 <Lc_vol_ctlr_opmsg_obpm_set_control_26>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
            }
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
84201144:	10 2c       	Null = r0 - 16;
84201146:	be 65       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84201148 <Lc_vol_ctlr_opmsg_obpm_set_control_27>:
84201148:	d0 2d       	Null = r0 - 23;
8420114a:	f8 ff a5 ee 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_4;

8420114e <Lc_vol_ctlr_opmsg_obpm_set_control_28>:
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
8420114e:	63 d8       	r1 = M[FP + 48];
84201150:	82 7c       	r0 = r0 + -16;
84201152:	41 08       	rMAC = r6 + Null;
84201154:	52 54       	r0 = r0 LSHIFT 2;
84201156:	51 00       	rMAC = r0 + rMAC;
84201158:	8b 9e       	M[rMAC + 40] = r1;
8420115a:	96 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420115c <Lc_vol_ctlr_opmsg_obpm_set_control_29>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
    }
    else
    {
        op_extra_data->lpvols = &op_extra_data->host_vol;
8420115c:	61 f0 f8 20 	rMAC = r4 + 248;
84201160:	61 f0 62 8e 	M[r4 + 392] = rMAC;

84201164 <Lc_vol_ctlr_opmsg_obpm_set_control_30>:
    }
    op_extra_data->shared_volume_ptr->current_volume_level = op_extra_data->lpvols->master_gain;
84201164:	61 f0 62 88 	rMAC = M[r4 + 392];
84201168:	62 f0 63 88 	r0 = M[r4 + 396];
8420116c:	09 e8       	rMAC = M[rMAC + Null];
8420116e:	91 8e       	M[r0 + 8] = rMAC;


    cps_response_set_result(resp_data,result);
84201170:	53 d8       	r1 = M[FP + 40];
84201172:	4a d8       	r0 = M[FP + 36];
84201174:	ef fd fc ff 	call (m) 0xb4e;
84201178:	3b ee 

    return TRUE;
8420117a:	5a 08       	r0 = r9 + Null;

8420117c <Lc_vol_ctlr_opmsg_obpm_set_control_31>:
}
8420117c:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420117e:	d8 4c       	rts;

84201180 <$_vol_ctlr_opmsg_obpm_get_params>:

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201180:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201182:	1f 00       	r5 = r1 + Null;
84201184:	26 00       	r4 = r2 + Null;
84201186:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201188:	ef fd f9 ff 	call (m) 0x4e6;
8420118c:	3f ea 

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
8420118e:	02 f0 b4 46 	r0 = r0 + 692;
84201192:	45 08       	r3 = r6 + Null;
84201194:	34 00       	r2 = r4 + Null;
84201196:	3b 00       	r1 = r5 + Null;
84201198:	ef fd fa ff 	call (m) 0x792;
8420119c:	3b ef 

8420119e <Lc_vol_ctlr_opmsg_obpm_get_params_2>:
}
8420119e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842011a0:	d8 4c       	rts;

842011a2 <$_vol_ctlr_opmsg_obpm_get_defaults>:

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011a2:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842011a4:	1f 00       	r5 = r1 + Null;
842011a6:	26 00       	r4 = r2 + Null;
842011a8:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842011aa:	ef fd f9 ff 	call (m) 0x4e6;
842011ae:	3d e9 

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetDefaultsMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842011b0:	02 f0 b4 46 	r0 = r0 + 692;
842011b4:	45 08       	r3 = r6 + Null;
842011b6:	34 00       	r2 = r4 + Null;
842011b8:	3b 00       	r1 = r5 + Null;
842011ba:	ef fd fb ff 	call (m) 0x840;
842011be:	27 e4 

842011c0 <Lc_vol_ctlr_opmsg_obpm_get_defaults_2>:
}
842011c0:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842011c2:	d8 4c       	rts;

842011c4 <$_vol_ctlr_opmsg_obpm_set_params>:

bool vol_ctlr_opmsg_obpm_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011c4:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842011c6:	19 09       	r7 = r1 + Null;
842011c8:	27 00       	r5 = r2 + Null;
842011ca:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842011cc:	ef fd f9 ff 	call (m) 0x4e6;
842011d0:	3b e8 
842011d2:	16 00       	r4 = r0 + Null;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    bool retval;

    patch_fn(volume_control_opmsg_obpm_set_params_patch);

    retval = cpsSetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842011d4:	62 f0 b4 22 	r0 = r4 + 692;
842011d8:	45 08       	r3 = r6 + Null;
842011da:	3c 00       	r2 = r5 + Null;
842011dc:	4b 08       	r1 = r7 + Null;
842011de:	ef fd fb ff 	call (m) 0x914;
842011e2:	37 e9 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
842011e4:	41 20       	rMAC = Null + 1;
842011e6:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

842011ea <Lc_vol_ctlr_opmsg_obpm_set_params_2>:

    return retval;
842011ea:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842011ec:	d8 4c       	rts;

842011ee <$_vol_ctlr_opmsg_obpm_get_status>:
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011ee:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
842011f0:	19 09       	r7 = r1 + Null;
842011f2:	27 00       	r5 = r2 + Null;
842011f4:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842011f6:	ef fd f9 ff 	call (m) 0x4e6;
842011fa:	31 e7 
842011fc:	12 09       	r8 = r0 + Null;
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    vol_ctrl_gains_t *lpvols = op_extra_data->lpvols;
842011fe:	a6 f0 62 88 	r4 = M[r8 + 392];
    unsigned  *resp;

    patch_fn_shared(volume_control_wrapper);

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(VOL_CTRL_STATISTICS),&resp))
84201202:	c1 11       	rMAC = FP + 28;
84201204:	09 1c       	pushm <rMAC>;
84201206:	05 f0 50 40 	r3 = Null + 80;
8420120a:	44 08       	r2 = r6 + Null;
8420120c:	3b 00       	r1 = r5 + Null;
8420120e:	4a 08       	r0 = r7 + Null;
84201210:	ef fd fc ff 	call (m) 0xb64;
84201214:	35 ea 
84201216:	7f 4c       	SP = SP + -4;
84201218:	10 04       	Null = r0 - Null;
8420121a:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_3;

8420121c <Lc_vol_ctlr_opmsg_obpm_get_status_2>:
    {
        return FALSE;
8420121c:	02 00       	r0 = Null + Null;
8420121e:	4c 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_6;

84201220 <Lc_vol_ctlr_opmsg_obpm_get_status_3>:
    }

    if (resp)
84201220:	3c d8       	r2 = M[FP + 28];
84201222:	49 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_5;

84201224 <Lc_vol_ctlr_opmsg_obpm_get_status_4>:
    {
        resp = cpsPack2Words(op_extra_data->Ovr_Control, op_extra_data->post_gain, resp);
84201224:	a3 f0 3d 88 	r1 = M[r8 + 244];
84201228:	a2 f0 3c 88 	r0 = M[r8 + 240];
8420122c:	ff fd c5 f1 	call (m) 0x39caa;
84201230:	3f e3 
84201232:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->master_gain, lpvols->auxiliary_gain[0], resp);
84201234:	3c d8       	r2 = M[FP + 28];
84201236:	b3 88       	r1 = M[r4 + 8];
84201238:	32 e8       	r0 = M[r4 + Null];
8420123a:	ff fd c5 f1 	call (m) 0x39caa;
8420123e:	31 e3 
84201240:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[1], lpvols->auxiliary_gain[2], resp);
84201242:	3c d8       	r2 = M[FP + 28];
84201244:	33 89       	r1 = M[r4 + 16];
84201246:	f2 88       	r0 = M[r4 + 12];
84201248:	ff fd c5 f1 	call (m) 0x39caa;
8420124c:	23 e3 
8420124e:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[3], lpvols->auxiliary_gain[4], resp);
84201250:	3c d8       	r2 = M[FP + 28];
84201252:	b3 89       	r1 = M[r4 + 24];
84201254:	72 89       	r0 = M[r4 + 20];
84201256:	ff fd c5 f1 	call (m) 0x39caa;
8420125a:	35 e2 
8420125c:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[5], lpvols->auxiliary_gain[6], resp);
8420125e:	3c d8       	r2 = M[FP + 28];
84201260:	33 98       	r1 = M[r4 + 32];
84201262:	f2 89       	r0 = M[r4 + 28];
84201264:	ff fd c5 f1 	call (m) 0x39caa;
84201268:	27 e2 
8420126a:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[7], lpvols->channel_trims[0], resp);
8420126c:	3c d8       	r2 = M[FP + 28];
8420126e:	b3 98       	r1 = M[r4 + 40];
84201270:	72 98       	r0 = M[r4 + 36];
84201272:	ff fd c5 f1 	call (m) 0x39caa;
84201276:	39 e1 
84201278:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[1], lpvols->channel_trims[2], resp);
8420127a:	3c d8       	r2 = M[FP + 28];
8420127c:	33 99       	r1 = M[r4 + 48];
8420127e:	f2 98       	r0 = M[r4 + 44];
84201280:	ff fd c5 f1 	call (m) 0x39caa;
84201284:	2b e1 
84201286:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[3], lpvols->channel_trims[4], resp);
84201288:	3c d8       	r2 = M[FP + 28];
8420128a:	b3 99       	r1 = M[r4 + 56];
8420128c:	72 99       	r0 = M[r4 + 52];
8420128e:	ff fd c5 f1 	call (m) 0x39caa;
84201292:	3d e0 
84201294:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[5], lpvols->channel_trims[6], resp);
84201296:	3c d8       	r2 = M[FP + 28];
84201298:	33 a8       	r1 = M[r4 + 64];
8420129a:	f2 99       	r0 = M[r4 + 60];
8420129c:	ff fd c5 f1 	call (m) 0x39caa;
842012a0:	2f e0 
842012a2:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[7], op_extra_data->aux_state, resp);
842012a4:	3c d8       	r2 = M[FP + 28];
842012a6:	a3 f0 b9 88 	r1 = M[r8 + 740];
842012aa:	72 a8       	r0 = M[r4 + 68];
842012ac:	ff fd c4 f1 	call (m) 0x39caa;
842012b0:	3f ef 
842012b2:	3a de       	M[FP + 28] = r0;

842012b4 <Lc_vol_ctlr_opmsg_obpm_get_status_5>:
    }

    return TRUE;
842012b4:	42 20       	r0 = Null + 1;

842012b6 <Lc_vol_ctlr_opmsg_obpm_get_status_6>:
}
842012b6:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
842012b8:	d8 4c       	rts;

842012ba <$_vol_ctlr_opmsg_set_ucid>:

    return TRUE;
}

bool vol_ctlr_opmsg_set_ucid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012ba:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842012bc:	11 09       	r7 = r0 + Null;
842012be:	1a 09       	r8 = r1 + Null;
842012c0:	27 00       	r5 = r2 + Null;
842012c2:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842012c4:	ef fd f9 ff 	call (m) 0x4e6;
842012c8:	23 e1 
842012ca:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    PS_KEY_TYPE key;
    bool retval;

    retval = cpsSetUcidMsgHandler(&op_extra_data->parms_def,message_data,resp_length,resp_data);
842012cc:	62 f0 b4 22 	r0 = r4 + 692;
842012d0:	45 08       	r3 = r6 + Null;
842012d2:	3c 00       	r2 = r5 + Null;
842012d4:	53 08       	r1 = r8 + Null;
842012d6:	ef fd fb ff 	call (m) 0x9a6;
842012da:	31 e6 
842012dc:	17 00       	r5 = r0 + Null;

    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(base_op_get_cap_id(op_data),op_extra_data->parms_def.ucid,OPMSG_P_STORE_PARAMETER_SUB_ID);
842012de:	4a 08       	r0 = r7 + Null;
842012e0:	ef fd f9 ff 	call (m) 0x4ea;
842012e4:	2b e0 
842012e6:	92 c6       	r0 = r0 AND 0xffff;
842012e8:	61 f0 b1 88 	rMAC = M[r4 + 708];
842012ec:	92 55       	r0 = r0 LSHIFT 7;
842012ee:	8b c2       	r1 = rMAC AND 0x3f;
842012f0:	1b 54       	r1 = r1 LSHIFT 1;
842012f2:	9b 12       	r1 = r1 OR r0;
    ps_entry_read((void*)op_data,key,PERSIST_ANY,ups_params_vc);
842012f4:	42 f0 05 f0 	r3 = Null + 69212349;
842012f8:	bd 70 
842012fa:	04 00       	r2 = Null + Null;
842012fc:	4a 08       	r0 = r7 + Null;
842012fe:	ff fd 32 f0 	call (m) 0x7888;
84201302:	2b ec 

    return retval;
84201304:	3a 00       	r0 = r5 + Null;

84201306 <Lc_vol_ctlr_opmsg_set_ucid_2>:
}
84201306:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201308:	d8 4c       	rts;

8420130a <$_vol_ctlr_opmsg_get_ps_id>:

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420130a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420130c:	16 00       	r4 = r0 + Null;
8420130e:	1a 09       	r8 = r1 + Null;
84201310:	20 09       	r6 = r2 + Null;
84201312:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201314:	ef fd f8 ff 	call (m) 0x4e6;
84201318:	33 ee 
8420131a:	11 09       	r7 = r0 + Null;

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,base_op_get_cap_id(op_data),message_data,resp_length,resp_data);
8420131c:	32 00       	r0 = r4 + Null;
8420131e:	ef fd f8 ff 	call (m) 0x4ea;
84201322:	2d ee 
84201324:	13 00       	r1 = r0 + Null;
84201326:	39 1c       	pushm <r5>;
84201328:	92 f0 b4 22 	r0 = r7 + 692;
8420132c:	45 08       	r3 = r6 + Null;
8420132e:	54 08       	r2 = r8 + Null;
84201330:	ef fd fb ff 	call (m) 0x9c8;
84201334:	39 e4 
84201336:	7f 4c       	SP = SP + -4;

84201338 <Lc_vol_ctlr_opmsg_get_ps_id_2>:
}
84201338:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420133a:	d8 4c       	rts;

8420133c <$_vol_ctlr_opmsg_set_sample_rate>:

bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420133c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420133e:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201340:	ef fd f8 ff 	call (m) 0x4e6;
84201344:	27 ed 
bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->sample_rate = 25 * (OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE));
84201346:	f1 88       	rMAC = M[r4 + 12];
84201348:	89 c6       	rMAC = rMAC AND 0xffff;
8420134a:	49 46       	rMAC = rMAC * 25 (int);
8420134c:	21 f0 3b 8e 	M[r0 + 236] = rMAC;

    return TRUE;
84201350:	42 20       	r0 = Null + 1;

84201352 <Lc_vol_ctlr_opmsg_set_sample_rate_2>:
}
84201352:	f1 48       	popm <FP, r4, rLink>;
84201354:	d8 4c       	rts;

84201356 <$_vol_ctlr_opmsg_data_stream_based>:

bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201356:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201358:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420135a:	ef fd f8 ff 	call (m) 0x4e6;
8420135e:	2d ec 
bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->stream_based = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_DATA_STREAM_BASED, IS_STREAM_BASED);
84201360:	f1 88       	rMAC = M[r4 + 12];
84201362:	89 c6       	rMAC = rMAC AND 0xffff;
84201364:	21 f0 c3 8e 	M[r0 + 780] = rMAC;

    return TRUE;
84201368:	42 20       	r0 = Null + 1;

8420136a <Lc_vol_ctlr_opmsg_data_stream_based_2>:
}
8420136a:	f1 48       	popm <FP, r4, rLink>;
8420136c:	d8 4c       	rts;

8420136e <$_vol_ctlr_opmsg_set_aux_time_to_play>:
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
bool vol_ctlr_opmsg_set_aux_time_to_play(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420136e:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84201370:	11 09       	r7 = r0 + Null;
84201372:	1f 00       	r5 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201374:	ef fd f8 ff 	call (m) 0x4e6;
84201378:	33 eb 
8420137a:	16 00       	r4 = r0 + Null;


    /* get aux channel index */
    unsigned aux_channel_index = OPMSG_FIELD_GET(message_data,
                                                 OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                 AUX_CHANNEL_INDEX);
8420137c:	f9 88       	rMAC = M[r5 + 12];
8420137e:	8b c6       	r1 = rMAC AND 0xffff;
        (TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                          OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 1) +
        ((TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                           OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 0) << 16);
84201380:	39 89       	rMAC = M[r5 + 16];
84201382:	8a c6       	r0 = rMAC AND 0xffff;
84201384:	92 56       	r0 = r0 LSHIFT 16;
84201386:	79 89       	rMAC = M[r5 + 20];
84201388:	89 c6       	rMAC = rMAC AND 0xffff;
8420138a:	1f f2 08 c0 	r6 = r0 + rMAC;
    /* get drift rate */
    int aux_drift_rate = (int)(int16)OPMSG_FIELD_GET(message_data,
                                                     OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                     AUX_DRIFT_RATE);
8420138e:	b9 89       	rMAC = M[r5 + 24];
84201390:	0f 0c       	r5 = SE16 rMAC;

    /* Only channel 0 is supported */
    if(aux_channel_index != 0)
84201392:	18 04       	Null = r1 - Null;
84201394:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_5;

84201396 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_2>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback, "
                    "only channel 0 supports this feature, channel=%d",
                    aux_channel_index);
84201396:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420139a:	88 24       	Null = rMAC - 2;
8420139c:	07 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420139e <Lc_vol_ctlr_opmsg_set_aux_time_to_play_3>:
8420139e:	55 f1 02 f0 	r0 = Null + 357564774;
842013a2:	66 41 
842013a4:	ef fd fc ff 	call (m) 0xcde;
842013a8:	3b e9 

842013aa <Lc_vol_ctlr_opmsg_set_aux_time_to_play_4>:
        return FALSE;
842013aa:	02 00       	r0 = Null + Null;
842013ac:	76 6e       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_17;

842013ae <Lc_vol_ctlr_opmsg_set_aux_time_to_play_5>:
    }

    /* drift_rate is in 1/10 of ppm, so convert it to a
     * fractional number.
     */
    aux_drift_rate = aux_drift_rate * FRACTIONAL(0.0001);
842013ae:	46 f3 dc f7 	r5 = r5 * 214748 (int);
842013b2:	97 d9 
    aux_drift_rate = frac_mult(aux_drift_rate, FRACTIONAL(0.001));
842013b4:	02 f0 62 f0 	r0 = Null + 2147483;
842013b8:	9b 48 
842013ba:	00 f2 77 c9 	r5 = r5 * r0 (frac);

    vol_ctrl_aux_channel_t  *aux_channel = &op_extra_data->aux_channel[aux_channel_index];
842013be:	61 f0 6c 20 	rMAC = r4 + 108;
     * if sent after that we aren't be able to meet the deadline for timed
     * playback so just return FALSE.
     */
    if(aux_channel->buffer != NULL &&
       aux_channel->state != AUX_STATE_NO_AUX &&
       aux_channel->state != AUX_STATE_END_AUX)
842013c2:	0a e8       	r0 = M[rMAC + Null];
842013c4:	11 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

842013c6 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_6>:
842013c6:	09 81       	rMAC = MBS[rMAC + 4];
842013c8:	0f 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

842013ca <Lc_vol_ctlr_opmsg_set_aux_time_to_play_7>:
842013ca:	c8 24       	Null = rMAC - 3;
842013cc:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

842013ce <Lc_vol_ctlr_opmsg_set_aux_time_to_play_8>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback: "
                    "aux channel %d is already active",
                    aux_channel_index);
842013ce:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842013d2:	88 24       	Null = rMAC - 2;
842013d4:	eb 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

842013d6 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_9>:
842013d6:	55 f1 02 f0 	r0 = Null + 357564858;
842013da:	ba 41 
842013dc:	03 00       	r1 = Null + Null;
842013de:	ef fd fc ff 	call (m) 0xcde;
842013e2:	21 e8 
842013e4:	e3 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

842013e6 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_10>:
        return FALSE;
    }

    /* Sanity check on time to play time */
    TIME current_time = time_get_time();
842013e6:	ff fd 26 f0 	call (m) 0x6100;
842013ea:	3b e8 
842013ec:	13 00       	r1 = r0 + Null;
    TIME_INTERVAL ttp_in_future = time_sub(aux_time_to_play, current_time);
842013ee:	3f f8 01 c2 	rMAC = r6 - r1;
    if(ttp_in_future < (VOL_CTRL_AUX_MIN_TTP_IN_FUTURE_MS*MILLISECOND) ||
       ttp_in_future > (VOL_CTRL_AUX_MAX_TTP_IN_FUTURE_MS*MILLISECOND))
842013f2:	01 f0 10 f3 	Null = rMAC - 30000;
842013f6:	30 2d 
842013f8:	05 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_12;

842013fa <Lc_vol_ctlr_opmsg_set_aux_time_to_play_11>:
842013fa:	c4 f4 10 f2 	Null = rMAC - 20000000;
842013fe:	00 3d 
84201400:	0d 6c       	if LE jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_14;

84201402 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_12>:
    {
        L2_DBG_MSG2("Volume Control Aux Timed Playback: "
                    "Requested time to play is too early or too late,"
                    "current time=%d, time to play=%d",
                    current_time, aux_time_to_play);
84201402:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201406:	88 24       	Null = rMAC - 2;
84201408:	d1 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420140a <Lc_vol_ctlr_opmsg_set_aux_time_to_play_13>:
8420140a:	55 f1 02 f0 	r0 = Null + 357564926;
8420140e:	fe 41 
84201410:	44 08       	r2 = r6 + Null;
84201412:	ef fd fc ff 	call (m) 0xcf2;
84201416:	21 e7 
84201418:	c9 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420141a <Lc_vol_ctlr_opmsg_set_aux_time_to_play_14>:
     * aux_time_to_play will be for first sample of aux,
     * we have a ramping down time for main channel before
     * actual mixing happens.
     * */
    vol_ctrl_aux_params_t *aux_param = (vol_ctrl_aux_params_t *)
        (&op_extra_data->parameters.OFFSET_AUX1_SCALE);
8420141a:	61 f0 94 21 	rMAC = r4 + 404;
    unsigned atk_tc = aux_param[aux_channel_index].atk_tc;
8420141e:	4b 88       	r1 = M[rMAC + 4];
    TIME_INTERVAL start_period = (TIME_INTERVAL) ((1<<(DAWTH-1))/atk_tc)*10;
84201420:	00 f8 02 f0 	r0 = Null + -2147483648;
84201424:	00 40 
84201426:	ff fd c7 f0 	call (m) 0x1a290;
8420142a:	2b e3 
8420142c:	91 42       	rMAC = r0 * 10 (int);
    TIME ttp_gate_time = time_sub(aux_time_to_play, start_period);
8420142e:	1f f8 0b c2 	r9 = r6 - rMAC;
    /* aux timed playback message in only for one tone/prompt,
     * if we don't receive the actual aux data within reasonable
     * time, timed playback will expire and later received aux data
     * will be mixed in normal non-ttp mode */
    TIME ttp_expiry_time = time_add(aux_time_to_play,
                                    VOL_CTRL_AUX_TTP_EXPIRY_PERIOD_MS*MILLISECOND);
84201432:	06 f0 8a f0 	r8 = r6 + 100000;
84201436:	a0 2a 

    L2_DBG_MSG4("Volume Control, setting auxiliary playback time:"
                " time=%d, channel=%d, ttp=%d, drift=%d",
                time_get_time(), aux_channel_index, aux_time_to_play, aux_drift_rate);
84201438:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420143c:	88 24       	Null = rMAC - 2;
8420143e:	0f 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_16;

84201440 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_15>:
84201440:	ff fd 26 f0 	call (m) 0x6100;
84201444:	21 e6 
84201446:	13 00       	r1 = r0 + Null;
84201448:	39 1c       	pushm <r5>;
8420144a:	55 f1 02 f0 	r0 = Null + 357565042;
8420144e:	72 42 
84201450:	04 00       	r2 = Null + Null;
84201452:	45 08       	r3 = r6 + Null;
84201454:	ef fd fc ff 	call (m) 0xd20;
84201458:	2d e6 
8420145a:	7f 4c       	SP = SP + -4;

8420145c <Lc_vol_ctlr_opmsg_set_aux_time_to_play_16>:
    /* postpone processing just in case this update is preempted
     * by the operator's process. Normally user is expected to send
     * this message before auxiliary path starts sending audio data,
     * so practically perhaps not required.
     */
    opmgr_op_suspend_processing(op_data);
8420145c:	4a 08       	r0 = r7 + Null;
8420145e:	ff fd 21 f0 	call (m) 0x570c;
84201462:	2f e5 
    op_extra_data->aux0_ttp.time_to_play = aux_time_to_play;
84201464:	68 f0 c5 8e 	M[r4 + 788] = r6;
    op_extra_data->aux0_ttp.expiry_time = ttp_expiry_time;
84201468:	6a f0 c6 8e 	M[r4 + 792] = r8;
    op_extra_data->aux0_ttp.gate_time = ttp_gate_time;
8420146c:	6b f0 c7 8e 	M[r4 + 796] = r9;
    op_extra_data->aux0_ttp.drift_rate = aux_drift_rate;
84201470:	67 f0 c9 8e 	M[r4 + 804] = r5;
    op_extra_data->aux0_ttp.enabled = TRUE;
84201474:	41 20       	rMAC = Null + 1;
84201476:	61 f0 c4 8e 	M[r4 + 784] = rMAC;

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
    record_aux_ttr_event(op_data,
                         VOL_CTRL_TTR_EVENT_AUX_STATE,
                         pack_aux_state(op_extra_data),
                         aux_time_to_play);
8420147a:	32 00       	r0 = r4 + Null;
8420147c:	01 f0 3d ef 	call (m) Lc_pack_aux_state_1;
84201480:	03 f0 44 40 	r1 = Null + 68;
84201484:	45 08       	r3 = r6 + Null;
84201486:	14 00       	r2 = r0 + Null;
84201488:	4a 08       	r0 = r7 + Null;
8420148a:	02 f0 31 e0 	call (m) Lc_record_aux_ttr_event_1;
#endif /* VOLUME_CONTROL_AUX_TIMING_TRACE */
    opmgr_op_resume_processing(op_data);
8420148e:	4a 08       	r0 = r7 + Null;
84201490:	ff fd 21 f0 	call (m) 0x573a;
84201494:	2b e5 
    return TRUE;
84201496:	42 20       	r0 = Null + 1;

84201498 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_17>:
}
84201498:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420149a:	d8 4c       	rts;

8420149c <$_vol_ctlr_opmsg_set_downstream_latency_est>:

bool vol_ctlr_opmsg_set_downstream_latency_est(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420149c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420149e:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842014a0:	ef fd f8 ff 	call (m) 0x4e6;
842014a4:	27 e2 
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* get downstream latency field */
    unsigned latency_est_ms = OPMSG_FIELD_GET(message_data,
                                              OPMSG_VOL_CTRL_SET_DOWNSTREAM_LATENCY_EST,
                                              LATENCY_EST_MS);
842014a6:	f1 88       	rMAC = M[r4 + 12];
842014a8:	89 c6       	rMAC = rMAC AND 0xffff;
    /* check maximum value */
    if(latency_est_ms > VOL_CTRL_MAX_DOWNSTREAM_LATENCY_MS)
842014aa:	10 f0 c8 24 	Null = rMAC - 200;
842014ae:	09 f0 89 e0 	if LS jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_3;

842014b2 <Lc_vol_ctlr_opmsg_set_downstream_latency_est_2>:
    {
        return FALSE;
842014b2:	02 00       	r0 = Null + Null;
842014b4:	04 6e       	jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_4;

842014b6 <Lc_vol_ctlr_opmsg_set_downstream_latency_est_3>:

    /* set downstream latency config, change while
	   the operator is running is ok, but the value
	   will be used from next auxiliary burst.
	 */
    VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data) = latency_est_ms;
842014b6:	21 f0 d2 8e 	M[r0 + 840] = rMAC;
    return TRUE;
842014ba:	42 20       	r0 = Null + 1;

842014bc <Lc_vol_ctlr_opmsg_set_downstream_latency_est_4>:
}
842014bc:	f1 48       	popm <FP, r4, rLink>;
842014be:	d8 4c       	rts;

842014c0 <Lc_vol_ctrl_fixup_buffer_details_1>:
 */
static bool vol_ctrl_fixup_buffer_details(VOL_CTRL_DATA_T *op_extra_data, unsigned terminal_id, OP_BUF_DETAILS_RSP *resp)
{
    patch_fn_shared(volume_control_wrapper);

    return TRUE;
842014c0:	42 20       	r0 = Null + 1;

842014c2 <Lc_vol_ctrl_fixup_buffer_details_2>:
842014c2:	d8 4c       	rts;

842014c4 <Lc_vol_ctrl_recalc_main_buffer_size_1>:
842014c4:	d8 4c       	rts;

842014c6 <Lc_vol_ctrl_recalc_aux_buffer_size_1>:

/**
 * \brief Update aux_buffer_size with the minimum of connected aux buffers' sizes
 */
static void vol_ctrl_recalc_aux_buffer_size(VOL_CTRL_DATA_T *op_extra_data)
{
842014c6:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842014c8:	16 00       	r4 = r0 + Null;
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;
842014ca:	ff f7 f8 f7 	r6 = Null + 2147483647;
842014ce:	ff 7b 

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
842014d0:	07 00       	r5 = Null + Null;
842014d2:	69 f0 6c 20 	r7 = r4 + 108;

842014d6 <Lc_vol_ctrl_recalc_aux_buffer_size_2>:
    {
        tCbuffer* aux_buffer = op_extra_data->aux_channel[ch].buffer;
        if (aux_buffer != NULL)
842014d6:	92 f0 00 e8 	r0 = M[r7 + Null];
842014da:	08 60       	if EQ jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

842014dc <Lc_vol_ctrl_recalc_aux_buffer_size_3>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
842014dc:	ff fd 97 f0 	call (m) 0x14450;
842014e0:	35 eb 
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
842014e2:	2f f8 00 c2 	Null = r6 - r0;
842014e6:	02 64       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

842014e8 <Lc_vol_ctrl_recalc_aux_buffer_size_4>:
842014e8:	10 09       	r6 = r0 + Null;

842014ea <Lc_vol_ctrl_recalc_aux_buffer_size_5>:
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
842014ea:	7f 20       	r5 = r5 + 1;
842014ec:	81 75       	r7 = r7 + 16;
842014ee:	38 26       	Null = r5 - 8;
842014f0:	f3 65       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_2;

842014f2 <Lc_vol_ctrl_recalc_aux_buffer_size_6>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
        }
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
842014f2:	68 f0 bb 8e 	M[r4 + 748] = r6;

842014f6 <Lc_vol_ctrl_recalc_aux_buffer_size_7>:
}
842014f6:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842014f8:	d8 4c       	rts;

842014fa <Lc_vol_ctrl_kick_waiting_1>:
842014fa:	d8 4c       	rts;

842014fc <Lc_vol_ctrl_handle_aux_metadata_1>:
 *          delete all other aux metadata
 * \param op_extra_data     volume control operator specific data
 * \returns                 EOF tag, if found
 */
static metadata_tag* vol_ctrl_handle_aux_metadata(VOL_CTRL_DATA_T *op_extra_data)
{
842014fc:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
842014fe:	17 00       	r5 = r0 + Null;
    metadata_tag* aux_tag_head = NULL;
84201500:	02 00       	r0 = Null + Null;
    metadata_tag* eoftag = NULL;
84201502:	06 00       	r4 = Null + Null;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
84201504:	00 09       	r6 = Null + Null;
    unsigned b4idx, afteridx;

    /* get aux metadata, if applicable */
    if (op_extra_data->metadata_aux_channel != NULL)
84201506:	39 a9       	rMAC = M[r5 + 80];
84201508:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_3;

8420150a <Lc_vol_ctrl_handle_aux_metadata_2>:
    {
        aux_tag_head = buff_metadata_remove(op_extra_data->metadata_aux_channel->buffer,
                                            op_extra_data->metadata_aux_channel->advance_buffer * OCTETS_PER_SAMPLE,
                                            &b4idx, &afteridx);
8420150a:	85 11       	r3 = FP + 24;
8420150c:	44 11       	r2 = FP + 20;
8420150e:	ca 88       	r0 = M[rMAC + 12];
84201510:	53 54       	r1 = r0 LSHIFT 2;
84201512:	0a e8       	r0 = M[rMAC + Null];
84201514:	ff fd 9a f0 	call (m) 0x149ca;
84201518:	37 e5 

8420151a <Lc_vol_ctrl_handle_aux_metadata_3>:
    }

    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
8420151a:	f9 a8       	rMAC = M[r5 + 76];
8420151c:	14 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

8420151e <Lc_vol_ctrl_handle_aux_metadata_4>:
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
8420151e:	11 00       	rMAC = r0 + Null;

84201520 <Lc_vol_ctrl_handle_aux_metadata_5>:
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
84201520:	08 04       	Null = rMAC - Null;
84201522:	11 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

84201524 <Lc_vol_ctrl_handle_aux_metadata_6>:
84201524:	4b 88       	r1 = M[rMAC + 4];
84201526:	5b c0       	r1 = r1 AND 0x2;
84201528:	04 62       	if NE jump (m) Lc_vol_ctrl_handle_aux_metadata_8;

8420152a <Lc_vol_ctrl_handle_aux_metadata_7>:
        {
            prev_tag = tmp_tag;
8420152a:	08 09       	r6 = rMAC + Null;
            tmp_tag = tmp_tag->next;
8420152c:	09 e8       	rMAC = M[rMAC + Null];
    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
8420152e:	f9 6f       	jump (m) Lc_vol_ctrl_handle_aux_metadata_5;

84201530 <Lc_vol_ctrl_handle_aux_metadata_8>:
            tmp_tag = tmp_tag->next;
        }
        if (tmp_tag != NULL)
        {
            /* EOF tag was found in aux metadata*/
            eoftag = tmp_tag;
84201530:	0e 00       	r4 = rMAC + Null;
            /* remove it from the list */
            if (prev_tag != NULL)
84201532:	0f f8 00 c2 	Null = r6 - Null;
84201536:	05 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_10;

84201538 <Lc_vol_ctrl_handle_aux_metadata_9>:
            {
                prev_tag->next = eoftag->next;
84201538:	0b e8       	r1 = M[rMAC + Null];
8420153a:	83 f0 00 ee 	M[r6 + Null] = r1;
8420153e:	02 6e       	jump (m) Lc_vol_ctrl_handle_aux_metadata_11;

84201540 <Lc_vol_ctrl_handle_aux_metadata_10>:
            }
            else
            {
                aux_tag_head = eoftag->next;
84201540:	0a e8       	r0 = M[rMAC + Null];

84201542 <Lc_vol_ctrl_handle_aux_metadata_11>:
            }
            eoftag->next = NULL;
84201542:	08 ee       	M[rMAC + Null] = Null;

84201544 <Lc_vol_ctrl_handle_aux_metadata_12>:
        }
    }
    /* delete aux metadata anyways */
    buff_metadata_tag_list_delete(aux_tag_head);
84201544:	ff fd 98 f0 	call (m) 0x145ee;
84201548:	2b e5 

    return eoftag;
8420154a:	32 00       	r0 = r4 + Null;

8420154c <Lc_vol_ctrl_handle_aux_metadata_13>:
}
8420154c:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
8420154e:	d8 4c       	rts;

84201550 <Lc_vol_ctrl_handle_input_metadata_1>:
 * \brief Transport metadata from input to output and handle aux EOF.
 * \param op_extra_data     volume control operator specific data
 * \param eoftag            EOF tag, if found in aux metadata
 */
static void vol_ctrl_handle_input_metadata(VOL_CTRL_DATA_T *op_extra_data, metadata_tag* eoftag)
{
84201550:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84201552:	16 00       	r4 = r0 + Null;
84201554:	18 09       	r6 = r1 + Null;
    metadata_tag *ret_mtag;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
    unsigned b4idx, afteridx;
    unsigned input_amount = op_extra_data->tc.num_words * OCTETS_PER_SAMPLE;
84201556:	62 f0 b2 88 	r0 = M[r4 + 712];
8420155a:	01 f2 d9 c8 	r7 = r0 LSHIFT 2;

    /* get input metadata, if applicable*/
    if (op_extra_data->metadata_ip_buffer != NULL)
8420155e:	b2 a8       	r0 = M[r4 + 72];
84201560:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_3;

84201562 <Lc_vol_ctrl_handle_input_metadata_2>:
    {
        ret_mtag = buff_metadata_remove(op_extra_data->metadata_ip_buffer,
                                        input_amount, &b4idx, &afteridx);
84201562:	c5 11       	r3 = FP + 28;
84201564:	84 11       	r2 = FP + 24;
84201566:	4b 08       	r1 = r7 + Null;
84201568:	ff fd 9a f0 	call (m) 0x149ca;
8420156c:	23 e3 
8420156e:	17 00       	r5 = r0 + Null;
84201570:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_4;

84201572 <Lc_vol_ctrl_handle_input_metadata_3>:
    }
    else
    {
        b4idx = 0;
84201572:	30 de       	M[FP + 24] = Null;
        afteridx = input_amount;
84201574:	e9 f0 07 8e 	M[FP + 28] = r7;
        ret_mtag = NULL;
84201578:	07 00       	r5 = Null + Null;

8420157a <Lc_vol_ctrl_handle_input_metadata_4>:
    }

    if (op_extra_data->metadata_op_buffer != NULL)
8420157a:	f1 a8       	rMAC = M[r4 + 76];
8420157c:	78 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_36;

8420157e <Lc_vol_ctrl_handle_input_metadata_5>:
    {
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        if(op_extra_data->aux0_ttp.generate_ttp)
8420157e:	60 f0 c8 88 	Null = M[r4 + 800];
84201582:	06 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_7;

84201584 <Lc_vol_ctrl_handle_input_metadata_6>:
        {
            /* Operator shall generate timestamp itself, this
             * is done by time-stamping VOID tags.
             */
            vol_ctrl_timestamp_void_tags(op_extra_data, ret_mtag, b4idx);
84201584:	34 d8       	r2 = M[FP + 24];
84201586:	3b 00       	r1 = r5 + Null;
84201588:	32 00       	r0 = r4 + Null;
8420158a:	01 f0 21 e2 	call (m) Lc_vol_ctrl_timestamp_void_tags_1;

8420158e <Lc_vol_ctrl_handle_input_metadata_7>:
        }
#endif
        if (ret_mtag == NULL)
8420158e:	38 04       	Null = r5 - Null;
84201590:	31 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_19;

84201592 <Lc_vol_ctrl_handle_input_metadata_8>:
            /* No metadata in input: we cannot append EOF tags!
             * In this case we need to save the EOF tag until
             * a new input tag comes in.
             * If none does, we need to recognise the data closing
             * the last received tag and append the EOF there. */
            if (eoftag != NULL)
84201592:	0f f8 00 c2 	Null = r6 - Null;
84201596:	12 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_13;

84201598 <Lc_vol_ctrl_handle_input_metadata_9>:
            {
                /* Save it for next run. */
                if (op_extra_data->last_eoftag != NULL)
84201598:	72 a9       	r0 = M[r4 + 84];
8420159a:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_11;

8420159c <Lc_vol_ctrl_handle_input_metadata_10>:
                {
                    /* We already had a pending EOF tag. Delete it. */
                    buff_metadata_tag_list_delete(op_extra_data->last_eoftag);
8420159c:	ff fd 98 f0 	call (m) 0x145ee;
842015a0:	33 e2 

842015a2 <Lc_vol_ctrl_handle_input_metadata_11>:
                }
                op_extra_data->last_eoftag = eoftag;
842015a2:	68 f0 15 8e 	M[r4 + 84] = r6;
                L2_DBG_MSG("volume_control: aux EOF saved for next run");
842015a6:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842015aa:	88 24       	Null = rMAC - 2;
842015ac:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_13;

842015ae <Lc_vol_ctrl_handle_input_metadata_12>:
842015ae:	55 f1 02 f0 	r0 = Null + 357564416;
842015b2:	00 40 
842015b4:	ef fd fb ff 	call (m) 0xccc;
842015b8:	39 e8 

842015ba <Lc_vol_ctrl_handle_input_metadata_13>:
            }
            if (op_extra_data->last_tag_data_remaining <= input_amount)
842015ba:	b1 a9       	rMAC = M[r4 + 88];
842015bc:	9f f1 00 c2 	Null = rMAC - r7;
842015c0:	08 f0 ab e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_18;

842015c4 <Lc_vol_ctrl_handle_input_metadata_14>:
            {
                /* The last received tag is closed now and no other tags
                 * came through. If we had a pending EOF tag,
                 * we need to output it now */
                if (op_extra_data->last_eoftag != NULL)
842015c4:	71 a9       	rMAC = M[r4 + 84];
842015c6:	10 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_17;

842015c8 <Lc_vol_ctrl_handle_input_metadata_15>:
                {
                    ret_mtag = op_extra_data->last_eoftag;
842015c8:	0f 00       	r5 = rMAC + Null;
                    /* clear backup ptr */
                    op_extra_data->last_eoftag = NULL;
842015ca:	70 af       	M[r4 + 84] = Null;
                    b4idx = input_amount;
842015cc:	e9 f0 06 8e 	M[FP + 24] = r7;
                    afteridx = 0;
842015d0:	38 de       	M[FP + 28] = Null;
                    L2_DBG_MSG("volume_control: ORPHAN aux EOF moved to output");
842015d2:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842015d6:	88 24       	Null = rMAC - 2;
842015d8:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_17;

842015da <Lc_vol_ctrl_handle_input_metadata_16>:
842015da:	55 f1 02 f0 	r0 = Null + 357564459;
842015de:	2b 40 
842015e0:	ef fd fb ff 	call (m) 0xccc;
842015e4:	2d e7 

842015e6 <Lc_vol_ctrl_handle_input_metadata_17>:
                }
                op_extra_data->last_tag_data_remaining = 0;
842015e6:	b0 af       	M[r4 + 88] = Null;
842015e8:	3a 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

842015ea <Lc_vol_ctrl_handle_input_metadata_18>:
            }
            else
            {
                /* update the number of octets to come to complete the last tag */
                op_extra_data->last_tag_data_remaining -= input_amount;
842015ea:	00 f9 31 c2 	rMAC = rMAC - r7;
842015ee:	b1 af       	M[r4 + 88] = rMAC;
842015f0:	36 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

842015f2 <Lc_vol_ctrl_handle_input_metadata_19>:
        }
        else
        {
            /* Check if we found an EOF on a previous run where input had no
             * metadata and we could not append it on the output. */
            if (op_extra_data->last_eoftag != NULL && ret_mtag != NULL)
842015f2:	71 a9       	rMAC = M[r4 + 84];
842015f4:	0e 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_22;

842015f6 <Lc_vol_ctrl_handle_input_metadata_20>:
            {
                /* Transport now at the beginning of the output*/
                op_extra_data->last_eoftag->next = ret_mtag;
842015f6:	0f ee       	M[rMAC + Null] = r5;
                ret_mtag = op_extra_data->last_eoftag;
842015f8:	77 a9       	r5 = M[r4 + 84];
                /* clear backup ptr */
                op_extra_data->last_eoftag = NULL;
842015fa:	70 af       	M[r4 + 84] = Null;
                L2_DBG_MSG("volume_control: previous aux EOF moved to output");
842015fc:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201600:	88 24       	Null = rMAC - 2;
84201602:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_22;

84201604 <Lc_vol_ctrl_handle_input_metadata_21>:
84201604:	55 f1 02 f0 	r0 = Null + 357564506;
84201608:	5a 40 
8420160a:	ef fd fb ff 	call (m) 0xccc;
8420160e:	23 e6 

84201610 <Lc_vol_ctrl_handle_input_metadata_22>:
            }

            /* find the last tag of input metadata */
            tmp_tag = ret_mtag;
84201610:	3a 00       	r0 = r5 + Null;
            prev_tag = NULL;
84201612:	01 00       	rMAC = Null + Null;

84201614 <Lc_vol_ctrl_handle_input_metadata_23>:
            while (tmp_tag->next != NULL)
84201614:	13 e8       	r1 = M[r0 + Null];
84201616:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_25;

84201618 <Lc_vol_ctrl_handle_input_metadata_24>:
            {
                prev_tag = tmp_tag;
84201618:	11 00       	rMAC = r0 + Null;
                tmp_tag = tmp_tag->next;
8420161a:	1a 00       	r0 = r1 + Null;
8420161c:	fc 6f       	jump (m) Lc_vol_ctrl_handle_input_metadata_23;

8420161e <Lc_vol_ctrl_handle_input_metadata_25>:
            }

            /* save the number of octets to come to complete the last tag*/
            if (afteridx > 0 && afteridx <= tmp_tag->length)
8420161e:	3b d8       	r1 = M[FP + 28];
84201620:	08 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_28;

84201622 <Lc_vol_ctrl_handle_input_metadata_26>:
84201622:	d4 88       	r2 = M[r0 + 12];
84201624:	18 05       	Null = r1 - r2;
84201626:	08 f0 8b e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_28;

8420162a <Lc_vol_ctrl_handle_input_metadata_27>:
            {
                op_extra_data->last_tag_data_remaining = tmp_tag->length - afteridx;
8420162a:	e3 04       	r1 = r2 - r1;
8420162c:	b3 af       	M[r4 + 88] = r1;
8420162e:	02 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_29;

84201630 <Lc_vol_ctrl_handle_input_metadata_28>:
            }
            else
            {
                op_extra_data->last_tag_data_remaining = 0;
84201630:	b0 af       	M[r4 + 88] = Null;

84201632 <Lc_vol_ctrl_handle_input_metadata_29>:
            }

            if (eoftag != NULL)
84201632:	0f f8 00 c2 	Null = r6 - Null;
84201636:	13 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_35;

84201638 <Lc_vol_ctrl_handle_input_metadata_30>:
            {
                /* We found an EOF on the aux channel on this run
                 * bring it on the output in second to last position:
                 * aux_tag is the last tag, place eof tag in front of it. */
                eoftag->next = tmp_tag;
84201638:	82 f0 00 ee 	M[r6 + Null] = r0;
                if (prev_tag == NULL)
8420163c:	08 04       	Null = rMAC - Null;
8420163e:	03 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_32;

84201640 <Lc_vol_ctrl_handle_input_metadata_31>:
                {
                    ret_mtag = eoftag;
84201640:	47 08       	r5 = r6 + Null;
84201642:	03 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_33;

84201644 <Lc_vol_ctrl_handle_input_metadata_32>:
                }
                else
                {
                    prev_tag->next = eoftag;
84201644:	18 f0 00 ee 	M[rMAC + Null] = r6;

84201648 <Lc_vol_ctrl_handle_input_metadata_33>:
                }
                L2_DBG_MSG("volume_control: aux EOF moved to output");
84201648:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420164c:	88 24       	Null = rMAC - 2;
8420164e:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_35;

84201650 <Lc_vol_ctrl_handle_input_metadata_34>:
84201650:	55 f1 02 f0 	r0 = Null + 357564555;
84201654:	8b 40 
84201656:	ef fd fb ff 	call (m) 0xccc;
8420165a:	37 e3 

8420165c <Lc_vol_ctrl_handle_input_metadata_35>:
            }
        }
        /* write metadata to output */
        buff_metadata_append(op_extra_data->metadata_op_buffer, ret_mtag, b4idx, afteridx);
8420165c:	3d d8       	r3 = M[FP + 28];
8420165e:	34 d8       	r2 = M[FP + 24];
84201660:	f2 a8       	r0 = M[r4 + 76];
84201662:	3b 00       	r1 = r5 + Null;
84201664:	ff fd 98 f0 	call (m) 0x147b8;
84201668:	35 ea 
8420166a:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_37;

8420166c <Lc_vol_ctrl_handle_input_metadata_36>:
    }
    else
    {
        /* we cannot output metadata, delete input metadata */
        buff_metadata_tag_list_delete(ret_mtag);
8420166c:	3a 00       	r0 = r5 + Null;
8420166e:	ff fd 97 f0 	call (m) 0x145ee;
84201672:	21 ec 

84201674 <Lc_vol_ctrl_handle_input_metadata_37>:
    }
}
84201674:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84201676:	d8 4c       	rts;

84201678 <Lc_vol_ctrl_update_current_timestamp_1>:
 *        playback of aux inputs.
 * \param op_extra_data volume control operator specific data
 * \param amount_consumed amount of input consumed since last update
 */
static void vol_ctrl_update_current_timestamp(VOL_CTRL_DATA_T *op_extra_data)
{
84201678:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
8420167a:	10 09       	r6 = r0 + Null;
    unsigned amount_consumed = op_extra_data->prev_consumed_samples;
8420167c:	87 f0 cf 88 	r5 = M[r6 + 828];
    /* This will be set again when op consumes samples from input */
    op_extra_data->prev_consumed_samples = 0;
84201680:	80 f0 cf 8e 	M[r6 + 828] = Null;
#endif

    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
84201684:	30 de       	M[FP + 24] = Null;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
84201686:	83 11       	r1 = FP + 24;
84201688:	82 f0 12 88 	r0 = M[r6 + 72];
8420168c:	ff fd 99 f0 	call (m) 0x14930;
84201690:	25 e5 
84201692:	16 00       	r4 = r0 + Null;
84201694:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_3;

84201696 <Lc_vol_ctrl_update_current_timestamp_2>:

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
            return;
        }
        b4idx += mtag->length;
84201696:	f1 88       	rMAC = M[r4 + 12];
84201698:	32 d8       	r0 = M[FP + 24];
8420169a:	51 00       	rMAC = r0 + rMAC;
8420169c:	31 de       	M[FP + 24] = rMAC;
        mtag = mtag->next;
8420169e:	36 e8       	r4 = M[r4 + Null];

842016a0 <Lc_vol_ctrl_update_current_timestamp_3>:
    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
    while(mtag != NULL)
842016a0:	30 04       	Null = r4 - Null;
842016a2:	36 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_10;

842016a4 <Lc_vol_ctrl_update_current_timestamp_4>:
    {
        /* Search the input buffer metadata, if we see a TTP tag, then we use input time
         * stamps for the purpose of mixing time of auxiliary inputs to main inputs.
         */
        if(IS_TIMESTAMPED_TAG(mtag))
842016a4:	71 88       	rMAC = M[r4 + 4];
842016a6:	12 f0 30 00 	r0 = rMAC AND 0x30;
842016aa:	f6 61       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_2;

842016ac <Lc_vol_ctrl_update_current_timestamp_5>:
842016ac:	c9 c2       	rMAC = rMAC AND 0x40;
842016ae:	f4 63       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_2;

842016b0 <Lc_vol_ctrl_update_current_timestamp_6>:
        {
            unsigned *err_offset_id;
            unsigned out_length;
            /* go back to first input sample */
            TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE,
                                                              op_extra_data->sample_rate);
842016b0:	83 f0 3b 88 	r1 = M[r6 + 236];
842016b4:	32 d8       	r0 = M[FP + 24];
842016b6:	52 50       	r0 = r0 LSHIFT -2;
842016b8:	ff fd b6 f0 	call (m) 0x183fe;
842016bc:	27 ea 
            op_extra_data->current_timestamp = time_sub(mtag->timestamp, time_back);
842016be:	31 89       	rMAC = M[r4 + 16];
842016c0:	89 04       	rMAC = rMAC - r0;
842016c2:	81 f0 cc 8e 	M[r6 + 816] = rMAC;
            if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                (void **)&err_offset_id))
842016c6:	c5 11       	r3 = FP + 28;
842016c8:	04 12       	r2 = FP + 32;
842016ca:	43 20       	r1 = Null + 1;
842016cc:	32 00       	r0 = r4 + Null;
842016ce:	ff fd 98 f0 	call (m) 0x14762;
842016d2:	35 e4 
842016d4:	10 04       	Null = r0 - Null;
842016d6:	0e 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

842016d8 <Lc_vol_ctrl_update_current_timestamp_7>:
            {
                int *err_offset_ptr = ttp_info_get(*err_offset_id);
842016d8:	39 d8       	rMAC = M[FP + 28];
842016da:	0a e8       	r0 = M[rMAC + Null];
842016dc:	ff fd c2 f0 	call (m) 0x19c1a;
842016e0:	3f e9 
                if (err_offset_ptr != NULL)
842016e2:	10 04       	Null = r0 - Null;
842016e4:	07 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

842016e6 <Lc_vol_ctrl_update_current_timestamp_8>:
                {
                    /* subtract the offset */
                    op_extra_data->current_timestamp =
                        time_sub(op_extra_data->current_timestamp, *err_offset_ptr);
842016e6:	81 f0 cc 88 	rMAC = M[r6 + 816];
842016ea:	12 e8       	r0 = M[r0 + Null];
842016ec:	89 04       	rMAC = rMAC - r0;
842016ee:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

842016f2 <Lc_vol_ctrl_update_current_timestamp_9>:
            /* current_timestamp: time stamp associated with first sample of input
             * main_timestamp_valid: whether main input has valid timestamp
             * last_main_real_timestamp: last valid timestamp we received from main input
             */
            op_extra_data->last_main_real_timestamp =
                op_extra_data->current_timestamp;
842016f2:	81 f0 cc 88 	rMAC = M[r6 + 816];
842016f6:	81 f0 cb 8e 	M[r6 + 812] = rMAC;
            op_extra_data->main_timestamp_valid = TRUE;
842016fa:	41 20       	rMAC = Null + 1;
842016fc:	81 f0 ca 8e 	M[r6 + 808] = rMAC;
            op_extra_data->current_timestamp_valid = TRUE;
84201700:	81 f0 cd 8e 	M[r6 + 820] = rMAC;

            /* real timestamp from input update, no accumulated remainder*/
            op_extra_data->current_timestamp_update_remainder = 0;
84201704:	80 f0 ce 8e 	M[r6 + 824] = Null;

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
84201708:	80 f0 c8 8e 	M[r6 + 800] = Null;
8420170c:	5d 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

8420170e <Lc_vol_ctrl_update_current_timestamp_10>:
     *    we can build based on last received timestamp from main
     *    buffer. We stop relying on main timestamp if we
     *    haven't received any timestamp from input in last
     *    MAX_REBUILD_TIMESTAMP_PERIOD milliseconds.
     */
    if(op_extra_data->main_timestamp_valid)
8420170e:	80 f0 ca 88 	Null = M[r6 + 808];
84201712:	13 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_14;

84201714 <Lc_vol_ctrl_update_current_timestamp_11>:
    {
        TIME_INTERVAL time_passed_since_last_real_timestamp =
            time_sub(op_extra_data->current_timestamp,
                     op_extra_data->last_main_real_timestamp);
84201714:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201718:	82 f0 cb 88 	r0 = M[r6 + 812];
8420171c:	89 04       	rMAC = rMAC - r0;
        if(time_passed_since_last_real_timestamp >
           (int)(VOL_CTRL_AUX_USE_MAIN_TIMESTAMP_PERIOD_MS*MILLISECOND))
8420171e:	0c f0 10 f0 	Null = rMAC - 200000;
84201722:	40 3d 
84201724:	07 6c       	if LE jump (m) Lc_vol_ctrl_update_current_timestamp_13;

84201726 <Lc_vol_ctrl_update_current_timestamp_12>:
        {
            /* stop using main timestamp */
            op_extra_data->main_timestamp_valid = FALSE;
84201726:	80 f0 ca 8e 	M[r6 + 808] = Null;
            op_extra_data->current_timestamp_valid = FALSE;
8420172a:	80 f0 cd 8e 	M[r6 + 820] = Null;
            op_extra_data->current_timestamp_update_remainder = 0;
8420172e:	80 f0 ce 8e 	M[r6 + 824] = Null;

84201732 <Lc_vol_ctrl_update_current_timestamp_13>:
     * to process actual aux data.
     */
    if(!op_extra_data->main_timestamp_valid &&
       op_extra_data->aux0_ttp.enabled &&
       !op_extra_data->aux0_ttp.generate_ttp &&
       !op_extra_data->aux_active)
84201732:	80 f0 ca 88 	Null = M[r6 + 808];
84201736:	1b 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

84201738 <Lc_vol_ctrl_update_current_timestamp_14>:
84201738:	80 f0 c4 88 	Null = M[r6 + 784];
8420173c:	15 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_18;

8420173e <Lc_vol_ctrl_update_current_timestamp_15>:
8420173e:	80 f0 c8 88 	Null = M[r6 + 800];
84201742:	15 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

84201744 <Lc_vol_ctrl_update_current_timestamp_16>:
84201744:	80 f0 b8 88 	Null = M[r6 + 736];
84201748:	0f 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_18;

8420174a <Lc_vol_ctrl_update_current_timestamp_17>:
    {
        /* Start self ttp generating, with an estimated
         * target latency from current time.
         */
        TIME cur_time = time_get_time();
8420174a:	ff fd 24 f0 	call (m) 0x6100;
8420174e:	37 ed 
        op_extra_data->current_timestamp_valid = TRUE;
84201750:	41 20       	rMAC = Null + 1;
84201752:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
        op_extra_data->current_timestamp =
            time_add(cur_time, op_extra_data->downstream_latency_estimate);
84201756:	83 f0 d0 88 	r1 = M[r6 + 832];
8420175a:	9a 00       	r0 = r1 + r0;
8420175c:	82 f0 cc 8e 	M[r6 + 816] = r0;
        op_extra_data->aux0_ttp.generate_ttp = TRUE;
84201760:	81 f0 c8 8e 	M[r6 + 800] = rMAC;
84201764:	31 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

84201766 <Lc_vol_ctrl_update_current_timestamp_18>:
     * if input has valid timestamp op will not
     * generate ttp itself.
     * */
    op_extra_data->current_timestamp_valid =
        op_extra_data->main_timestamp_valid ||
        op_extra_data->aux0_ttp.generate_ttp;
84201766:	80 f0 ca 88 	Null = M[r6 + 808];
8420176a:	03 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_20;

8420176c <Lc_vol_ctrl_update_current_timestamp_19>:
8420176c:	41 20       	rMAC = Null + 1;
8420176e:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_21;

84201770 <Lc_vol_ctrl_update_current_timestamp_20>:
84201770:	41 20       	rMAC = Null + 1;
84201772:	80 f0 c8 88 	Null = M[r6 + 800];
84201776:	00 f0 01 c0 	if EQ rMAC = Null + Null;

8420177a <Lc_vol_ctrl_update_current_timestamp_21>:

    /* Build timestamp from previous one considering number of samples
     * consumed since
     */
    if(op_extra_data->current_timestamp_valid && amount_consumed != 0)
8420177a:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
8420177e:	24 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

84201780 <Lc_vol_ctrl_update_current_timestamp_22>:
84201780:	38 04       	Null = r5 - Null;
84201782:	22 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

84201784 <Lc_vol_ctrl_update_current_timestamp_23>:
    {
        /* new_time_stamp = previous_time_stamp + amount_consumed/sample_rate
         * we keep a remainder to avoid the effect of truncation.
         */
        uint64 tm_mul = (uint64)amount_consumed * 1000000 +
            op_extra_data->current_timestamp_update_remainder;
84201784:	82 f0 ce 88 	r0 = M[r6 + 824];
84201788:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
8420178c:	40 f7 11 cc 
84201790:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
84201792:	00 f1 d5 c8 	r3 = rMAC LSHIFT 0;
84201796:	cc 57       	r2 = rMAC LSHIFT 32;
84201798:	16 01       	r4 = r0 + r2;
8420179a:	47 03       	r5 = Null + r3 + Carry;
        TIME_INTERVAL time_passed = (TIME_INTERVAL) (tm_mul/op_extra_data->sample_rate);
8420179c:	89 f0 3b 88 	r7 = M[r6 + 236];
842017a0:	4c 08       	r2 = r7 + Null;
842017a2:	05 00       	r3 = Null + Null;
842017a4:	3b 00       	r1 = r5 + Null;
842017a6:	32 00       	r0 = r4 + Null;
842017a8:	ff fd c5 f0 	call (m) 0x1a208;
842017ac:	21 e3 
842017ae:	11 00       	rMAC = r0 + Null;
        op_extra_data->current_timestamp_update_remainder =
            (unsigned)(tm_mul - ((uint64)time_passed*op_extra_data->sample_rate));
842017b0:	32 00       	r0 = r4 + Null;
842017b2:	9f f1 83 c9 	r1 = rMAC * r7 (int);
842017b6:	d2 04       	r0 = r0 - r1;
842017b8:	82 f0 ce 8e 	M[r6 + 824] = r0;
        op_extra_data->current_timestamp =
            time_add(op_extra_data->current_timestamp, time_passed);
842017bc:	82 f0 cc 88 	r0 = M[r6 + 816];
842017c0:	51 00       	rMAC = r0 + rMAC;
842017c2:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

842017c6 <Lc_vol_ctrl_update_current_timestamp_24>:
    }
}
842017c6:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
842017c8:	d8 4c       	rts;

842017ca <Lc_vol_ctrl_timestamp_void_tags_1>:
 * \octets_before_tag octets before mtag first octet
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
842017ca:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842017cc:	16 00       	r4 = r0 + Null;
842017ce:	1f 00       	r5 = r1 + Null;
842017d0:	20 09       	r6 = r2 + Null;

842017d2 <Lc_vol_ctrl_timestamp_void_tags_2>:
    while(NULL != mtag)
842017d2:	38 04       	Null = r5 - Null;
842017d4:	1d 60       	if EQ jump (m) Lc_vol_ctrl_timestamp_void_tags_7;

842017d6 <Lc_vol_ctrl_timestamp_void_tags_3>:
    {
        /* traverse through all tags in the list*/
        if(IS_VOID_TTP_TAG(mtag))
842017d6:	79 88       	rMAC = M[r5 + 4];
842017d8:	11 f0 70 00 	rMAC = rMAC AND 0x70;
842017dc:	10 f0 50 24 	Null = rMAC - 80;
842017e0:	13 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

842017e2 <Lc_vol_ctrl_timestamp_void_tags_4>:
842017e2:	38 89       	Null = M[r5 + 16];
842017e4:	11 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

842017e6 <Lc_vol_ctrl_timestamp_void_tags_5>:
            /* tags is a VOID tag, turn it to a TIMESTAMP tags.
             * Note: current_timestamp field holds ttp for octet 0
             */
            TIME_INTERVAL time_passed =
                convert_samples_to_time(octets_before_tag/ADDR_PER_WORD,
                                        op_extra_data->sample_rate);
842017e6:	63 f0 3b 88 	r1 = M[r4 + 236];
842017ea:	7f f8 d2 c8 	r0 = r6 LSHIFT -2;
842017ee:	ff fd b6 f0 	call (m) 0x183fe;
842017f2:	31 e0 
            METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
842017f4:	79 88       	rMAC = M[r5 + 4];
842017f6:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
            METADATA_TIMESTAMP_SET(mtag,
                                   time_add(op_extra_data->current_timestamp, time_passed),
                                   METADATA_TIMESTAMP_LOCAL);
842017fa:	c9 c9       	rMAC = rMAC OR 0x10;
842017fc:	79 8e       	M[r5 + 4] = rMAC;
842017fe:	61 f0 cc 88 	rMAC = M[r4 + 816];
84201802:	51 00       	rMAC = r0 + rMAC;
84201804:	39 8f       	M[r5 + 16] = rMAC;

84201806 <Lc_vol_ctrl_timestamp_void_tags_6>:
        }
        octets_before_tag += mtag->length;
84201806:	f9 88       	rMAC = M[r5 + 12];
84201808:	08 0d       	r6 = rMAC + r6;
        mtag = mtag->next;
8420180a:	3f e8       	r5 = M[r5 + Null];
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
    while(NULL != mtag)
8420180c:	e3 6f       	jump (m) Lc_vol_ctrl_timestamp_void_tags_2;

8420180e <Lc_vol_ctrl_timestamp_void_tags_7>:
                                   METADATA_TIMESTAMP_LOCAL);
        }
        octets_before_tag += mtag->length;
        mtag = mtag->next;
    }
}
8420180e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201810:	d8 4c       	rts;

84201812 <Lc_vol_ctrl_setup_mute_1>:
    op_extra_data->channels = NULL;
}


static void vol_ctrl_setup_mute(VOL_CTRL_DATA_T *op_extra_data,unsigned bMute)
{
84201812:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201814:	16 00       	r4 = r0 + Null;
84201816:	1f 00       	r5 = r1 + Null;

    /*  cur_mute_gain = 0 at start, and default mute=FALSE
        To immediately unmute set mute_period=0
    */

    if((op_extra_data->sample_rate<1) || (op_extra_data->mute_period<1) )
84201818:	63 f0 3b 88 	r1 = M[r4 + 236];
8420181c:	04 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_3;

8420181e <Lc_vol_ctrl_setup_mute_2>:
8420181e:	62 f0 c0 88 	r0 = M[r4 + 768];
84201822:	0b 62       	if NE jump (m) Lc_vol_ctrl_setup_mute_4;

84201824 <Lc_vol_ctrl_setup_mute_3>:
    {
        /* Immediately set mute gain */
        op_extra_data->cur_mute_gain  = bMute ? 0 : FRACTIONAL(1.0);
84201824:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84201828:	ff 7b 
8420182a:	38 04       	Null = r5 - Null;
8420182c:	01 f0 01 c0 	if NE rMAC = Null + Null;
84201830:	61 f0 c1 8e 	M[r4 + 772] = rMAC;
        mute_increment=1;
84201834:	42 20       	r0 = Null + 1;
84201836:	17 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

84201838 <Lc_vol_ctrl_setup_mute_4>:
    }
    else
    {

        if(op_extra_data->mute_period<1000)
84201838:	20 f0 e8 27 	Null = r0 - 1000;
8420183c:	02 f0 a1 e0 	if C jump (m) Lc_vol_ctrl_setup_mute_6;

84201840 <Lc_vol_ctrl_setup_mute_5>:
        {
            mute_increment = pl_fractional_divide(op_extra_data->mute_period,1000);
84201840:	03 f0 e8 43 	r1 = Null + 1000;
84201844:	ff fd e0 f1 	call (m) 0x3d950;
84201848:	2d e8 
            mute_increment = pl_fractional_divide(1,frac_mult(mute_increment,op_extra_data->sample_rate));
8420184a:	63 f0 3b 88 	r1 = M[r4 + 236];
8420184e:	3f f2 43 c9 	r1 = r0 * r1 (frac);
84201852:	42 20       	r0 = Null + 1;
84201854:	ff fd e0 f1 	call (m) 0x3d950;
84201858:	3d e7 
8420185a:	05 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

8420185c <Lc_vol_ctrl_setup_mute_6>:
        }
        else
        {
            mute_increment = pl_fractional_divide(1,op_extra_data->sample_rate);
8420185c:	42 20       	r0 = Null + 1;
8420185e:	ff fd e0 f1 	call (m) 0x3d950;
84201862:	33 e7 

84201864 <Lc_vol_ctrl_setup_mute_7>:
        }
    }

    /* Set direction of transition */
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;
84201864:	38 04       	Null = r5 - Null;
84201866:	05 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_9;

84201868 <Lc_vol_ctrl_setup_mute_8>:
84201868:	81 04       	rMAC = Null - r0;
8420186a:	61 f0 c2 8e 	M[r4 + 776] = rMAC;
8420186e:	03 6e       	jump (m) Lc_vol_ctrl_setup_mute_10;

84201870 <Lc_vol_ctrl_setup_mute_9>:
84201870:	62 f0 c2 8e 	M[r4 + 776] = r0;

84201874 <Lc_vol_ctrl_setup_mute_10>:

}
84201874:	f2 48       	popm <FP, r4, r5, rLink>;
84201876:	d8 4c       	rts;

84201878 <Lc_pack_aux_state_1>:
}
#endif /* INSTALL_METADATA */

#ifdef VOLUME_CONTROL_AUX_TIMING_TRACE
static uint32 pack_aux_state(VOL_CTRL_DATA_T *op_extra_data)
{
84201878:	48 1d       	pushm <FP(=SP)>, SP = SP + 0x10;
    VOL_CTRL_PACKED_AUX_STATE packed_aux_state;

    packed_aux_state.u.f.aux_state = op_extra_data->aux_channel[0].state;
8420187a:	21 f0 70 80 	rMAC = MBS[r0 + 112];
8420187e:	10 de       	M[FP + 8] = Null;
84201880:	41 da       	MB[FP + 8] = rMAC;
    packed_aux_state.u.f.aux_pending = op_extra_data->aux_pending;
84201882:	21 f0 bc 88 	rMAC = M[r0 + 752];
84201886:	49 da       	MB[FP + 9] = rMAC;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    packed_aux_state.u.f.ttp_enabled = op_extra_data->aux0_ttp.enabled;
84201888:	21 f0 c4 88 	rMAC = M[r0 + 784];
8420188c:	51 da       	MB[FP + 10] = rMAC;
    packed_aux_state.u.f.generate_ttp = op_extra_data->aux0_ttp.generate_ttp;
8420188e:	21 f0 c8 88 	rMAC = M[r0 + 800];
84201892:	59 da       	MB[FP + 11] = rMAC;
#endif

    return packed_aux_state.u.w;
84201894:	12 d8       	r0 = M[FP + 8];

84201896 <Lc_pack_aux_state_2>:
}
84201896:	48 49       	SP = SP - 0x10, popm <FP>;
84201898:	d8 4c       	rts;

8420189a <Lc_record_aux_ttr_event_1>:

static void record_aux_ttr_event(OPERATOR_DATA *op_data,
                                 TIMING_TRACE_OP_EVENT_TYPE event_type,
                                 unsigned arg1,
                                 unsigned arg2)
{
8420189a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420189c:	1e 00       	r4 = r1 + Null;
8420189e:	27 00       	r5 = r2 + Null;
842018a0:	28 09       	r6 = r3 + Null;
    /* Always use the ID for sink terminal 1 */
    ENDPOINT_ID aux_in_ep_id = base_op_get_ext_op_id(op_data) |
            STREAM_EP_EXT_SINK | VOL_CTRL_TTR_EVENT_TERMINAL_NUM;
842018a2:	ef fd f6 ff 	call (m) 0x4f4;
842018a6:	33 e2 
842018a8:	a0 f0 01 f2 	r0 = r0 OR 0xa001;
842018ac:	52 d8 
    opmgr_record_timing_trace_op_term_event(aux_in_ep_id, event_type, arg1, arg2);
842018ae:	45 08       	r3 = r6 + Null;
842018b0:	3c 00       	r2 = r5 + Null;
842018b2:	33 00       	r1 = r4 + Null;
842018b4:	01 f0 21 e2 	call (m) $_opmgr_record_timing_trace_op_term_event;

842018b8 <Lc_record_aux_ttr_event_2>:
}
842018b8:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842018ba:	d8 4c       	rts;

842018bc <Lc_ups_params_vc_1>:



static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
842018bc:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842018be:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842018c0:	ef fd f6 ff 	call (m) 0x4e6;
842018c4:	27 e1 
842018c6:	16 00       	r4 = r0 + Null;
static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data((OPERATOR_DATA*)instance_data);

    cpsSetParameterFromPsStore(&op_extra_data->parms_def,length,data,status);
842018c8:	e5 d5       	r3 = MHS[FP + -8];
842018ca:	fc d9       	r2 = M[FP + -4];
842018cc:	62 f0 b4 22 	r0 = r4 + 692;
842018d0:	3b 00       	r1 = r5 + Null;
842018d2:	ef fd f8 ff 	call (m) 0xa0a;
842018d6:	39 e9 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
842018d8:	41 20       	rMAC = Null + 1;
842018da:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    return TRUE;
842018de:	0a 00       	r0 = rMAC + Null;

842018e0 <Lc_ups_params_vc_2>:
}
842018e0:	f2 48       	popm <FP, r4, r5, rLink>;
842018e2:	d8 4c       	rts;

842018e4 <$_VOL_CTRL_GetDefaults>:
   0x7999999Au,			// LIMIT_ADAPTATION_RATIO
   0xFFD57A44u			// LIMIT_THRESHOLD_LOG
};

unsigned *VOL_CTRL_GetDefaults(unsigned capid){
	switch(capid){
842018e4:	20 f0 48 24 	Null = r0 - 72;
842018e8:	05 60       	if EQ jump (m) Lc_VOL_CTRL_GetDefaults_3;

842018ea <Lc_VOL_CTRL_GetDefaults_2>:
842018ea:	01 f0 20 f0 	Null = r0 - 16468;
842018ee:	54 24 
842018f0:	05 62       	if NE jump (m) Lc_VOL_CTRL_GetDefaults_4;

842018f2 <Lc_VOL_CTRL_GetDefaults_3>:
		case 0x0048: return defaults_vol_ctrlVOL_V2PLUS;
842018f2:	f8 ff 02 f0 	r0 = Null + -8388604;
842018f6:	04 40 
842018f8:	02 6e       	jump (m) Lc_VOL_CTRL_GetDefaults_5;

842018fa <Lc_VOL_CTRL_GetDefaults_4>:
		case 0x4054: return defaults_vol_ctrlVOL_V2PLUS;
	}
	return((unsigned *)0);
842018fa:	02 00       	r0 = Null + Null;

842018fc <Lc_VOL_CTRL_GetDefaults_5>:
842018fc:	d8 4c       	rts;

842018fe <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_vol_ctlr_cap_data;
842018fe:	07 f0 02 f0 	r0 = Null + 7340176;
84201902:	90 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84201904:	20 f0 f8 42 	Null = Null + 17144;

84201908 <$_vol_ctrl_update_aux_state>:
.CONST $vol_ctrl.axfp.period        4*ADDR_PER_WORD;  // r3
.MODULE $M.vol_ctrl_update_aux_state;
    .CODESEGMENT PM;

$_vol_ctrl_update_aux_state:
    pushm <r5,r7>;
84201908:	28 f0 40 e0 	pushm <r5, r7>;

    LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_aux_state.PATCH_ID_0, r7)

    // Check if any AUX to monitor
    r7 = r1;
8420190c:	19 09       	r7 = r1 + Null;
    if Z jump update_aux_state_abort;
8420190e:	b7 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_abort;

    r5 = r0;
84201910:	17 00       	r5 = r0 + Null;

    /* Setup Parameters Pointer */
    r1 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD +
               $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
84201912:	23 f0 94 21 	r1 = r0 + 404;
    /* Setup Aux Pointer */
    r0 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
84201916:	72 f0 6c 20 	r0 = r5 + 108;
    /* setup period */
    r3 = M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD];
8420191a:	25 89       	r3 = M[r2 + 16];
    /* Get number of words to process */
    r2 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
8420191c:	24 88       	r2 = M[r2 + 0];

    pushm <FP(=SP),r0,r1,r2,r3,r4,r6,r8,rLink>;
8420191e:	57 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r4, r6, r8, rLink>;

    r8 = NULL;
84201922:	02 09       	r8 = Null + Null;
    r6 = 1;
84201924:	08 71       	r6 = Null + 1;

84201926 <$M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next>:

    // r0: vol_ctrl_aux_channel_t *aux
    // r1: vol_ctrl_aux_params_t *aux_params

    // Get aux->state
    r4 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84201926:	56 88       	r4 = M[r0 + 4];
    // In aux timed playback mode we don't allow aux data
    // to be consumed until the right time.

    // Auxiliary timed playback is only for channel 0, skip ttp handling
    // if this isn't first aux channel.
    r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
84201928:	73 f0 6c 20 	r1 = r5 + 108;
    NULL = r1 - r0;
8420192c:	98 04       	Null = r1 - r0;
    if NZ jump aux_ttp_gate_control_done;
8420192e:	22 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // timed playback requires that aux ttp to have been enabled by the user and
    // also we have valid timestamp to honour the ttp request, check both below,
    // if any fails then no gate control.

    // see if TTP is enabled for this aux channel
    NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
84201930:	70 f0 c4 88 	Null = M[r5 + 784];
    if Z jump aux_ttp_gate_control_done;
84201934:	1f 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // also see if we have a valid timestamp to handle aux timed playback
    // if not as if aux ttp isn't enabled
    NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
84201936:	70 f0 cd 88 	Null = M[r5 + 820];
    if Z jump aux_ttp_gate_control_done;
8420193a:	1c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // time to open the gate. We open the gate when time passes TTP_GATE_TIME,
    // this is a bit before AUX_TTP time (default 10ms but user configurable) it will
    // give time to main channel for fading.
    // r1 = time stamp for first sample
    // r3 = ttp gate time
    r1 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
8420193c:	73 f0 cc 88 	r1 = M[r5 + 816];
    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GATE_TIME)];
84201940:	75 f0 c7 88 	r3 = M[r5 + 796];
    r3 = r1 - r3;
84201944:	5d 05       	r3 = r1 - r3;
    if POS jump check_aux_ttp_expiry;
84201946:	05 f0 97 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.check_aux_ttp_expiry;

    // gate time hasn't passed yet, AUX is expected to be
    // inactive, if for any reason it is in an active state
    // then we can't meet TTP deadline, just disable TTP playback.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
8420194a:	30 24       	Null = r4 - 0;
    if NZ jump disable_aux_ttp;
8420194c:	0f 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.disable_aux_ttp;
    // see if it is the time to open the gate
    // we open the gate if the gate time lies in
    // a sample within this chunk, i.e between
    // current timestamp and and next timestamp
    // timestamp ----gate_time --- (timestamp+period)
    rMAC = M[FP + $vol_ctrl.axfp.period]; // rMAC = period in 10us
8420194e:	21 d8       	rMAC = M[FP + 16];
    rMAC = rMAC * 10 (int);               // rMAC = period in us
84201950:	89 42       	rMAC = rMAC * 10 (int);
    NULL = r3 + rMAC;                     // rMAC > time left to gate?
84201952:	68 00       	Null = r3 + rMAC;
    if POS jump aux_ttp_gate_control_done;// if yes then open the gate
84201954:	05 f0 9f e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // keep the gate closed
    // it's not time to open the aux gate
    // don't allow anything to be consumed from aux
    M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = 0;
84201958:	d0 8e       	M[r0 + 12] = Null;
    jump aux_ttp_gate_control_done;
8420195a:	0c 6e       	jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

8420195c <$M.vol_ctrl_update_aux_state.check_aux_ttp_expiry>:

check_aux_ttp_expiry:
    // if expiry time has reached and we haven't yet started
    // playing the aux then no longer need to honour the timed
    // playback request, we can't meet the deadline.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
8420195c:	30 24       	Null = r4 - 0;
    if NZ jump aux_ttp_gate_control_done;
8420195e:	0a 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(EXPIRY_TIME)];
84201960:	75 f0 c6 88 	r3 = M[r5 + 792];
    NULL = r1 - r3;
84201964:	58 05       	Null = r1 - r3;
    if NEG jump aux_ttp_gate_control_done;
84201966:	04 f0 8d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

8420196a <$M.vol_ctrl_update_aux_state.disable_aux_ttp>:
    // Aux ttp has expired
disable_aux_ttp:
    // disabling aux timed playback
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = NULL;
8420196a:	70 f0 c4 8e 	M[r5 + 784] = Null;
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
8420196e:	70 f0 c8 8e 	M[r5 + 800] = Null;

84201972 <$M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done>:
aux_ttp_gate_control_done:
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
    // amount = aux_ptr->advance_buffer
    //        = aux_ptr->buffer ? cbuffer_calc_amount_data_in_words(aux_ptr->buffer) : 0
    r0 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD];
84201972:	d2 88       	r0 = M[r0 + 12];


    // Is Aux Data Present in sufficient quantity to mix?
    r1 = M[FP + $vol_ctrl.axfp.num_words];
84201974:	1b d8       	r1 = M[FP + 12];
    NULL = r1 - r0;
84201976:	98 04       	Null = r1 - r0;
    if GT jump update_aux_state_insufficient_data;
84201978:	50 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data;

8420197a <$M.vol_ctrl_update_aux_state.update_aux_state_sufficient_data>:

    update_aux_state_sufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
8420197a:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = volume_tc.num_words;
        M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD]=r1;
8420197c:	eb 8e       	M[r3 + 12] = r1;

        NULL = r4 - $volume_control_cap.AUX_STATE_IN_AUX;
8420197e:	b0 24       	Null = r4 - 2;
        if Z jump update_aux_state_done;
84201980:	6c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;
        /* Not in IN_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_START_AUX;
84201982:	70 24       	Null = r4 - 1;
        if Z jump update_aux_state_in_AUX_START;
84201984:	04 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START;
            /* Not in START_AUX state, enter START_AUX state
               Start count down.  Don't use data until in IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_START_AUX;
84201986:	43 20       	r1 = Null + 1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201988:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
8420198a:	a8 8e       	M[r3 + 8] = Null;

8420198c <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START>:
           // jump update_aux_do_not_use_data;
        update_aux_state_in_AUX_START:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
8420198c:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
8420198e:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.ATK_TC_FIELD];
84201990:	5b 88       	r1 = M[r1 + 4];
            rMAC = r0 * r1;
84201992:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
84201996:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r0 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
84201998:	aa 88       	r0 = M[r3 + 8];
            r2 = 1.0;
8420199a:	ff f7 f4 f7 	r2 = Null + 2147483647;
8420199e:	ff 7b 
            rMAC = rMAC + r0;
842019a0:	51 00       	rMAC = r0 + rMAC;
            if V rMAC = r2;
842019a2:	06 f4 01 c0 	if V rMAC = r2 + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
842019a6:	a9 8e       	M[r3 + 8] = rMAC;
            NULL = rMAC - r2;
842019a8:	08 05       	Null = rMAC - r2;
            if NZ jump update_aux_do_not_use_data;
842019aa:	56 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* auxiliary timed playback is only for channel 0, skip ttp handling
             * if this isn't first aux channel.
             */
            r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
842019ac:	73 f0 6c 20 	r1 = r5 + 108;
            NULL = r1 - r3;
842019b0:	58 05       	Null = r1 - r3;
            if NZ jump aux_ttp_start_done;
842019b2:	2d 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // time we start mixing aux into main channel. In ttp mode we
            // might need to delay it to make sure aux starts mixing at a time
            // as close as to requested playback time.

            // see if TTP is enabled at all for aux channel
            NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
842019b4:	70 f0 c4 88 	Null = M[r5 + 784];
            if Z jump aux_ttp_start_done;
842019b8:	2a 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // and we have valid timestamp
            NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
842019ba:	70 f0 cd 88 	Null = M[r5 + 820];
            if Z jump aux_ttp_start_done;
842019be:	27 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // r1 = aux requested ttp, this is the timestamp we want the aux to be mixed with main
            // r2 = timestamp, this is the timestamp for first sample of main
            r1 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(TIME_TO_PLAY)];
842019c0:	73 f0 c5 88 	r1 = M[r5 + 788];
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
842019c4:	74 f0 cc 88 	r2 = M[r5 + 816];
            r1 = r1 - r2;
842019c8:	1b 05       	r1 = r1 - r2;

            // because of the gate we expect to be very close to TTP time. If that
            // not the case, i.e. it's unexpectedly far in the future then something
            // should have gone wrong, to avoid stalling of mixing for long time ignore
            // TTP and let it go ahead with mixing.
            NULL = r1 - $vol_ctrl.MAX_EXTENDING_START_TRANSIENT_TIME_US;
842019ca:	01 f0 30 f3 	Null = r1 - 30000;
842019ce:	30 2d 
            if POS jump aux_ttp_start_done_without_ttp;
842019d0:	05 f0 b9 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;
            // Good news, we are very close to TTP time, lets work out how
            // many sample we are to TTP time
            // samples = time * fs
            // r1 = time*1000000, so we calculate it this way:
            // samples = (r1 / 2000) * (fs/500)
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.SAMPLE_RATE_FIELD];
842019d4:	74 f0 3b 88 	r2 = M[r5 + 236];
            r2 = r2 * (1/500.0)(frac);
842019d8:	04 f0 89 f1 	r2 = r2 * 0.0019999998621642589569091796875 (frac);
842019dc:	37 f4 54 c9 
            r2 = r2 * r1 (int)(sat);
842019e0:	00 f3 f4 c9 	r2 = r2 * r1 (int) (sat);
            r2 = r2 * (1.0/2000.0)(frac); // r2 = samples to ttp time
842019e4:	01 f0 62 f0 	r2 = r2 * 0.000500000081956386566162109375 (frac);
842019e8:	4e f4 54 c9 
            // negative r2 means that ttp was in a sample in the past
            // i.e. already exited the operator, this shall not happen
            // since we open the gate at right time, however in case that
            // happened continue without ttp.
            if NEG jump aux_ttp_start_done_without_ttp;
842019ec:	04 f0 9d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;

            // r2 = 0, means TTP is exactly at first sample,
            // lucky, go to IN_AUX state now and start mixing
            if Z jump aux_ttp_start_done;
842019f0:	0e 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // if TTP is for later than whole of this chunk then extend transient time
            rMAC = M[FP + $vol_ctrl.axfp.num_words];
842019f2:	19 d8       	rMAC = M[FP + 12];
            NULL = r2 - rMAC;
842019f4:	60 04       	Null = r2 - rMAC;
            if POS jump update_aux_do_not_use_data;
842019f6:	05 f0 e1 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

            // TTP lies somewhere within current chunk, we split the
            // current chunk, so only samples before TTP are consumed
            // from the main channel, so next time will be start of TTP
            rMAC = r5 + $volume_control_cap._vol_ctrl_data_struct.TC_FIELD;
842019fa:	71 f0 c8 22 	rMAC = r5 + 712;
            M[rMAC + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD] = r2;
842019fe:	0c 8e       	M[rMAC + 0] = r2;
            M[FP + $vol_ctrl.axfp.num_words] = r2;
84201a00:	1c de       	M[FP + 12] = r2;
            r1 = r1 * 10 (int);
84201a02:	9b 42       	r1 = r1 * 10 (int);
            M[FP + $vol_ctrl.axfp.period] = r1;
84201a04:	23 de       	M[FP + 16] = r1;
            jump update_aux_do_not_use_data;
84201a06:	28 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

84201a08 <$M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp>:
            // We are here since either ttp time passed or is quite into the future.
            // We aren't expected to come to this point if gate opened at right time.
            // We go to IN_AUX now and timed playback won't be honoured.
            // clearing TTP_ENABLED field but not stopping TTP generation if active,
            // this is to avoid unnecessary disturbance it timed playback.
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
84201a08:	70 f0 c4 8e 	M[r5 + 784] = Null;

84201a0c <$M.vol_ctrl_update_aux_state.aux_ttp_start_done>:
aux_ttp_start_done:
            // debug var only, just shows that started to mix aux, the flag shall be
            // cleared by the caller.
            r1 = 1;
84201a0c:	43 20       	r1 = Null + 1;
            M[r5 + $volume_control_cap._vol_ctrl_data_struct.DBG_AUX_MIXING_STARTED_FIELD] = r1;
84201a0e:	73 f0 d1 8e 	M[r5 + 836] = r1;
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* Entering IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_IN_AUX;
84201a12:	83 20       	r1 = Null + 2;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201a14:	6b 8e       	M[r3 + 4] = r1;
            jump update_aux_state_done;
84201a16:	21 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

84201a18 <$M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data>:

     update_aux_state_insufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
84201a18:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = amount;

        NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
84201a1a:	30 24       	Null = r4 - 0;
        if Z jump update_aux_do_not_use_data;
84201a1c:	1d 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
        /* Not in NO_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_END_AUX;
84201a1e:	f0 24       	Null = r4 - 3;
        if Z jump update_aux_state_in_AUX_END;
84201a20:	07 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END;
            /* Not in END_AUX state, enter END_AUX state
               Start count down.  Don't purge data until in NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_END_AUX;
84201a22:	c3 20       	r1 = Null + 3;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201a24:	6b 8e       	M[r3 + 4] = r1;
            r1 = 1.0;
84201a26:	ff f7 f3 f7 	r1 = Null + 2147483647;
84201a2a:	ff 7b 
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = r1;
84201a2c:	ab 8e       	M[r3 + 8] = r1;

84201a2e <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END>:
           // jump update_aux_do_not_use_data;
       update_aux_state_in_AUX_END:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
84201a2e:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201a30:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.DEC_TC_FIELD];
84201a32:	9b 88       	r1 = M[r1 + 8];
            rMAC = r0 * r1;
84201a34:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
84201a38:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r2 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
84201a3a:	ac 88       	r2 = M[r3 + 8];
            rMAC = r2 - rMAC;
84201a3c:	61 04       	rMAC = r2 - rMAC;
            if NEG rMAC=NULL;
84201a3e:	04 f0 01 c0 	if NEG rMAC = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
84201a42:	a9 8e       	M[r3 + 8] = rMAC;
            if GT jump update_aux_do_not_use_data;
84201a44:	09 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            // timed playback is only for one tone/prompt, once
            // finished disable aux timed playback
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
84201a46:	70 f0 c8 8e 	M[r5 + 800] = Null;
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
84201a4a:	70 f0 c4 8e 	M[r5 + 784] = Null;
#endif
            /* Entering NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_NO_AUX;
84201a4e:	03 00       	r1 = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201a50:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
84201a52:	a8 8e       	M[r3 + 8] = Null;
            jump update_aux_state_done;
84201a54:	02 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

84201a56 <$M.vol_ctrl_update_aux_state.update_aux_do_not_use_data>:

update_aux_do_not_use_data:
    M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = NULL;
84201a56:	e8 8e       	M[r3 + 12] = Null;

84201a58 <$M.vol_ctrl_update_aux_state.update_aux_state_done>:
update_aux_state_done:

    // Next aux channel
    r0 = M[FP + $vol_ctrl.axfp.aux_ptr];
84201a58:	0a d8       	r0 = M[FP + 4];

    /* Is NO_AUX */
    NULL = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84201a5a:	50 88       	Null = M[r0 + 4];
    if NZ r8 = r8 OR r6;
84201a5c:	81 fa 4a c8 	if NE r8 = r8 OR r6;
    r0 = r0 + ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
84201a60:	12 28       	r0 = r0 + 16;
    M[FP + $vol_ctrl.axfp.aux_ptr]=r0;
84201a62:	0a de       	M[FP + 4] = r0;

    r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201a64:	13 d8       	r1 = M[FP + 8];
    r1 = r1 + ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE*ADDR_PER_WORD);
84201a66:	1b 23       	r1 = r1 + 12;
    M[FP + $vol_ctrl.axfp.aparm_ptr]=r1;
84201a68:	13 de       	M[FP + 8] = r1;

    r6 = r6 LSHIFT 1;
84201a6a:	00 f8 d8 d8 	r6 = r6 LSHIFT 1;
    r7 = r7 LSHIFT -1;
84201a6e:	7f f9 d9 d8 	r7 = r7 LSHIFT -1;
    if NZ jump vol_ctrl_update_aux_state_next;
84201a72:	5a 63       	if NE jump (m) $M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next;

    /* Save overall state */
    M[r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD] = r8;
84201a74:	7a f0 b8 8e 	M[r5 + 736] = r8;

    popm <FP,r0,r1,r2,r3,r4,r6,r8,rLink>;
84201a78:	57 f2 6d e0 	popm <FP, r0, r1, r2, r3, r4, r6, r8, rLink>;

84201a7c <$M.vol_ctrl_update_aux_state.update_aux_state_abort>:

update_aux_state_abort:
    popm <r5,r7>;
84201a7c:	28 f0 60 e0 	popm <r5, r7>;
    rts;
84201a80:	d8 4c       	rts;

84201a82 <$_vol_ctrl_compute_time_constants>:
    .CODESEGMENT PM;

    .CONST POS_ONE_Q16_N   (1<<(DAWTH-16));  // 1.0 in Q16.8 (arch4: Q16.16)

$_vol_ctrl_compute_time_constants:
    pushm <r4,r5,r6,r7,rlink>;
84201a82:	b4 1c       	pushm <r4, r5, r6, r7, rLink>;
// r0:  unsigned sample_rate
// r1:  unsigned vol_tc  (r-1)
// r2:  vol_time_constants_t *lpvcs

    r3 = r1;
84201a84:	1d 00       	r3 = r1 + Null;
    r1 = M[r2+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84201a86:	23 88       	r1 = M[r2 + 0];

    // compute period in 100th of msec  (samples/sample_rate)*100,000
    rMAC = r1 * 3125 (int);
84201a88:	0c f0 35 f3 	rMAC = r1 * 3125 (int);
84201a8c:	91 d9 
    rMAC = rMAC LSHIFT (5-DAWTH) (56bit);
84201a8e:	72 f1 d1 d8 	rMAC = rMAC LSHIFT -27 (56bit);
    Div  = rMAC / r0;
84201a92:	91 4c       	Div = rMAC / r0;
    r4 = DivResult;
84201a94:	c6 4c       	r4 = DivResult;
    M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD] = r4;
84201a96:	26 8f       	M[r2 + 16] = r4;

    r4 = r4 ASHIFT (DAWTH-14);
84201a98:	09 f6 16 c9 	r4 = r4 ASHIFT 18;
    // compute volume update coeff: 11.5*n/fs (roughly 0.1dB/ms)
    r5 = r4 * 0.942071589546666;      // update coef in Q1.23 (arch4: Q1.31)
84201a9c:	89 f7 cd f5 	r5 = r4 * 0.942071589641273021697998046875 (SS);
84201aa0:	46 f6 d7 cc 
    // positive VOL_TC will increase the rate.
    // modified_coef ~= coef*r*(1+(r-1)*coef) (r = ramp factor)
    r1 = r3 + POS_ONE_Q16_N;
84201aa4:	04 f0 53 f0 	r1 = r3 + 65536;
84201aa8:	00 20 
    if NEG r1 = 0;          // safeguard
84201aaa:	04 f0 03 c0 	if NEG r1 = Null + Null;
    rMAC = r1 * r5;
84201aae:	7f f3 c1 cc 	rMAC = r1 * r5 (SS);
    r1 = rMAC ASHIFT 15;    // coef*r                in Q1.23 (arch4: Q1.31)
84201ab2:	07 f1 13 d9 	r1 = rMAC ASHIFT 15;
    rMAC = POS_ONE_Q16_N;
84201ab6:	81 f0 00 40 	rMAC = Null + 65536;
    rMAC = rMAC + r5 * r3;  // (1+(r-1)*coef)        in Q16.8 (arch4: Q16.16)
84201aba:	5f f7 c1 ca 	rMAC = rMAC + r5 * r3 (SS);
    rMAC = rMAC ASHIFT 8 (56bit);
84201abe:	c9 5d       	rMAC = rMAC ASHIFT 8 (56bit);
    rMAC = rMAC * r1;       // coef*r*(1+(r-1)*coef) in Q8.16 (arch4: Q8.24)
84201ac0:	3f f1 c1 cc 	rMAC = rMAC * r1 (SS);
    r1 = rMAC ASHIFT 7;     // convert modified_coef to Q1.23 (arch4: Q1.31)
84201ac4:	8b 5d       	r1 = rMAC ASHIFT 7;
    M[r2 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD] = r1;
84201ac6:	63 8e       	M[r2 + 4] = r1;


   // calculate release coeff(reaches 99% in 50ms)
   r0 = r4 * 0.6553593446;
84201ac8:	3e f5 d0 f2 	r0 = r4 * 0.65535934455692768096923828125 (SS);
84201acc:	a4 f6 d2 cc 
   r0 = r0 * (log(0.01)/0.05/log(2.0)/128.0/100.0)(frac);
84201ad0:	ea ff d5 fb 	r0 = r0 * -0.010381025262176990509033203125 (frac);
84201ad4:	a6 f2 52 c9 
   call $math.pow2_table;
84201ad8:	ff fd 95 f3 	call 0x74514;
84201adc:	3c e1 
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD] = r0;
84201ade:	a2 8e       	M[r2 + 8] = r0;

   // attack coeff, 5 times faster
   r1 = r0 * r0 (frac);
84201ae0:	2f f2 43 c9 	r1 = r0 * r0 (frac);
   r1 = r1 * r1 (frac);
84201ae4:	00 f3 73 c9 	r1 = r1 * r1 (frac);
   r1 = r0 * r1 (frac);
84201ae8:	3f f2 43 c9 	r1 = r0 * r1 (frac);
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD] = r1;
84201aec:	e3 8e       	M[r2 + 12] = r1;

   popm <r4,r5,r6,r7,rlink>;
84201aee:	b4 48       	popm <r4, r5, r6, r7, rLink>;
   rts;
84201af0:	d8 4c       	rts;
