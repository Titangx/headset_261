
/home/svc-audio-dspsw/kymera_builds/builds/2021/kymera_2103100121/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_anc_tuning.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_anc_tuning_processing>:
    .VAR gen_silence_data = 0;

// void anc_tuning_processing(ANC_TUNING_OP_DATA *p_ext_data,unsigned num_samples);
$_anc_tuning_processing:

   pushm <r7, r8, r9, rLink>; 
84200000:	00 2e 00 f1 	pushm <r7, r8, r9, rLink>;
   pushm <I0, I4>;        
84200004:	11 00 01 f1 	pushm <I0, I4>;
   pushm <M0, M1, M2, L0, L4>;
84200008:	00 57 01 f1 	pushm <M0, M1, M2, L0, L4>;
   pushm <B0,B4>;
8420000c:	00 14 02 f1 	pushm <B0, B4>;

   r9 = r0; // extra operator data
84200010:	0f 00 b2 00 	r9 = r0 + Null;
   r8 = r1; // samples available
84200014:	0f 00 a3 00 	r8 = r1 + Null;
// cycle through linked list of sinks
// call get read address
// cache results inside data obj (read ptr, base address, size)
//-----------------------------------------------------------------------------

   r7 = M[r9 + $anc_tuning_defs.anc_tuning_exop_struct.FIRST_SINK_FIELD];
84200018:	18 04 9b d1 	r7 = M[r9 + 1048];

8420001c <$M.anc_tuning_proc.anc_tuning_process_channels_next_sink>:
   anc_tuning_process_channels_next_sink:
        r0 = M[r7 + $anc_tuning_defs.anc_sink_struct.BUFFER_FIELD];
8420001c:	08 00 29 d1 	r0 = M[r7 + 8];
        call $cbuffer.get_read_address_and_size_and_start_address; 
84200020:	03 00 00 fd 	call (m) 0x3a27a;
84200024:	7b a2 f0 e1 
        M[r7 + $anc_tuning_defs.anc_sink_struct.READ_PTR_FIELD]     = r0;
84200028:	10 00 29 d5 	M[r7 + 16] = r0;
        M[r7 + $anc_tuning_defs.anc_sink_struct.BUFFER_SIZE_FIELD]  = r1;
8420002c:	14 00 39 d5 	M[r7 + 20] = r1;
        M[r7 + $anc_tuning_defs.anc_sink_struct.BUFFER_START_FIELD] = r2;
84200030:	0c 00 49 d5 	M[r7 + 12] = r2;
    r7 = M[r7 + $anc_tuning_defs.anc_sink_struct.NEXT_FIELD];
84200034:	00 00 99 d1 	r7 = M[r7 + 0];
    if NZ jump anc_tuning_process_channels_next_sink;
84200038:	f9 ff 10 dd 	if NE jump $M.anc_tuning_proc.anc_tuning_process_channels_next_sink;
// else
//      use dummy global variable for silence
// copy read to write
// update write address for sources
//-----------------------------------------------------------------------------
    r7 = M[r9 + $anc_tuning_defs.anc_tuning_exop_struct.FIRST_SOURCE_FIELD];
8420003c:	1c 04 9b d1 	r7 = M[r9 + 1052];

84200040 <$M.anc_tuning_proc.anc_tuning_process_channels_next_source>:
    anc_tuning_process_channels_next_source:
        r0 = M[r7 + $anc_tuning_defs.anc_source_struct.BUFFER_FIELD];
84200040:	08 00 29 d1 	r0 = M[r7 + 8];
        call $cbuffer.get_write_address_and_size_and_start_address;
84200044:	03 00 00 fd 	call (m) 0x3a2b0;
84200048:	b1 a2 f0 e1 
        I4 = r0;
8420004c:	2f 00 40 50 	I4 = Null + r0;
        L4 = r1;
84200050:	3f 00 e0 50 	L4 = Null + r1;
        push r2;
84200054:	00 00 40 f3 	push r2;
        pop B4;
84200058:	00 00 c6 f3 	pop B4;

        r1 = M[r7 + $anc_tuning_defs.anc_source_struct.SINK_FIELD];
8420005c:	0c 00 39 d1 	r1 = M[r7 + 12];
        if Z jump transfer_silence;
84200060:	07 00 00 dd 	if EQ jump $M.anc_tuning_proc.transfer_silence;
            r0 = M[r1 + $anc_tuning_defs.anc_sink_struct.READ_PTR_FIELD];
84200064:	10 00 23 d1 	r0 = M[r1 + 16];
            I0 = r0;
84200068:	2f 00 00 50 	I0 = Null + r0;
            r0 = M[r1 + $anc_tuning_defs.anc_sink_struct.BUFFER_SIZE_FIELD];
8420006c:	14 00 23 d1 	r0 = M[r1 + 20];
            L0 = r0;
84200070:	2f 00 c0 50 	L0 = Null + r0;
            r0 = M[r1 + $anc_tuning_defs.anc_sink_struct.BUFFER_START_FIELD];
84200074:	0c 00 23 d1 	r0 = M[r1 + 12];
            jump transfer_data;
84200078:	05 00 f0 dd 	jump $M.anc_tuning_proc.transfer_data;

8420007c <$M.anc_tuning_proc.transfer_silence>:
        transfer_silence:
            // Dummy Silence buffer
            r0 = &gen_silence_data;
8420007c:	70 00 00 fd 	r0 = Null + 7340192;
84200080:	a0 00 20 01 
            I0 = r0;
84200084:	2f 00 00 50 	I0 = Null + r0;
            L0 = MK1;
84200088:	04 00 c0 51 	L0 = Null + 4;

8420008c <$M.anc_tuning_proc.transfer_data>:
        transfer_data:
        
        r10 = r8-1;
8420008c:	3f 00 ca e4 	r10 = r8 - 1;
        push r0;
84200090:	00 00 20 f3 	push r0;
        pop B0;
84200094:	00 00 a6 f3 	pop B0;
        r0 = M[I0,MK1];    
84200098:	00 21 00 03 	Null = Null + Null, r0 = M[I0,4];
        r2 = M[r7 + $anc_tuning_defs.anc_source_struct.PEAK_FIELD];
8420009c:	14 00 49 d1 	r2 = M[r7 + 20];
        do copy_loop;
842000a0:	04 00 f0 e5 	do $M.anc_tuning_proc.copy_loop;
            r1 = ABS r0;
842000a4:	4f 00 32 e4 	r1 = ABS r0;
            r2 = MAX r1;
842000a8:	6f 00 43 e4 	r2 = MAX r1;
            r0=M[I0,MK1],  M[I4,MK1]=r0;
842000ac:	a1 21 00 03 	Null = Null + Null, r0 = M[I0,4], M[I4,4] = r0;

842000b0 <$M.anc_tuning_proc.copy_loop>:
        copy_loop:
        M[I4,MK1]=r0;    
842000b0:	a1 00 00 03 	Null = Null + Null, M[I4,4] = r0;
        M[r7 + $anc_tuning_defs.anc_source_struct.PEAK_FIELD]=r2;
842000b4:	14 00 49 d5 	M[r7 + 20] = r2;
        
        r0 = M[r7 + $anc_tuning_defs.anc_source_struct.BUFFER_FIELD];
842000b8:	08 00 29 d1 	r0 = M[r7 + 8];
        r1 = I4;
842000bc:	4f 00 30 44 	r1 = Null + I4;
        call $cbuffer.set_write_address;
842000c0:	03 00 00 fd 	call (m) 0x3a320;
842000c4:	21 a3 f0 e1 

    r7 = M[r7 + $anc_tuning_defs.anc_source_struct.NEXT_FIELD];
842000c8:	00 00 99 d1 	r7 = M[r7 + 0];
    if NZ jump anc_tuning_process_channels_next_source;
842000cc:	dd ff 10 dd 	if NE jump $M.anc_tuning_proc.anc_tuning_process_channels_next_source;
// setup buffer from cached values
// advance read ptr by amount
// update read address for sinks
//-----------------------------------------------------------------------------
   // r8 to octects
   Words2Addr(r8);
842000d0:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   M1 = r8;
842000d4:	af 00 90 50 	M1 = Null + r8;

   r7 = M[r9 + $anc_tuning_defs.anc_tuning_exop_struct.FIRST_SINK_FIELD];
842000d8:	18 04 9b d1 	r7 = M[r9 + 1048];

842000dc <$M.anc_tuning_proc.anc_tuning_process_channels_next_sink2>:
   anc_tuning_process_channels_next_sink2:
        r0 = M[r7 + $anc_tuning_defs.anc_sink_struct.READ_PTR_FIELD];
842000dc:	10 00 29 d1 	r0 = M[r7 + 16];
        I0 = r0;
842000e0:	2f 00 00 50 	I0 = Null + r0;
        r0 = M[r7 + $anc_tuning_defs.anc_sink_struct.BUFFER_SIZE_FIELD];
842000e4:	14 00 29 d1 	r0 = M[r7 + 20];
        L0 = r0;
842000e8:	2f 00 c0 50 	L0 = Null + r0;
        r0 = M[r7 + $anc_tuning_defs.anc_sink_struct.BUFFER_START_FIELD];
842000ec:	0c 00 29 d1 	r0 = M[r7 + 12];
        push r0;
842000f0:	00 00 20 f3 	push r0;
        pop B0;
842000f4:	00 00 a6 f3 	pop B0;
        // I0,L0,B0
        r0 = M[I0,M1];
842000f8:	00 21 00 02 	Null = Null + Null, r0 = M[I0,M1];
        r0 = M[r7 + $anc_tuning_defs.anc_sink_struct.BUFFER_FIELD];
842000fc:	08 00 29 d1 	r0 = M[r7 + 8];
        r1 = I0;
84200100:	0f 00 30 44 	r1 = Null + I0;
        call $cbuffer.set_read_address;
84200104:	03 00 00 fd 	call (m) 0x3a2e6;
84200108:	e7 a2 f0 e1 
    r7 = M[r7 + $anc_tuning_defs.anc_sink_struct.NEXT_FIELD];
8420010c:	00 00 99 d1 	r7 = M[r7 + 0];
    if NZ jump anc_tuning_process_channels_next_sink2;
84200110:	f3 ff 10 dd 	if NE jump $M.anc_tuning_proc.anc_tuning_process_channels_next_sink2;

   popm <B0,B4>;
84200114:	00 14 06 f1 	popm <B0, B4>;
   popm <M0, M1, M2, L0, L4>;
84200118:	00 57 05 f1 	popm <M0, M1, M2, L0, L4>;
   popm <I0, I4>; 
8420011c:	11 00 05 f1 	popm <I0, I4>;
   popm <r7, r8, r9, rLink>;          
84200120:	00 2e 04 f1 	popm <r7, r8, r9, rLink>;
   rts;
84200124:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

84200128 <$_anc_tuning_sched_info>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool anc_tuning_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200128:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420012a:	17 00       	r5 = r0 + Null;
8420012c:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
8420012e:	ff fd 01 f0 	call (m) 0x41c;
84200132:	2f e7 
    if (resp == NULL)
84200134:	10 04       	Null = r0 - Null;
84200136:	09 62       	if NE jump (m) Lc_anc_tuning_sched_info_3;

84200138 <Lc_anc_tuning_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200138:	03 f0 00 60 	r1 = Null + 4096;
8420013c:	34 00       	r2 = r4 + Null;
8420013e:	3a 00       	r0 = r5 + Null;
84200140:	ff fd 01 f0 	call (m) 0x4bc;
84200144:	3d eb 
84200146:	05 6e       	jump (m) Lc_anc_tuning_sched_info_4;

84200148 <Lc_anc_tuning_sched_info_3>:
    }
    *response_data = resp;
84200148:	32 ee       	M[r4 + Null] = r0;

    resp->block_size = ANC_TUNING_DEFAULT_BLOCK_SIZE;
8420014a:	41 20       	rMAC = Null + 1;
8420014c:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
8420014e:	0a 00       	r0 = rMAC + Null;

84200150 <Lc_anc_tuning_sched_info_4>:
}
84200150:	f2 48       	popm <FP, r4, r5, rLink>;
84200152:	d8 4c       	rts;

84200154 <$_anc_tuning_buffer_details>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool anc_tuning_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200154:	c8 1c       	pushm <FP(=SP), rLink>;
    /* tuning capability doesn't support inplace, metadata etc. */
    return base_op_buffer_details(op_data, message_data, response_id, response_data);
84200156:	ff fd 01 f0 	call (m) 0x37c;
8420015a:	27 e1 

8420015c <Lc_anc_tuning_buffer_details_2>:
}
8420015c:	c8 48       	popm <FP, rLink>;
8420015e:	d8 4c       	rts;

84200160 <$_anc_tuning_disconnect>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool anc_tuning_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200160:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200162:	16 00       	r4 = r0 + Null;
84200164:	18 09       	r6 = r1 + Null;
84200166:	2b 09       	r9 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
84200168:	ff fd 01 f0 	call (m) 0x4e6;
8420016c:	3f eb 
8420016e:	17 00       	r5 = r0 + Null;
 * response
 */
bool anc_tuning_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data(op_data);
    unsigned  terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
84200170:	8a f0 00 e8 	r8 = M[r6 + Null];
    unsigned  terminal_num = terminal_id & TERMINAL_NUM_MASK;
84200174:	a8 f0 3f 00 	r6 = r8 AND 0x3f;
    unsigned  terminal_mask;

   if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200178:	03 00       	r1 = Null + Null;
8420017a:	5c 08       	r2 = r9 + Null;
8420017c:	32 00       	r0 = r4 + Null;
8420017e:	ff fd 01 f0 	call (m) 0x4bc;
84200182:	3f e9 
84200184:	10 04       	Null = r0 - Null;
84200186:	03 62       	if NE jump (m) Lc_anc_tuning_disconnect_3;

84200188 <Lc_anc_tuning_disconnect_2>:
   {
        return FALSE;
84200188:	02 00       	r0 = Null + Null;
8420018a:	52 6e       	jump (m) Lc_anc_tuning_disconnect_13;

8420018c <Lc_anc_tuning_disconnect_3>:
   }

    terminal_mask = ~(1<<terminal_num);
8420018c:	41 08       	rMAC = r6 + Null;
8420018e:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200192:	ff f2 59 d6 	r7 = -1 - r0;

    if(terminal_id & TERMINAL_SINK_MASK)
84200196:	40 f0 a1 f0 	rMAC = r8 AND 0x800000;
8420019a:	00 00 
8420019c:	24 60       	if EQ jump (m) Lc_anc_tuning_disconnect_8;

8420019e <Lc_anc_tuning_disconnect_4>:
    {
       if(terminal_num>=ANC_TUNING_MAX_SINKS)
8420019e:	80 f0 08 24 	Null = r6 - 8;
842001a2:	07 64       	if NC jump (m) Lc_anc_tuning_disconnect_6;

842001a4 <Lc_anc_tuning_disconnect_5>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
842001a4:	01 f0 00 60 	rMAC = Null + 4096;
842001a8:	b2 f0 00 e8 	r0 = M[r9 + Null];
842001ac:	51 8e       	M[r0 + 4] = rMAC;
842001ae:	3f 6e       	jump (m) Lc_anc_tuning_disconnect_12;

842001b0 <Lc_anc_tuning_disconnect_6>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       }

       if(p_ext_data->sinks[terminal_num].buffer==NULL)
842001b0:	0c f8 92 c9 	r0 = r6 * 24 (int);
842001b4:	39 00       	rMAC = r5 + Null;
842001b6:	51 00       	rMAC = r0 + rMAC;
842001b8:	08 09       	r6 = rMAC + Null;
842001ba:	81 f0 c0 88 	rMAC = M[r6 + 768];
842001be:	f3 61       	if EQ jump (m) Lc_anc_tuning_disconnect_5;

842001c0 <Lc_anc_tuning_disconnect_7>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       }
       opmgr_op_suspend_processing(op_data);
842001c0:	32 00       	r0 = r4 + Null;
842001c2:	ff fd 2a f0 	call (m) 0x570c;
842001c6:	2b ea 
       p_ext_data->sinks[terminal_num].buffer = NULL;
842001c8:	80 f0 c0 8e 	M[r6 + 768] = Null;
       p_ext_data->sinks[terminal_num].ep_handle = NULL;
842001cc:	80 f0 bf 8e 	M[r6 + 764] = Null;
       p_ext_data->connect_change       = TRUE;
842001d0:	41 20       	rMAC = Null + 1;
842001d2:	71 f0 0d 8f 	M[r5 + 1076] = rMAC;
       p_ext_data->connected_sinks &= terminal_mask;
842001d6:	71 f0 08 89 	rMAC = M[r5 + 1056];
842001da:	00 f9 31 c8 	rMAC = rMAC AND r7;
842001de:	71 f0 08 8f 	M[r5 + 1056] = rMAC;
842001e2:	1e 6e       	jump (m) Lc_anc_tuning_disconnect_11;

842001e4 <Lc_anc_tuning_disconnect_8>:
       opmgr_op_resume_processing(op_data);
    }

    else
    {
       if(terminal_num>=ANC_TUNING_MAX_SOURCES)
842001e4:	80 f0 04 24 	Null = r6 - 4;
842001e8:	f2 ff bd ef 	if C jump (m) Lc_anc_tuning_disconnect_5;

842001ec <Lc_anc_tuning_disconnect_9>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       }
       if(p_ext_data->sources[terminal_num].buffer==NULL)
842001ec:	0c f8 92 c9 	r0 = r6 * 24 (int);
842001f0:	39 00       	rMAC = r5 + Null;
842001f2:	51 00       	rMAC = r0 + rMAC;
842001f4:	08 09       	r6 = rMAC + Null;
842001f6:	81 f0 f0 88 	rMAC = M[r6 + 960];
842001fa:	d5 61       	if EQ jump (m) Lc_anc_tuning_disconnect_5;

842001fc <Lc_anc_tuning_disconnect_10>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       }
       opmgr_op_suspend_processing(op_data);
842001fc:	32 00       	r0 = r4 + Null;
842001fe:	ff fd 2a f0 	call (m) 0x570c;
84200202:	2f e8 
       p_ext_data->sources[terminal_num].buffer = NULL;
84200204:	80 f0 f0 8e 	M[r6 + 960] = Null;
       p_ext_data->sources[terminal_num].ep_handle = NULL;
84200208:	80 f0 ef 8e 	M[r6 + 956] = Null;
       p_ext_data->connect_change       = TRUE;
8420020c:	41 20       	rMAC = Null + 1;
8420020e:	71 f0 0d 8f 	M[r5 + 1076] = rMAC;
       p_ext_data->connected_sources &= terminal_mask;
84200212:	71 f0 09 89 	rMAC = M[r5 + 1060];
84200216:	00 f9 31 c8 	rMAC = rMAC AND r7;
8420021a:	71 f0 09 8f 	M[r5 + 1060] = rMAC;

8420021e <Lc_anc_tuning_disconnect_11>:
       opmgr_op_suspend_processing(op_data);
       p_ext_data->sinks[terminal_num].buffer = NULL;
       p_ext_data->sinks[terminal_num].ep_handle = NULL;
       p_ext_data->connect_change       = TRUE;
       p_ext_data->connected_sinks &= terminal_mask;
       opmgr_op_resume_processing(op_data);
8420021e:	32 00       	r0 = r4 + Null;
84200220:	ff fd 2a f0 	call (m) 0x573a;
84200224:	3b e8 
       p_ext_data->connected_sources &= terminal_mask;
       opmgr_op_resume_processing(op_data);

    }

    anc_tuning_update_processing(op_data);
84200226:	32 00       	r0 = r4 + Null;
84200228:	02 f0 27 e8 	call (m) $_anc_tuning_update_processing;

8420022c <Lc_anc_tuning_disconnect_12>:
    if(terminal_id & TERMINAL_SINK_MASK)
    {
       if(terminal_num>=ANC_TUNING_MAX_SINKS)
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
8420022c:	42 20       	r0 = Null + 1;

8420022e <Lc_anc_tuning_disconnect_13>:
    }

    anc_tuning_update_processing(op_data);
    return TRUE;

}
8420022e:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200230:	d8 4c       	rts;

84200232 <$_anc_tuning_create>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool anc_tuning_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200232:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200234:	10 09       	r6 = r0 + Null;
84200236:	19 09       	r7 = r1 + Null;
84200238:	27 00       	r5 = r2 + Null;
8420023a:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
8420023c:	ff fd 01 f0 	call (m) 0x4e6;
84200240:	2b e5 
84200242:	16 00       	r4 = r0 + Null;
{
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data(op_data);

    /* Call base_op create initializing operator to NOT_RUNNING state, 
       It also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
84200244:	55 08       	r3 = r8 + Null;
84200246:	3c 00       	r2 = r5 + Null;
84200248:	4b 08       	r1 = r7 + Null;
8420024a:	42 08       	r0 = r6 + Null;
8420024c:	ff fd 00 f0 	call (m) 0x35a;
84200250:	2f e8 
84200252:	10 04       	Null = r0 - Null;
84200254:	03 62       	if NE jump (m) Lc_anc_tuning_create_3;

84200256 <Lc_anc_tuning_create_2>:
    {
        return FALSE;
84200256:	02 00       	r0 = Null + Null;
84200258:	31 6e       	jump (m) Lc_anc_tuning_create_7;

8420025a <Lc_anc_tuning_create_3>:
    }

    /* Initialize extended data for operator.  Assume intialized to zero */
    p_ext_data->ReInitFlag = 1;
8420025a:	41 20       	rMAC = Null + 1;
8420025c:	61 f0 bd 8e 	M[r4 + 756] = rMAC;
    p_ext_data->is_stereo = FALSE;
84200260:	60 f0 0a 8f 	M[r4 + 1064] = Null;
    p_ext_data->is_two_mic = FALSE;
84200264:	60 f0 0b 8f 	M[r4 + 1068] = Null;
    p_ext_data->is_parallel_anc = FALSE;
84200268:	60 f0 0c 8f 	M[r4 + 1072] = Null;

    /* default sink to source mapping suitable for a plant (or S-path) recording */
    p_ext_data->sources[ANC_TUNING_SOURCE_USB_LEFT].sink_index = ANC_TUNING_SINK_FBMON_LEFT; 
8420026c:	82 20       	r0 = Null + 2;
8420026e:	62 f0 f2 8e 	M[r4 + 968] = r0;
    p_ext_data->sources[ANC_TUNING_SOURCE_USB_RIGHT].sink_index = ANC_TUNING_SINK_FBMON_RIGHT; 
84200272:	c2 20       	r0 = Null + 3;
84200274:	62 f0 f8 8e 	M[r4 + 992] = r0;
    p_ext_data->sources[ANC_TUNING_SOURCE_DAC_LEFT].sink_index = ANC_TUNING_SINK_USB_LEFT;
84200278:	60 f0 fe 8e 	M[r4 + 1016] = Null;
    p_ext_data->sources[ANC_TUNING_SOURCE_DAC_RIGHT].sink_index = ANC_TUNING_SINK_USB_RIGHT;
8420027c:	61 f0 04 8f 	M[r4 + 1040] = rMAC;
    p_ext_data->fb_mon[0] = 1; /* Use FB signal from FB Mon mux */
84200280:	61 f0 16 8f 	M[r4 + 1112] = rMAC;
    p_ext_data->fb_mon[1] = 0; /* Use FFa signal from FB Mon mux */
84200284:	60 f0 17 8f 	M[r4 + 1116] = Null;

    if(!cpsInitParameters(&p_ext_data->params_def,ANC_TUNING_GetDefaults(ANC_TUNING_CAP_ID),(unsigned*)&p_ext_data->anc_tuning_cap_params,sizeof(ANC_TUNING_PARAMETERS)))
84200288:	22 f0 82 40 	r0 = Null + 16514;
8420028c:	05 f0 33 e4 	call (m) $_ANC_TUNING_GetDefaults;
84200290:	05 f0 e0 42 	r3 = Null + 736;
84200294:	34 29       	r2 = r4 + 20;
84200296:	13 00       	r1 = r0 + Null;
84200298:	32 00       	r0 = r4 + Null;
8420029a:	ff fd 02 f0 	call (m) 0x742;
8420029e:	29 e5 
842002a0:	10 04       	Null = r0 - Null;
842002a2:	07 62       	if NE jump (m) Lc_anc_tuning_create_5;

842002a4 <Lc_anc_tuning_create_4>:
842002a4:	01 f0 00 60 	rMAC = Null + 4096;
842002a8:	a2 f0 00 e8 	r0 = M[r8 + Null];
842002ac:	51 8e       	M[r0 + 4] = rMAC;
842002ae:	05 6e       	jump (m) Lc_anc_tuning_create_6;

842002b0 <Lc_anc_tuning_create_5>:
       base_op_change_response_status(response_data, STATUS_CMD_FAILED);
       return TRUE;
    }

    /* get licenses */
    anc_tuning_enable_wrapper(0,0);
842002b0:	03 00       	r1 = Null + Null;
842002b2:	02 00       	r0 = Null + Null;
842002b4:	05 f0 21 e1 	call (m) $_anc_tuning_enable_wrapper;

842002b8 <Lc_anc_tuning_create_6>:
    p_ext_data->fb_mon[1] = 0; /* Use FFa signal from FB Mon mux */

    if(!cpsInitParameters(&p_ext_data->params_def,ANC_TUNING_GetDefaults(ANC_TUNING_CAP_ID),(unsigned*)&p_ext_data->anc_tuning_cap_params,sizeof(ANC_TUNING_PARAMETERS)))
    {
       base_op_change_response_status(response_data, STATUS_CMD_FAILED);
       return TRUE;
842002b8:	42 20       	r0 = Null + 1;

842002ba <Lc_anc_tuning_create_7>:

    /* get licenses */
    anc_tuning_enable_wrapper(0,0);

    return TRUE;
}
842002ba:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842002bc:	d8 4c       	rts;

842002be <$_anc_tuning_connect>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool anc_tuning_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842002be:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842002c0:	16 00       	r4 = r0 + Null;
842002c2:	1a 09       	r8 = r1 + Null;
842002c4:	2b 09       	r9 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
842002c6:	ff fd 01 f0 	call (m) 0x4e6;
842002ca:	21 e1 
842002cc:	11 09       	r7 = r0 + Null;
 * response
 */
bool anc_tuning_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data); 
842002ce:	a8 f0 00 e8 	r6 = M[r8 + Null];
    unsigned  terminal_num = terminal_id & TERMINAL_NUM_MASK;
842002d2:	87 f0 3f 00 	r5 = r6 AND 0x3f;
    unsigned  terminal_mask;
    ENDPOINT *ep;
    tCbuffer* buffer = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
842002d6:	a1 f0 01 88 	rMAC = M[r8 + 4];
842002da:	41 de       	M[FP + 32] = rMAC;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842002dc:	03 00       	r1 = Null + Null;
842002de:	5c 08       	r2 = r9 + Null;
842002e0:	32 00       	r0 = r4 + Null;
842002e2:	ff fd 00 f0 	call (m) 0x4bc;
842002e6:	3b ee 
842002e8:	10 04       	Null = r0 - Null;
842002ea:	03 62       	if NE jump (m) Lc_anc_tuning_connect_3;

842002ec <Lc_anc_tuning_connect_2>:
    {
        return FALSE;
842002ec:	02 00       	r0 = Null + Null;
842002ee:	5a 6e       	jump (m) Lc_anc_tuning_connect_13;

842002f0 <Lc_anc_tuning_connect_3>:
    }

    terminal_mask = (1<<terminal_num);
842002f0:	39 00       	rMAC = r5 + Null;
842002f2:	00 f1 9a de 	r8 = 0x1 LSHIFT rMAC;

    if(terminal_id & TERMINAL_SINK_MASK)
842002f6:	40 f0 81 f0 	rMAC = r6 AND 0x800000;
842002fa:	00 00 
842002fc:	29 60       	if EQ jump (m) Lc_anc_tuning_connect_8;

842002fe <Lc_anc_tuning_connect_4>:
    {
       if(terminal_num>=ANC_TUNING_MAX_SINKS)
842002fe:	38 26       	Null = r5 - 8;
84200300:	07 64       	if NC jump (m) Lc_anc_tuning_connect_6;

84200302 <Lc_anc_tuning_connect_5>:
84200302:	01 f0 00 60 	rMAC = Null + 4096;
84200306:	b2 f0 00 e8 	r0 = M[r9 + Null];
8420030a:	51 8e       	M[r0 + 4] = rMAC;
8420030c:	4a 6e       	jump (m) Lc_anc_tuning_connect_12;

8420030e <Lc_anc_tuning_connect_6>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       }
     
       if(p_ext_data->sinks[terminal_num].buffer!=NULL)
8420030e:	3a 46       	r0 = r5 * 24 (int);
84200310:	49 08       	rMAC = r7 + Null;
84200312:	51 00       	rMAC = r0 + rMAC;
84200314:	0f 00       	r5 = rMAC + Null;
84200316:	71 f0 c0 88 	rMAC = M[r5 + 768];
8420031a:	f4 63       	if NE jump (m) Lc_anc_tuning_connect_5;

8420031c <Lc_anc_tuning_connect_7>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       }      

       ep = (ENDPOINT*) opmgr_override_get_endpoint(op_data, terminal_id);
8420031c:	43 08       	r1 = r6 + Null;
8420031e:	32 00       	r0 = r4 + Null;
84200320:	ff fd 28 f0 	call (m) 0x546c;
84200324:	2d ea 
84200326:	10 09       	r6 = r0 + Null;

       opmgr_op_suspend_processing(op_data);
84200328:	32 00       	r0 = r4 + Null;
8420032a:	ff fd 29 f0 	call (m) 0x570c;
8420032e:	23 ef 
       p_ext_data->sinks[terminal_num].buffer = buffer;
84200330:	41 d8       	rMAC = M[FP + 32];
84200332:	71 f0 c0 8e 	M[r5 + 768] = rMAC;
       p_ext_data->sinks[terminal_num].ep_handle = ep;
84200336:	78 f0 bf 8e 	M[r5 + 764] = r6;
       p_ext_data->connect_change     = TRUE;
8420033a:	41 20       	rMAC = Null + 1;
8420033c:	91 f0 0d 8f 	M[r7 + 1076] = rMAC;
       p_ext_data->connected_sinks |= terminal_mask;
84200340:	91 f0 08 89 	rMAC = M[r7 + 1056];
84200344:	00 fa 71 c8 	rMAC = rMAC OR r8;
84200348:	91 f0 08 8f 	M[r7 + 1056] = rMAC;
8420034c:	23 6e       	jump (m) Lc_anc_tuning_connect_11;

8420034e <Lc_anc_tuning_connect_8>:
       opmgr_op_resume_processing(op_data);
    }
    else
    {
       if(terminal_num>=ANC_TUNING_MAX_SOURCES)
8420034e:	38 25       	Null = r5 - 4;
84200350:	f2 ff b3 ef 	if C jump (m) Lc_anc_tuning_connect_5;

84200354 <Lc_anc_tuning_connect_9>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       }    
       if(p_ext_data->sources[terminal_num].buffer!=NULL)
84200354:	3a 46       	r0 = r5 * 24 (int);
84200356:	49 08       	rMAC = r7 + Null;
84200358:	51 00       	rMAC = r0 + rMAC;
8420035a:	0f 00       	r5 = rMAC + Null;
8420035c:	71 f0 f0 88 	rMAC = M[r5 + 960];
84200360:	d1 63       	if NE jump (m) Lc_anc_tuning_connect_5;

84200362 <Lc_anc_tuning_connect_10>:
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
       } 

       ep = (ENDPOINT*) opmgr_override_get_endpoint(op_data, terminal_id);
84200362:	43 08       	r1 = r6 + Null;
84200364:	32 00       	r0 = r4 + Null;
84200366:	ff fd 28 f0 	call (m) 0x546c;
8420036a:	27 e8 
8420036c:	10 09       	r6 = r0 + Null;

       opmgr_op_suspend_processing(op_data);
8420036e:	32 00       	r0 = r4 + Null;
84200370:	ff fd 29 f0 	call (m) 0x570c;
84200374:	3d ec 
       p_ext_data->sources[terminal_num].buffer = buffer;
84200376:	41 d8       	rMAC = M[FP + 32];
84200378:	71 f0 f0 8e 	M[r5 + 960] = rMAC;
       p_ext_data->sources[terminal_num].ep_handle = ep;
8420037c:	78 f0 ef 8e 	M[r5 + 956] = r6;
       p_ext_data->connect_change       = TRUE;
84200380:	41 20       	rMAC = Null + 1;
84200382:	91 f0 0d 8f 	M[r7 + 1076] = rMAC;
       p_ext_data->connected_sources |= terminal_mask;
84200386:	91 f0 09 89 	rMAC = M[r7 + 1060];
8420038a:	00 fa 71 c8 	rMAC = rMAC OR r8;
8420038e:	91 f0 09 8f 	M[r7 + 1060] = rMAC;

84200392 <Lc_anc_tuning_connect_11>:
       opmgr_op_suspend_processing(op_data);
       p_ext_data->sinks[terminal_num].buffer = buffer;
       p_ext_data->sinks[terminal_num].ep_handle = ep;
       p_ext_data->connect_change     = TRUE;
       p_ext_data->connected_sinks |= terminal_mask;
       opmgr_op_resume_processing(op_data);
84200392:	32 00       	r0 = r4 + Null;
84200394:	ff fd 29 f0 	call (m) 0x573a;
84200398:	27 ed 
       p_ext_data->connect_change       = TRUE;
       p_ext_data->connected_sources |= terminal_mask;
       opmgr_op_resume_processing(op_data);
    }

    anc_tuning_update_processing(op_data);
8420039a:	32 00       	r0 = r4 + Null;
8420039c:	01 f0 33 ec 	call (m) $_anc_tuning_update_processing;

842003a0 <Lc_anc_tuning_connect_12>:
    if(terminal_id & TERMINAL_SINK_MASK)
    {
       if(terminal_num>=ANC_TUNING_MAX_SINKS)
       {
           base_op_change_response_status(response_data, STATUS_CMD_FAILED);
           return TRUE;
842003a0:	42 20       	r0 = Null + 1;

842003a2 <Lc_anc_tuning_connect_13>:
    }

    anc_tuning_update_processing(op_data);
    return TRUE;

}
842003a2:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842003a4:	d8 4c       	rts;

842003a6 <$_anc_tuning_destroy>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool anc_tuning_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842003a6:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842003a8:	16 00       	r4 = r0 + Null;
842003aa:	19 09       	r7 = r1 + Null;
842003ac:	27 00       	r5 = r2 + Null;
842003ae:	28 09       	r6 = r3 + Null;
    /* check that we are not trying to destroy a running operator */
    if (opmgr_op_is_running(op_data))
842003b0:	ff fd 29 f0 	call (m) 0x5700;
842003b4:	31 ea 
842003b6:	10 04       	Null = r0 - Null;
842003b8:	0b 60       	if EQ jump (m) Lc_anc_tuning_destroy_3;

842003ba <Lc_anc_tuning_destroy_2>:
    {
        *response_id = OPCMD_DESTROY;
842003ba:	41 20       	rMAC = Null + 1;
842003bc:	39 ee       	M[r5 + Null] = rMAC;

        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842003be:	03 f0 00 60 	r1 = Null + 4096;
842003c2:	44 08       	r2 = r6 + Null;
842003c4:	32 00       	r0 = r4 + Null;
842003c6:	ff fd 00 f0 	call (m) 0x4bc;
842003ca:	37 e7 
842003cc:	08 6e       	jump (m) Lc_anc_tuning_destroy_4;

842003ce <Lc_anc_tuning_destroy_3>:
    }
    else
    {   /* Nothing to clean up, all allocations from framework */
        /* call base_op destroy that creates and fills response message, too */
        return base_op_destroy(op_data, message_data, response_id, response_data);
842003ce:	45 08       	r3 = r6 + Null;
842003d0:	3c 00       	r2 = r5 + Null;
842003d2:	4b 08       	r1 = r7 + Null;
842003d4:	32 00       	r0 = r4 + Null;
842003d6:	ef fd ff ff 	call (m) 0x370;
842003da:	3b ec 

842003dc <Lc_anc_tuning_destroy_4>:
    }
 }
842003dc:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842003de:	d8 4c       	rts;

842003e0 <$_anc_tuning_opmsg_cps_set_control>:

/* *********************Operator Message Handle functions ******************************** */

/* OBPM controls for sink to source mapping */
bool anc_tuning_opmsg_cps_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003e0:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842003e2:	13 09       	r9 = r0 + Null;
842003e4:	18 09       	r6 = r1 + Null;
842003e6:	27 00       	r5 = r2 + Null;
842003e8:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
842003ea:	ff fd 00 f0 	call (m) 0x4e6;
842003ee:	3d e7 
842003f0:	16 00       	r4 = r0 + Null;
bool anc_tuning_opmsg_cps_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data(op_data);
    unsigned            i,num_controls,cntrl_value; 
    CPS_CONTROL_SOURCE  cntrl_src;
    OPMSG_RESULT_STATES result = OPMSG_RESULT_STATES_NORMAL_STATE;
842003f2:	01 09       	r7 = Null + Null;

    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
842003f4:	05 12       	r3 = FP + 32;
842003f6:	54 08       	r2 = r8 + Null;
842003f8:	3b 00       	r1 = r5 + Null;
842003fa:	42 08       	r0 = r6 + Null;
842003fc:	ff fd 03 f0 	call (m) 0xab2;
84200400:	37 e5 
84200402:	10 04       	Null = r0 - Null;
84200404:	03 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_set_control_3;

84200406 <Lc_anc_tuning_opmsg_cps_set_control_2>:
    {
       return FALSE;
84200406:	02 00       	r0 = Null + Null;
84200408:	3f 6e       	jump (m) Lc_anc_tuning_opmsg_cps_set_control_20;

8420040a <Lc_anc_tuning_opmsg_cps_set_control_3>:
    }

    for(i=0;i<num_controls;i++)
8420040a:	07 00       	r5 = Null + Null;

8420040c <Lc_anc_tuning_opmsg_cps_set_control_4>:
8420040c:	41 d8       	rMAC = M[FP + 32];
8420040e:	78 04       	Null = r5 - rMAC;
84200410:	02 f0 df e0 	if C jump (m) Lc_anc_tuning_opmsg_cps_set_control_19;

84200414 <Lc_anc_tuning_opmsg_cps_set_control_5>:
    {
        unsigned  cntrl_id=cps_control_get(message_data,i,&cntrl_value,&cntrl_src);
84200414:	85 12       	r3 = FP + 40;
84200416:	44 12       	r2 = FP + 36;
84200418:	3b 00       	r1 = r5 + Null;
8420041a:	42 08       	r0 = r6 + Null;
8420041c:	ff fd 03 f0 	call (m) 0xb00;
84200420:	25 e7 
        
        if(cntrl_id== ANC_TUNING_CONSTANT_SOURCE_ROUTES1_CTRL)
84200422:	90 25       	Null = r0 - 6;
84200424:	06 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_set_control_8;

84200426 <Lc_anc_tuning_opmsg_cps_set_control_6>:
        {
            p_ext_data->sources[ANC_TUNING_SOURCE_USB_LEFT].sink_index = cntrl_value;
84200426:	49 d8       	rMAC = M[FP + 36];
84200428:	61 f0 f2 8e 	M[r4 + 968] = rMAC;

8420042c <Lc_anc_tuning_opmsg_cps_set_control_7>:
    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
    {
       return FALSE;
    }

    for(i=0;i<num_controls;i++)
8420042c:	7f 20       	r5 = r5 + 1;
8420042e:	ef 6f       	jump (m) Lc_anc_tuning_opmsg_cps_set_control_4;

84200430 <Lc_anc_tuning_opmsg_cps_set_control_8>:
        
        if(cntrl_id== ANC_TUNING_CONSTANT_SOURCE_ROUTES1_CTRL)
        {
            p_ext_data->sources[ANC_TUNING_SOURCE_USB_LEFT].sink_index = cntrl_value;
        }
        else if(cntrl_id== ANC_TUNING_CONSTANT_SOURCE_ROUTES2_CTRL)
84200430:	d0 25       	Null = r0 - 7;
84200432:	05 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_set_control_10;

84200434 <Lc_anc_tuning_opmsg_cps_set_control_9>:
        {
            p_ext_data->sources[ANC_TUNING_SOURCE_USB_RIGHT].sink_index = cntrl_value;
84200434:	49 d8       	rMAC = M[FP + 36];
84200436:	61 f0 f8 8e 	M[r4 + 992] = rMAC;
8420043a:	f9 6f       	jump (m) Lc_anc_tuning_opmsg_cps_set_control_7;

8420043c <Lc_anc_tuning_opmsg_cps_set_control_10>:
        }
        else if(cntrl_id== ANC_TUNING_CONSTANT_SOURCE_ROUTES3_CTRL)
8420043c:	10 26       	Null = r0 - 8;
8420043e:	05 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_set_control_12;

84200440 <Lc_anc_tuning_opmsg_cps_set_control_11>:
        {
            p_ext_data->sources[ANC_TUNING_SOURCE_DAC_LEFT].sink_index = cntrl_value;
84200440:	49 d8       	rMAC = M[FP + 36];
84200442:	61 f0 fe 8e 	M[r4 + 1016] = rMAC;
84200446:	f3 6f       	jump (m) Lc_anc_tuning_opmsg_cps_set_control_7;

84200448 <Lc_anc_tuning_opmsg_cps_set_control_12>:
        }
        else if(cntrl_id== ANC_TUNING_CONSTANT_SOURCE_ROUTES4_CTRL)
84200448:	50 26       	Null = r0 - 9;
8420044a:	05 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_set_control_14;

8420044c <Lc_anc_tuning_opmsg_cps_set_control_13>:
        {
            p_ext_data->sources[ANC_TUNING_SOURCE_DAC_RIGHT].sink_index = cntrl_value;
8420044c:	49 d8       	rMAC = M[FP + 36];
8420044e:	61 f0 04 8f 	M[r4 + 1040] = rMAC;
84200452:	ed 6f       	jump (m) Lc_anc_tuning_opmsg_cps_set_control_7;

84200454 <Lc_anc_tuning_opmsg_cps_set_control_14>:
        }
        else if(cntrl_id== ANC_TUNING_CONSTANT_INST_FLAGS0_CTRL)
84200454:	90 26       	Null = r0 - 10;
84200456:	05 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_set_control_16;

84200458 <Lc_anc_tuning_opmsg_cps_set_control_15>:
        {
            p_ext_data->fb_mon[0] = cntrl_value;
84200458:	49 d8       	rMAC = M[FP + 36];
8420045a:	61 f0 16 8f 	M[r4 + 1112] = rMAC;
8420045e:	e7 6f       	jump (m) Lc_anc_tuning_opmsg_cps_set_control_7;

84200460 <Lc_anc_tuning_opmsg_cps_set_control_16>:

        }
        else if(cntrl_id== ANC_TUNING_CONSTANT_INST_FLAGS1_CTRL)
84200460:	d0 26       	Null = r0 - 11;
84200462:	05 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_set_control_18;

84200464 <Lc_anc_tuning_opmsg_cps_set_control_17>:
        {
            p_ext_data->fb_mon[1] = cntrl_value;
84200464:	49 d8       	rMAC = M[FP + 36];
84200466:	61 f0 17 8f 	M[r4 + 1116] = rMAC;
8420046a:	e1 6f       	jump (m) Lc_anc_tuning_opmsg_cps_set_control_7;

8420046c <Lc_anc_tuning_opmsg_cps_set_control_18>:
        }
        else
        {            
            result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
8420046c:	21 71       	r7 = Null + 4;

8420046e <Lc_anc_tuning_opmsg_cps_set_control_19>:
            break;
        }
    }

    cps_response_set_result(resp_data,result);
8420046e:	4b 08       	r1 = r7 + Null;
84200470:	52 08       	r0 = r8 + Null;
84200472:	ff fd 03 f0 	call (m) 0xb4e;
84200476:	3d e6 

    p_ext_data->connect_change  = TRUE;
84200478:	41 20       	rMAC = Null + 1;
8420047a:	61 f0 0d 8f 	M[r4 + 1076] = rMAC;
    anc_tuning_update_processing(op_data);
8420047e:	5a 08       	r0 = r9 + Null;
84200480:	01 f0 2f e5 	call (m) $_anc_tuning_update_processing;

    return TRUE;
84200484:	42 20       	r0 = Null + 1;

84200486 <Lc_anc_tuning_opmsg_cps_set_control_20>:
}
84200486:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200488:	d8 4c       	rts;

8420048a <$_anc_tuning_opmsg_cps_get_params>:

bool anc_tuning_opmsg_cps_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420048a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420048c:	1e 00       	r4 = r1 + Null;
8420048e:	27 00       	r5 = r2 + Null;
84200490:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
84200492:	ff fd 00 f0 	call (m) 0x4e6;
84200496:	35 e2 

bool anc_tuning_opmsg_cps_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    ANC_TUNING_OP_DATA *op_extra_data = get_instance_data(op_data);

    return cpsGetParameterMsgHandler(&op_extra_data->params_def,message_data,resp_length,resp_data);
84200498:	45 08       	r3 = r6 + Null;
8420049a:	3c 00       	r2 = r5 + Null;
8420049c:	33 00       	r1 = r4 + Null;
8420049e:	ff fd 01 f0 	call (m) 0x792;
842004a2:	35 e7 

842004a4 <Lc_anc_tuning_opmsg_cps_get_params_2>:
}
842004a4:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842004a6:	d8 4c       	rts;

842004a8 <$_anc_tuning_opmsg_cps_get_defaults>:

bool anc_tuning_opmsg_cps_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842004a8:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842004aa:	1e 00       	r4 = r1 + Null;
842004ac:	27 00       	r5 = r2 + Null;
842004ae:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
842004b0:	ff fd 00 f0 	call (m) 0x4e6;
842004b4:	37 e1 

bool anc_tuning_opmsg_cps_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    ANC_TUNING_OP_DATA *op_extra_data = get_instance_data(op_data);

    return cpsGetDefaultsMsgHandler(&op_extra_data->params_def,message_data,resp_length,resp_data);
842004b6:	45 08       	r3 = r6 + Null;
842004b8:	3c 00       	r2 = r5 + Null;
842004ba:	33 00       	r1 = r4 + Null;
842004bc:	ff fd 01 f0 	call (m) 0x840;
842004c0:	25 ec 

842004c2 <Lc_anc_tuning_opmsg_cps_get_defaults_2>:
}
842004c2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842004c4:	d8 4c       	rts;

842004c6 <$_anc_tuning_opmsg_cps_set_params>:

bool anc_tuning_opmsg_cps_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842004c6:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842004c8:	18 09       	r6 = r1 + Null;
842004ca:	26 00       	r4 = r2 + Null;
842004cc:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
842004ce:	ff fd 00 f0 	call (m) 0x4e6;
842004d2:	39 e0 
842004d4:	17 00       	r5 = r0 + Null;
bool anc_tuning_opmsg_cps_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    ANC_TUNING_OP_DATA *op_extra_data = get_instance_data(op_data);
    bool retval;

    retval = cpsSetParameterMsgHandler(&op_extra_data->params_def,message_data,resp_length,resp_data);
842004d6:	4d 08       	r3 = r7 + Null;
842004d8:	34 00       	r2 = r4 + Null;
842004da:	43 08       	r1 = r6 + Null;
842004dc:	ff fd 02 f0 	call (m) 0x914;
842004e0:	39 e1 

    /* Set the Reinit flag after setting the paramters */
    op_extra_data->ReInitFlag = 1;
842004e2:	41 20       	rMAC = Null + 1;
842004e4:	71 f0 bd 8e 	M[r5 + 756] = rMAC;

842004e8 <Lc_anc_tuning_opmsg_cps_set_params_2>:

    return retval;
842004e8:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842004ea:	d8 4c       	rts;

842004ec <$_anc_tuning_opmsg_cps_get_status>:
}

/* OBPM statistics */
bool anc_tuning_opmsg_cps_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842004ec:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
842004ee:	19 09       	r7 = r1 + Null;
842004f0:	27 00       	r5 = r2 + Null;
842004f2:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
842004f4:	ef fd ff ff 	call (m) 0x4e6;
842004f8:	33 ef 
842004fa:	16 00       	r4 = r0 + Null;
bool anc_tuning_opmsg_cps_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    ANC_TUNING_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned  *resp;

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(ANC_TUNING_STATISTICS),&resp))
842004fc:	81 11       	rMAC = FP + 24;
842004fe:	09 1c       	pushm <rMAC>;
84200500:	05 32       	r3 = Null + 40;
84200502:	44 08       	r2 = r6 + Null;
84200504:	3b 00       	r1 = r5 + Null;
84200506:	4a 08       	r0 = r7 + Null;
84200508:	ff fd 03 f0 	call (m) 0xb64;
8420050c:	3d e2 
8420050e:	7f 4c       	SP = SP + -4;
84200510:	10 04       	Null = r0 - Null;
84200512:	03 62       	if NE jump (m) Lc_anc_tuning_opmsg_cps_get_status_3;

84200514 <Lc_anc_tuning_opmsg_cps_get_status_2>:
    {
          return FALSE;
84200514:	02 00       	r0 = Null + Null;
84200516:	37 6e       	jump (m) Lc_anc_tuning_opmsg_cps_get_status_6;

84200518 <Lc_anc_tuning_opmsg_cps_get_status_3>:
    }

    if(resp)
84200518:	34 d8       	r2 = M[FP + 24];
8420051a:	34 60       	if EQ jump (m) Lc_anc_tuning_opmsg_cps_get_status_5;

8420051c <Lc_anc_tuning_opmsg_cps_get_status_4>:
    {
        unsigned val1,val2;
        val1 = op_extra_data->sources[0].sink_index;
8420051c:	62 f0 f2 88 	r0 = M[r4 + 968];
        val2 = op_extra_data->sources[1].sink_index;
84200520:	63 f0 f8 88 	r1 = M[r4 + 992];
        resp = cpsPack2Words(val1, val2, resp);
84200524:	ff fd cb f1 	call (m) 0x39caa;
84200528:	27 ec 
8420052a:	32 de       	M[FP + 24] = r0;
        val1 = op_extra_data->sources[2].sink_index;
8420052c:	62 f0 fe 88 	r0 = M[r4 + 1016];
        val2 = op_extra_data->sources[3].sink_index;
84200530:	63 f0 04 89 	r1 = M[r4 + 1040];
        resp = cpsPack2Words(val1, val2, resp);
84200534:	34 d8       	r2 = M[FP + 24];
84200536:	ff fd cb f1 	call (m) 0x39caa;
8420053a:	35 eb 
8420053c:	32 de       	M[FP + 24] = r0;
        val1 = op_extra_data->fb_mon[0];
8420053e:	62 f0 16 89 	r0 = M[r4 + 1112];
        val2 = op_extra_data->fb_mon[1];
84200542:	63 f0 17 89 	r1 = M[r4 + 1116];
        resp = cpsPack2Words(val1, val2, resp);
84200546:	34 d8       	r2 = M[FP + 24];
84200548:	ff fd cb f1 	call (m) 0x39caa;
8420054c:	23 eb 
8420054e:	32 de       	M[FP + 24] = r0;
        
        /* Peak statistics */
        val1 = op_extra_data->sources[0].peak;
84200550:	62 f0 f3 88 	r0 = M[r4 + 972];
        val2 = op_extra_data->sources[1].peak;
84200554:	63 f0 f9 88 	r1 = M[r4 + 996];
        resp = cpsPack2Words(val1, val2, resp);
84200558:	34 d8       	r2 = M[FP + 24];
8420055a:	ff fd cb f1 	call (m) 0x39caa;
8420055e:	31 ea 
84200560:	32 de       	M[FP + 24] = r0;
        op_extra_data->sources[0].peak=0;
84200562:	60 f0 f3 8e 	M[r4 + 972] = Null;
        op_extra_data->sources[1].peak=0;
84200566:	60 f0 f9 8e 	M[r4 + 996] = Null;
        val1 = op_extra_data->sources[2].peak;
8420056a:	62 f0 ff 88 	r0 = M[r4 + 1020];
        val2 = op_extra_data->sources[3].peak;
8420056e:	63 f0 05 89 	r1 = M[r4 + 1044];
        cpsPack2Words(val1, val2, resp);
84200572:	34 d8       	r2 = M[FP + 24];
84200574:	ff fd cb f1 	call (m) 0x39caa;
84200578:	37 e9 
        op_extra_data->sources[2].peak=0;
8420057a:	60 f0 ff 8e 	M[r4 + 1020] = Null;
        op_extra_data->sources[3].peak=0;
8420057e:	60 f0 05 8f 	M[r4 + 1044] = Null;

84200582 <Lc_anc_tuning_opmsg_cps_get_status_5>:
    }

    return TRUE;
84200582:	42 20       	r0 = Null + 1;

84200584 <Lc_anc_tuning_opmsg_cps_get_status_6>:
}
84200584:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84200586:	d8 4c       	rts;

84200588 <$_anc_tuning_opmsg_cps_set_ucid>:

    return(TRUE);
}

bool anc_tuning_opmsg_cps_set_ucid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200588:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420058a:	12 09       	r8 = r0 + Null;
8420058c:	18 09       	r6 = r1 + Null;
8420058e:	26 00       	r4 = r2 + Null;
84200590:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
84200592:	ef fd ff ff 	call (m) 0x4e6;
84200596:	35 ea 
84200598:	17 00       	r5 = r0 + Null;
{
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data(op_data);
    PS_KEY_TYPE key;
    bool retval;

    retval = cpsSetUcidMsgHandler(&p_ext_data->params_def,message_data,resp_length,resp_data);
8420059a:	4d 08       	r3 = r7 + Null;
8420059c:	34 00       	r2 = r4 + Null;
8420059e:	43 08       	r1 = r6 + Null;
842005a0:	ff fd 02 f0 	call (m) 0x9a6;
842005a4:	27 e0 
842005a6:	16 00       	r4 = r0 + Null;
    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(ANC_TUNING_CAP_ID,p_ext_data->params_def.ucid,OPMSG_P_STORE_PARAMETER_SUB_ID);
842005a8:	39 89       	rMAC = M[r5 + 16];
842005aa:	8a c2       	r0 = rMAC AND 0x3f;
842005ac:	12 54       	r0 = r0 LSHIFT 1;
842005ae:	02 f0 41 f0 	r1 = r0 OR 0x204100;
842005b2:	00 f2 53 c8 
    ps_entry_read((void*)op_data,key,PERSIST_ANY,ups_params_anc_tuning);
842005b6:	42 f0 05 f0 	r3 = Null + 69209339;
842005ba:	fb 58 
842005bc:	04 00       	r2 = Null + Null;
842005be:	52 08       	r0 = r8 + Null;
842005c0:	ff fd 39 f0 	call (m) 0x7888;
842005c4:	29 e6 

    return retval;
842005c6:	32 00       	r0 = r4 + Null;

842005c8 <Lc_anc_tuning_opmsg_cps_set_ucid_2>:
}
842005c8:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842005ca:	d8 4c       	rts;

842005cc <$_anc_tuning_opmsg_cps_get_psid>:

bool anc_tuning_opmsg_cps_get_psid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005cc:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842005ce:	1e 00       	r4 = r1 + Null;
842005d0:	27 00       	r5 = r2 + Null;
842005d2:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
842005d4:	ef fd ff ff 	call (m) 0x4e6;
842005d8:	33 e8 

bool anc_tuning_opmsg_cps_get_psid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    ANC_TUNING_OP_DATA *op_extra_data = get_instance_data(op_data);

    return cpsGetUcidMsgHandler(&op_extra_data->params_def,ANC_TUNING_CAP_ID,message_data,resp_length,resp_data);
842005da:	10 1c       	pushm <r6>;
842005dc:	23 f0 82 40 	r1 = Null + 16514;
842005e0:	3d 00       	r3 = r5 + Null;
842005e2:	34 00       	r2 = r4 + Null;
842005e4:	ff fd 01 f0 	call (m) 0x9c8;
842005e8:	25 ef 
842005ea:	7f 4c       	SP = SP + -4;

842005ec <Lc_anc_tuning_opmsg_cps_get_psid_2>:
}
842005ec:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842005ee:	d8 4c       	rts;

842005f0 <$_anc_tuning_opmsg_frontend_config>:

bool anc_tuning_opmsg_frontend_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005f0:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842005f2:	17 00       	r5 = r0 + Null;
842005f4:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
842005f6:	ef fd ff ff 	call (m) 0x4e6;
842005fa:	31 e7 
842005fc:	10 09       	r6 = r0 + Null;

bool anc_tuning_opmsg_frontend_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data(op_data);

    if (opmgr_op_is_running(op_data))
842005fe:	3a 00       	r0 = r5 + Null;
84200600:	ff fd 28 f0 	call (m) 0x5700;
84200604:	21 e8 
84200606:	10 04       	Null = r0 - Null;
84200608:	03 60       	if EQ jump (m) Lc_anc_tuning_opmsg_frontend_config_3;

8420060a <Lc_anc_tuning_opmsg_frontend_config_2>:
    {
       return FALSE;
8420060a:	02 00       	r0 = Null + Null;
8420060c:	13 6e       	jump (m) Lc_anc_tuning_opmsg_frontend_config_4;

8420060e <Lc_anc_tuning_opmsg_frontend_config_3>:
    }

    p_ext_data->is_stereo = OPMSG_FIELD_GET(message_data,OPMSG_ANC_TUNING_FRONTEND_CONFIG,IS_STEREO);
8420060e:	f1 88       	rMAC = M[r4 + 12];
84200610:	89 c6       	rMAC = rMAC AND 0xffff;
84200612:	81 f0 0a 8f 	M[r6 + 1064] = rMAC;
    p_ext_data->is_two_mic = OPMSG_FIELD_GET(message_data,OPMSG_ANC_TUNING_FRONTEND_CONFIG,IS_TWO_MIC);
84200616:	31 89       	rMAC = M[r4 + 16];
84200618:	89 c6       	rMAC = rMAC AND 0xffff;
8420061a:	81 f0 0b 8f 	M[r6 + 1068] = rMAC;
    p_ext_data->is_parallel_anc = OPMSG_FIELD_GET(message_data,OPMSG_ANC_TUNING_FRONTEND_CONFIG,IS_PARALLEL_ANC);
8420061e:	71 89       	rMAC = M[r4 + 20];
84200620:	89 c6       	rMAC = rMAC AND 0xffff;
84200622:	81 f0 0c 8f 	M[r6 + 1072] = rMAC;

    p_ext_data->connect_change  = TRUE;
84200626:	41 20       	rMAC = Null + 1;
84200628:	81 f0 0d 8f 	M[r6 + 1076] = rMAC;
    anc_tuning_update_processing(op_data);
8420062c:	3a 00       	r0 = r5 + Null;
8420062e:	80 4e       	call (m) $_anc_tuning_update_processing;

    return TRUE;
84200630:	42 20       	r0 = Null + 1;

84200632 <Lc_anc_tuning_opmsg_frontend_config_4>:
}
84200632:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200634:	d8 4c       	rts;

84200636 <$_anc_tuning_process_data>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
void anc_tuning_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200636:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200638:	19 09       	r7 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
8420063a:	ef fd ff ff 	call (m) 0x4e6;
8420063e:	2d e5 
84200640:	16 00       	r4 = r0 + Null;
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data(op_data);
    anc_source_t *lp_source=NULL;
    anc_sink_t   *lp_sink=NULL;
    unsigned      available, amount;

    if (p_ext_data->connect_change)
84200642:	60 f0 0d 89 	Null = M[r4 + 1076];
84200646:	04 60       	if EQ jump (m) Lc_anc_tuning_process_data_3;

84200648 <Lc_anc_tuning_process_data_2>:
    {
        p_ext_data->connect_change = FALSE;
84200648:	60 f0 0d 8f 	M[r4 + 1076] = Null;
        anc_tuning_channel_setup(p_ext_data);
8420064c:	7e 4e       	call (m) $_anc_tuning_channel_setup;

8420064e <Lc_anc_tuning_process_data_3>:
    }

    if(!p_ext_data->first_sink || !p_ext_data->first_source)
8420064e:	61 f0 06 89 	rMAC = M[r4 + 1048];
84200652:	6c 60       	if EQ jump (m) Lc_anc_tuning_process_data_26;

84200654 <Lc_anc_tuning_process_data_4>:
84200654:	61 f0 07 89 	rMAC = M[r4 + 1052];
84200658:	69 60       	if EQ jump (m) Lc_anc_tuning_process_data_26;

8420065a <Lc_anc_tuning_process_data_5>:
        return ;
    }

    /* when a parameter is changed, disable ANC, change parameter
       and then re-enable ANC. */
    if(p_ext_data->ReInitFlag && blicenceComp)
8420065a:	60 f0 bd 88 	Null = M[r4 + 756];
8420065e:	37 60       	if EQ jump (m) Lc_anc_tuning_process_data_15;

84200660 <Lc_anc_tuning_process_data_6>:
84200660:	e0 f0 00 f0 	Null = M[Null + $_blicenceComp];
84200664:	2a 88 
84200666:	33 60       	if EQ jump (m) Lc_anc_tuning_process_data_15;

84200668 <Lc_anc_tuning_process_data_7>:
    {
        /* Disable ANC. A value of zero ensures ANC is completely shut off */
        uint16 inst0_ena=0,inst1_ena=0; 
84200668:	00 09       	r6 = Null + Null;

        p_ext_data->ReInitFlag = 0;
8420066a:	60 f0 bd 8e 	M[r4 + 756] = Null;

        /* disable ANC */
        anc_tuning_enable_wrapper(inst0_ena,inst1_ena);
8420066e:	03 00       	r1 = Null + Null;
84200670:	02 00       	r0 = Null + Null;
84200672:	03 f0 23 e3 	call (m) $_anc_tuning_enable_wrapper;
        L2_DBG_MSG2("anc_tuning_cap: disabling top level anc with %d and %d \n",inst0_ena,inst1_ena);
84200676:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420067a:	88 24       	Null = rMAC - 2;
8420067c:	09 68       	if LT jump (m) Lc_anc_tuning_process_data_9;

8420067e <Lc_anc_tuning_process_data_8>:
8420067e:	55 f1 02 f0 	r0 = Null + 357564416;
84200682:	00 40 
84200684:	04 00       	r2 = Null + Null;
84200686:	03 00       	r1 = Null + Null;
84200688:	ff fd 03 f0 	call (m) 0xcf2;
8420068c:	2b e3 

8420068e <Lc_anc_tuning_process_data_9>:

        inst0_ena = anc_tuning_set_parameters(p_ext_data,STREAM_ANC_INSTANCE_ANC0_ID); 
8420068e:	43 20       	r1 = Null + 1;
84200690:	32 00       	r0 = r4 + Null;
84200692:	b7 4e       	call (m) $_anc_tuning_set_parameters;
84200694:	17 00       	r5 = r0 + Null;
        if(p_ext_data->is_stereo)
84200696:	60 f0 0a 89 	Null = M[r4 + 1064];
8420069a:	05 60       	if EQ jump (m) Lc_anc_tuning_process_data_11;

8420069c <Lc_anc_tuning_process_data_10>:
        {
            inst1_ena = anc_tuning_set_parameters(p_ext_data,STREAM_ANC_INSTANCE_ANC1_ID); 
8420069c:	83 20       	r1 = Null + 2;
8420069e:	32 00       	r0 = r4 + Null;
842006a0:	b0 4e       	call (m) $_anc_tuning_set_parameters;
842006a2:	10 09       	r6 = r0 + Null;

842006a4 <Lc_anc_tuning_process_data_11>:
        }

        /* enable ANC */
       if(p_ext_data->is_parallel_anc)
842006a4:	60 f0 0c 89 	Null = M[r4 + 1072];
842006a8:	02 60       	if EQ jump (m) Lc_anc_tuning_process_data_13;

842006aa <Lc_anc_tuning_process_data_12>:
       {
          inst1_ena = inst0_ena; 
842006aa:	38 09       	r6 = r5 + Null;

842006ac <Lc_anc_tuning_process_data_13>:
       }
        anc_tuning_enable_wrapper(inst0_ena,inst1_ena);
842006ac:	43 08       	r1 = r6 + Null;
842006ae:	3a 00       	r0 = r5 + Null;
842006b0:	03 f0 25 e1 	call (m) $_anc_tuning_enable_wrapper;
        L2_DBG_MSG2("anc_tuning_cap: enabling top level anc with %d and %d \n",inst0_ena,inst1_ena);
842006b4:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842006b8:	88 24       	Null = rMAC - 2;
842006ba:	09 68       	if LT jump (m) Lc_anc_tuning_process_data_15;

842006bc <Lc_anc_tuning_process_data_14>:
842006bc:	55 f1 02 f0 	r0 = Null + 357564473;
842006c0:	39 40 
842006c2:	44 08       	r2 = r6 + Null;
842006c4:	3b 00       	r1 = r5 + Null;
842006c6:	ff fd 03 f0 	call (m) 0xcf2;
842006ca:	2d e1 

842006cc <Lc_anc_tuning_process_data_15>:
    }
    
    available = MAXINT;
842006cc:	ff f7 f7 f7 	r5 = Null + 2147483647;
842006d0:	ff 7b 
    lp_source=p_ext_data->first_source;
842006d2:	68 f0 07 89 	r6 = M[r4 + 1052];

842006d6 <Lc_anc_tuning_process_data_16>:

    do
    {
        /* Minimum Space */
        amount = cbuffer_calc_amount_space_in_words(lp_source->buffer);
842006d6:	82 f0 02 88 	r0 = M[r6 + 8];
842006da:	ff fd cb f1 	call (m) 0x39d88;
842006de:	2f e5 
        if(amount<ANC_TUNING_DEFAULT_BLOCK_SIZE)
842006e0:	10 04       	Null = r0 - Null;
842006e2:	24 60       	if EQ jump (m) Lc_anc_tuning_process_data_26;

842006e4 <Lc_anc_tuning_process_data_17>:
        {
            return;
        }
        if(available>amount)
842006e4:	b8 04       	Null = r5 - r0;
842006e6:	09 f0 87 e0 	if LS jump (m) Lc_anc_tuning_process_data_19;

842006ea <Lc_anc_tuning_process_data_18>:
        {
            available = amount;
842006ea:	17 00       	r5 = r0 + Null;

842006ec <Lc_anc_tuning_process_data_19>:
        }
        lp_source = lp_source->next;
    }while(lp_source);
842006ec:	88 f0 00 e8 	r6 = M[r6 + Null];
842006f0:	f3 63       	if NE jump (m) Lc_anc_tuning_process_data_16;

842006f2 <Lc_anc_tuning_process_data_20>:
    
    lp_sink = p_ext_data->first_sink;
842006f2:	68 f0 06 89 	r6 = M[r4 + 1048];

842006f6 <Lc_anc_tuning_process_data_21>:

    do
    {
        /* Minimum Data */
        amount = cbuffer_calc_amount_data_in_words(lp_sink->buffer);
842006f6:	82 f0 02 88 	r0 = M[r6 + 8];
842006fa:	ff fd cb f1 	call (m) 0x39dd4;
842006fe:	3b e6 
        if(amount<ANC_TUNING_DEFAULT_BLOCK_SIZE)
84200700:	10 04       	Null = r0 - Null;
84200702:	14 60       	if EQ jump (m) Lc_anc_tuning_process_data_26;

84200704 <Lc_anc_tuning_process_data_22>:
        {
            return;
        }
        if(available>amount)
84200704:	b8 04       	Null = r5 - r0;
84200706:	09 f0 87 e0 	if LS jump (m) Lc_anc_tuning_process_data_24;

8420070a <Lc_anc_tuning_process_data_23>:
        {
            available = amount;
8420070a:	17 00       	r5 = r0 + Null;

8420070c <Lc_anc_tuning_process_data_24>:
        }
        lp_sink = lp_sink->next;
    }while(lp_sink);
8420070c:	88 f0 00 e8 	r6 = M[r6 + Null];
84200710:	f3 63       	if NE jump (m) Lc_anc_tuning_process_data_21;

84200712 <Lc_anc_tuning_process_data_25>:

    /* call asm processing */
    anc_tuning_processing(p_ext_data,available);
84200712:	3b 00       	r1 = r5 + Null;
84200714:	32 00       	r0 = r4 + Null;
84200716:	fc ff 2a e7 	call $_anc_tuning_processing;

    /* touched output */
    touched->sources = p_ext_data->connected_sources;
8420071a:	61 f0 09 89 	rMAC = M[r4 + 1060];
8420071e:	91 f0 00 ee 	M[r7 + Null] = rMAC;
    /* touched input */
    touched->sinks = p_ext_data->connected_sinks;
84200722:	61 f0 08 89 	rMAC = M[r4 + 1056];
84200726:	91 f0 01 8e 	M[r7 + 4] = rMAC;

8420072a <Lc_anc_tuning_process_data_26>:

}
8420072a:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420072c:	d8 4c       	rts;

8420072e <$_anc_tuning_update_processing>:

/* ********************************** Misc functions ************************************* */

void anc_tuning_update_processing(OPERATOR_DATA *op_data)
{
8420072e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84200730:	16 00       	r4 = r0 + Null;
    if (opmgr_op_is_running(op_data))
84200732:	ff fd 27 f0 	call (m) 0x5700;
84200736:	2f ee 
84200738:	10 04       	Null = r0 - Null;
8420073a:	05 60       	if EQ jump (m) Lc_anc_tuning_update_processing_3;

8420073c <Lc_anc_tuning_update_processing_2>:
    {
        /* Raise a bg int to process */
        opmgr_kick_operator(op_data);
8420073c:	32 00       	r0 = r4 + Null;
8420073e:	ff fd 18 f0 	call (m) 0x374a;
84200742:	2d e0 

84200744 <Lc_anc_tuning_update_processing_3>:
    }
}
84200744:	f1 48       	popm <FP, r4, rLink>;
84200746:	d8 4c       	rts;

84200748 <$_anc_tuning_channel_setup>:

void anc_tuning_channel_setup(ANC_TUNING_OP_DATA *p_ext_data)
{
84200748:	72 1c       	pushm <FP(=SP), r4, r5>;
    unsigned valid_sinks=0;
8420074a:	01 00       	rMAC = Null + Null;
    unsigned i,temp_mask;
    anc_source_t *lp_source=NULL;
8420074c:	04 00       	r2 = Null + Null;
    anc_sink_t   *lp_sink=NULL;
8420074e:	05 00       	r3 = Null + Null;

    p_ext_data->first_sink=NULL;
84200750:	20 f0 06 8f 	M[r0 + 1048] = Null;
    p_ext_data->first_source=NULL;
84200754:	20 f0 07 8f 	M[r0 + 1052] = Null;

    /* USB - Input */
    if((p_ext_data->connected_sinks&USB_SINK_MASK)==USB_SINK_MASK)
84200758:	26 f0 08 89 	r4 = M[r0 + 1056];
8420075c:	b3 c0       	r1 = r4 AND 0x3;
8420075e:	d8 24       	Null = r1 - 3;
84200760:	02 62       	if NE jump (m) Lc_anc_tuning_channel_setup_3;

84200762 <Lc_anc_tuning_channel_setup_2>:
    {
        valid_sinks |= USB_SINK_MASK;
84200762:	c1 20       	rMAC = Null + 3;

84200764 <Lc_anc_tuning_channel_setup_3>:
    }
    /* Left Stream */
    temp_mask = (p_ext_data->is_two_mic) ? ANC_SINK_MASK_2MIC : ANC_SINK_MASK_1MIC;
84200764:	03 29       	r1 = Null + 20;
84200766:	07 f0 54 40 	r5 = Null + 84;
8420076a:	20 f0 0b 89 	Null = M[r0 + 1068];
8420076e:	01 f7 03 c0 	if NE r1 = r5 + Null;
    if((p_ext_data->connected_sinks&temp_mask)==temp_mask)
84200772:	f7 10       	r5 = r4 AND r1;
84200774:	f8 04       	Null = r5 - r1;
84200776:	02 62       	if NE jump (m) Lc_anc_tuning_channel_setup_5;

84200778 <Lc_anc_tuning_channel_setup_4>:
    {
        valid_sinks |= temp_mask;
84200778:	c9 12       	rMAC = rMAC OR r1;

8420077a <Lc_anc_tuning_channel_setup_5>:
    }
    /* Right Stream */
    temp_mask <<= 1;
8420077a:	1b 54       	r1 = r1 LSHIFT 1;
    if((p_ext_data->connected_sinks&temp_mask)==temp_mask)
8420077c:	f6 10       	r4 = r4 AND r1;
8420077e:	f0 04       	Null = r4 - r1;
84200780:	2f 62       	if NE jump (m) Lc_anc_tuning_channel_setup_16;

84200782 <Lc_anc_tuning_channel_setup_6>:
    {
        valid_sinks |= temp_mask;
84200782:	c9 12       	rMAC = rMAC OR r1;

84200784 <Lc_anc_tuning_channel_setup_7>:
    if(valid_sinks ==0)
    {
        return;
    }

    temp_mask = p_ext_data->is_stereo ? 0xF : 0x7;    
84200784:	c3 21       	r1 = Null + 7;
84200786:	c6 23       	r4 = Null + 15;
84200788:	20 f0 0a 89 	Null = M[r0 + 1064];
8420078c:	01 f6 03 c0 	if NE r1 = r4 + Null;
    if((temp_mask & p_ext_data->connected_sources)!=temp_mask)
84200790:	26 f0 09 89 	r4 = M[r0 + 1060];
84200794:	f6 10       	r4 = r4 AND r1;
84200796:	f0 04       	Null = r4 - r1;
84200798:	2c 62       	if NE jump (m) Lc_anc_tuning_channel_setup_20;

8420079a <Lc_anc_tuning_channel_setup_8>:
    {
        return;
    }

    /* build sink list */
    for (i=0;i<ANC_TUNING_MAX_SINKS;i++)
8420079a:	03 00       	r1 = Null + Null;
8420079c:	26 f0 f8 22 	r4 = r0 + 760;
842007a0:	44 71       	r10 = Null + 8;
842007a2:	0a 4c       	do (m) Lc__loop0;

842007a4 <Lc_anc_tuning_channel_setup_9>:
    {
        if(valid_sinks & (1<<i))
842007a4:	1f 00       	r5 = r1 + Null;
842007a6:	00 f7 97 de 	r5 = 0x1 LSHIFT r5;
842007aa:	7f 10       	r5 = r5 AND rMAC;
842007ac:	03 60       	if EQ jump (m) Lc_anc_tuning_channel_setup_11;

842007ae <Lc_anc_tuning_channel_setup_10>:
        {
            anc_sink_t *lp_ptr=&p_ext_data->sinks[i];

            lp_ptr->next = lp_sink;
842007ae:	35 ee       	M[r4 + Null] = r3;
            lp_sink = lp_ptr;
842007b0:	35 00       	r3 = r4 + Null;

842007b2 <Lc_anc_tuning_channel_setup_11>:
    {
        return;
    }

    /* build sink list */
    for (i=0;i<ANC_TUNING_MAX_SINKS;i++)
842007b2:	5b 20       	r1 = r1 + 1;
842007b4:	36 2a       	r4 = r4 + 24;

842007b6 <Lc__loop0>:
842007b6:	23 f0 b8 23 	r1 = r0 + 952;
            lp_sink = lp_ptr;
        }
    }

    /* build source list */
    for (i=0;i<ANC_TUNING_MAX_SOURCES;i++)
842007ba:	24 71       	r10 = Null + 4;
842007bc:	16 4c       	do (m) Lc__loop1;

842007be <Lc_anc_tuning_channel_setup_13>:
    {
        anc_source_t *lp_ptr=&p_ext_data->sources[i];

        if(lp_ptr->buffer)
842007be:	9e 88       	r4 = M[r1 + 8];
842007c0:	13 60       	if EQ jump (m) Lc_anc_tuning_channel_setup_18;

842007c2 <Lc_anc_tuning_channel_setup_14>:
        {
            lp_ptr->next = lp_source;
842007c2:	1c ee       	M[r1 + Null] = r2;
            lp_source = lp_ptr;
842007c4:	1c 00       	r2 = r1 + Null;

            /* link a sink with the source */
            if(valid_sinks & (1<<lp_ptr->sink_index))
842007c6:	1e 89       	r4 = M[r1 + 16];
842007c8:	37 00       	r5 = r4 + Null;
842007ca:	00 f7 97 de 	r5 = 0x1 LSHIFT r5;
842007ce:	7f 10       	r5 = r5 AND rMAC;
842007d0:	0a 60       	if EQ jump (m) Lc_anc_tuning_channel_setup_17;

842007d2 <Lc_anc_tuning_channel_setup_15>:
            {
                lp_ptr->sink = &p_ext_data->sinks[lp_ptr->sink_index];
842007d2:	27 f0 f8 22 	r5 = r0 + 760;
842007d6:	36 46       	r4 = r4 * 24 (int);
842007d8:	f7 01       	r5 = r4 + r5;
842007da:	df 8e       	M[r1 + 12] = r5;
842007dc:	05 6e       	jump (m) Lc_anc_tuning_channel_setup_18;

842007de <Lc_anc_tuning_channel_setup_16>:
    if((p_ext_data->connected_sinks&temp_mask)==temp_mask)
    {
        valid_sinks |= temp_mask;
    }
    
    if(valid_sinks ==0)
842007de:	08 04       	Null = rMAC - Null;
842007e0:	08 60       	if EQ jump (m) Lc_anc_tuning_channel_setup_20;

842007e2 <Lc__ite_8>:
842007e2:	d1 6f       	jump (m) Lc_anc_tuning_channel_setup_7;

842007e4 <Lc_anc_tuning_channel_setup_17>:
            {
                lp_ptr->sink = &p_ext_data->sinks[lp_ptr->sink_index];
            }
            else
            {
                lp_ptr->sink = NULL;
842007e4:	d8 8e       	M[r1 + 12] = Null;

842007e6 <Lc_anc_tuning_channel_setup_18>:
842007e6:	1b 2a       	r1 = r1 + 24;

842007e8 <Lc__loop1>:
            lp_sink = lp_ptr;
        }
    }

    /* build source list */
    for (i=0;i<ANC_TUNING_MAX_SOURCES;i++)
842007e8:	24 f0 07 8f 	M[r0 + 1052] = r2;
            }
        }
    }
 
    p_ext_data->first_source=lp_source;    
    p_ext_data->first_sink=lp_sink;
842007ec:	25 f0 06 8f 	M[r0 + 1048] = r3;

842007f0 <Lc_anc_tuning_channel_setup_20>:

}
842007f0:	72 48       	popm <FP, r4, r5>;
842007f2:	d8 4c       	rts;

842007f4 <$_anc_tuning_set_monitor>:
 *
 * \return None
 */
void anc_tuning_set_monitor(STREAM_ANC_INSTANCE anc_instance,
                            unsigned decimation_chain_input)
{
842007f4:	c8 1c       	pushm <FP(=SP), rLink>;
            params.bit_enable = 0;
            break;
    }
    stream_anc_user2((void*)&params);
#else
    stream_anc_set_anc_tune(anc_instance, decimation_chain_input);
842007f6:	ff fd 5c f0 	call (m) 0xc0fc;
842007fa:	27 e8 

842007fc <Lc_anc_tuning_set_monitor_2>:
#endif
}
842007fc:	c8 48       	popm <FP, rLink>;
842007fe:	d8 4c       	rts;

84200800 <$_anc_tuning_set_parameters>:
 *
 * \return Bitfields specifying which Filter paths are enabled (=1) and disabled (=0)
 */
uint16 anc_tuning_set_parameters(ANC_TUNING_OP_DATA *p_ext_data,
                                 STREAM_ANC_INSTANCE instance_id)
{
84200800:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200802:	4c 4c       	SP = SP + 48;
84200804:	12 09       	r8 = r0 + Null;
84200806:	19 09       	r7 = r1 + Null;
    uint16 num_anc_instances;
    unsigned nb_coeffs, dec_chain, con_id;
    unsigned dac_hw_params[2];
    bool is_two_mic,is_ffa_en,is_ffb_en,is_fb_en,is_ff_out_en,status_check,is_parallel_anc;

    if(inst_off)
84200808:	98 f0 01 24 	r6 = r7 - 1;
8420080c:	04 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_3;

8420080e <Lc_anc_tuning_set_parameters_2>:
    {
        anc_inst_ptr = (ANC_INST_PARAMS*)(&p_ext_data->
                       anc_tuning_cap_params.OFFSET_ANC_USECASE_R);
8420080e:	a6 f0 84 21 	r4 = r8 + 388;
84200812:	03 6e       	jump (m) Lc_anc_tuning_set_parameters_4;

84200814 <Lc_anc_tuning_set_parameters_3>:
    }
    else
    {
        anc_inst_ptr = (ANC_INST_PARAMS*)(&p_ext_data->
                        anc_tuning_cap_params.OFFSET_ANC_USECASE_L);
84200814:	a6 f0 14 20 	r4 = r8 + 20;

84200818 <Lc_anc_tuning_set_parameters_4>:
    }

    /* setup config flags */
    is_two_mic   = p_ext_data->is_two_mic;
    is_ffa_en    = anc_inst_ptr->OFFSET_FF_A_ENABLE;
84200818:	32 98       	r0 = M[r4 + 32];
8420081a:	42 de       	M[FP + 32] = r0;
    is_ffb_en    = anc_inst_ptr->OFFSET_FF_B_ENABLE;
8420081c:	72 98       	r0 = M[r4 + 36];
8420081e:	4a de       	M[FP + 36] = r0;
    is_fb_en     = anc_inst_ptr->OFFSET_FB_ENABLE;
84200820:	b2 98       	r0 = M[r4 + 40];
84200822:	52 de       	M[FP + 40] = r0;
    is_ff_out_en = anc_inst_ptr->OFFSET_FF_OUT_ENABLE;
84200824:	37 a8       	r5 = M[r4 + 64];
    is_parallel_anc = p_ext_data->is_parallel_anc;
84200826:	a2 f0 0c 89 	r0 = M[r8 + 1072];
8420082a:	5a de       	M[FP + 44] = r0;

    if(!is_two_mic)
8420082c:	a1 f0 0b 89 	rMAC = M[r8 + 1068];
84200830:	0c 62       	if NE jump (m) Lc_anc_tuning_set_parameters_8;

84200832 <Lc_anc_tuning_set_parameters_5>:
    {
        L2_DBG_MSG("anc_tuning_cap: enable more microphones to use FFb filter \n");
84200832:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200836:	88 24       	Null = rMAC - 2;
84200838:	07 68       	if LT jump (m) Lc_anc_tuning_set_parameters_7;

8420083a <Lc_anc_tuning_set_parameters_6>:
8420083a:	55 f1 02 f0 	r0 = Null + 357564529;
8420083e:	71 40 
84200840:	ff fd 02 f0 	call (m) 0xccc;
84200844:	2d e4 

84200846 <Lc_anc_tuning_set_parameters_7>:
        is_ffb_en = FALSE;
84200846:	48 de       	M[FP + 36] = Null;

84200848 <Lc_anc_tuning_set_parameters_8>:

    /* setup enable flag */
    anc_enable_flag = (uint16)((is_ffa_en << 0)
                      |(is_ffb_en << 1)
                      |(is_fb_en << 2)
                      |(is_ff_out_en << 3)); 
84200848:	ba 54       	r0 = r5 LSHIFT 3;
8420084a:	53 d8       	r1 = M[FP + 40];
8420084c:	5b 54       	r1 = r1 LSHIFT 2;
8420084e:	d1 12       	rMAC = r0 OR r1;
84200850:	4a d8       	r0 = M[FP + 36];
84200852:	12 54       	r0 = r0 LSHIFT 1;
84200854:	89 12       	rMAC = rMAC OR r0;
84200856:	42 d8       	r0 = M[FP + 32];
84200858:	89 12       	rMAC = rMAC OR r0;
8420085a:	89 c6       	rMAC = rMAC AND 0xffff;
8420085c:	61 de       	M[FP + 48] = rMAC;

    L2_DBG_MSG1("anc_tuning_cap: anc enable flag has value %d \n",anc_enable_flag);
8420085e:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200862:	88 24       	Null = rMAC - 2;
84200864:	08 68       	if LT jump (m) Lc_anc_tuning_set_parameters_10;

84200866 <Lc_anc_tuning_set_parameters_9>:
84200866:	55 f1 02 f0 	r0 = Null + 357564589;
8420086a:	ad 40 
8420086c:	63 d8       	r1 = M[FP + 48];
8420086e:	ff fd 02 f0 	call (m) 0xcde;
84200872:	31 e3 

84200874 <Lc_anc_tuning_set_parameters_10>:

    /* ANC OFF - exit */
    if(!is_ff_out_en)
84200874:	38 04       	Null = r5 - Null;
84200876:	0e 62       	if NE jump (m) Lc_anc_tuning_set_parameters_14;

84200878 <Lc_anc_tuning_set_parameters_11>:
    {
        L2_DBG_MSG("anc_tuning_cap: ff out not enabled, so ANC OFF\n");
84200878:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420087c:	88 24       	Null = rMAC - 2;
8420087e:	07 68       	if LT jump (m) Lc_anc_tuning_set_parameters_13;

84200880 <Lc_anc_tuning_set_parameters_12>:
84200880:	55 f1 02 f0 	r0 = Null + 357564636;
84200884:	dc 40 
84200886:	ff fd 02 f0 	call (m) 0xccc;
8420088a:	27 e2 

8420088c <Lc_anc_tuning_set_parameters_13>:
        return 0;
8420088c:	02 00       	r0 = Null + Null;
8420088e:	0f f0 c1 e8 	jump (m) Lc_anc_tuning_set_parameters_73;

84200892 <Lc_anc_tuning_set_parameters_14>:

    /* Get FB mon endpoints by checking the endpoint connected to sink terminal 2,3 */
    ENDPOINT *ep_fb_mon;
    ENDPOINT *ep_fb_mon_audio;
    ep_fb_mon = p_ext_data->
                sinks[ANC_TUNING_SINK_FBMON_LEFT+inst_off].ep_handle;
84200892:	0c f8 92 c9 	r0 = r6 * 24 (int);
84200896:	51 08       	rMAC = r8 + Null;
84200898:	51 00       	rMAC = r0 + rMAC;
8420089a:	69 de       	M[FP + 52] = rMAC;
8420089c:	1b f0 cb 88 	r9 = M[rMAC + 812];
     * ep_fb_mon is an endpoint of anc_tuning capability.
     * ep_fb_mon->connected_to is an audio endpoint which is a source endpoint*/

    /* Set instance id of the (ep_fb_mon->connected_to) endpoint
     * For more details look at implementation of stream_anc_configure_instance */
    stream_anc_configure_instance(ep_fb_mon, instance_id);
842008a0:	4b 08       	r1 = r7 + Null;
842008a2:	5a 08       	r0 = r9 + Null;
842008a4:	ff fd 5b f0 	call (m) 0xbf2a;
842008a8:	27 e4 

    /* Enable SDM of the (ep_fb_mon->connected_to) endpoint which is a source endpoint
     * For more details look at implementation of stream_anc_enable_sdm */
    (void)stream_anc_enable_sdm(ep_fb_mon);
842008aa:	5a 08       	r0 = r9 + Null;
842008ac:	ff fd 5c f0 	call (m) 0xc236;
842008b0:	2b ec 

    /* Restore instance id of the (ep_fb_mon->connected_to) endpoint */
    stream_anc_configure_instance(ep_fb_mon, STREAM_ANC_INSTANCE_NONE_ID);
842008b2:	03 00       	r1 = Null + Null;
842008b4:	5a 08       	r0 = r9 + Null;
842008b6:	ff fd 5b f0 	call (m) 0xbf2a;
842008ba:	35 e3 

    /* ep_fb_mon->connected_to is an audio endpoint which is a source endpoint*/
    ep_fb_mon_audio = stream_get_endpoint_connected_to(ep_fb_mon);
842008bc:	5a 08       	r0 = r9 + Null;
842008be:	ff fd 39 f0 	call (m) 0x7afc;
842008c2:	3f e1 

    if (ep_fb_mon_audio != NULL)
842008c4:	10 04       	Null = r0 - Null;
842008c6:	13 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_19;

842008c8 <Lc_anc_tuning_set_parameters_15>:
         * If ANC uses digital mic, FB mon uses instance 0.
         * FB mon mic's are only setup so their decimators can be re-purposed
         * to stream data from the ANC path.  
         */
 
        if (stream_get_device_type(ep_fb_mon_audio) == STREAM_DEVICE_DIGITAL_MIC)
842008c8:	ff fd 42 f0 	call (m) 0x8e42;
842008cc:	3b eb 
842008ce:	90 25       	Null = r0 - 6;
842008d0:	07 62       	if NE jump (m) Lc_anc_tuning_set_parameters_17;

842008d2 <Lc_anc_tuning_set_parameters_16>:
        {
            /* MON1 = DIG_MIC_INST1_LEFT, MON2 = DIG_MIC_INST1_RIGHT */
            if(inst_off)
            {
                /* LOW_LATENCY_ANC_DECIMATION_INPUT_EN_3_FBTUNEOUT1 */
                dec_chain = DEC_CHAIN_3;
842008d2:	c3 20       	r1 = Null + 3;
842008d4:	0f f8 00 c2 	Null = r6 - Null;
842008d8:	a0 f0 43 ce 	if EQ r1 = Null + 2;
842008dc:	06 6e       	jump (m) Lc_anc_tuning_set_parameters_18;

842008de <Lc_anc_tuning_set_parameters_17>:
        {
            /* MON1 = ADC_LEFT, MON2=ADC_RIGHT */
            if(inst_off)
            {
                /* LOW_LATENCY_ANC_DECIMATION_INPUT_EN_1_FBTUNEOUT1 */
                dec_chain = DEC_CHAIN_1;
842008de:	03 00       	r1 = Null + Null;
842008e0:	0f f8 00 c2 	Null = r6 - Null;
842008e4:	21 f0 43 ce 	if NE r1 = Null + 1;

842008e8 <Lc_anc_tuning_set_parameters_18>:
            {
                /* LOW_LATENCY_ANC_DECIMATION_INPUT_EN_0_FBTUNEOUT0 */
               dec_chain = DEC_CHAIN_0;
            }
       }
       anc_tuning_set_monitor(instance_id, dec_chain);
842008e8:	4a 08       	r0 = r7 + Null;
842008ea:	85 4f       	call (m) $_anc_tuning_set_monitor;

842008ec <Lc_anc_tuning_set_parameters_19>:
    }

    /* Get FFa endpoints by checking the endpoint connected to terminal sink 4,5 */
    ep_ffa = p_ext_data->
             sinks[ANC_TUNING_SINK_MIC1_LEFT+inst_off].ep_handle;
842008ec:	69 d8       	rMAC = M[FP + 52];

    /* FB mon set control. Now that the decimators are re-purposed,
     * associate a specific signal from within the ANC block for streaming */

    if (ep_ffa != NULL)
842008ee:	17 f0 d7 88 	r5 = M[rMAC + 860];
842008f2:	13 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_23;

842008f4 <Lc_anc_tuning_set_parameters_20>:
    {
        if (p_ext_data->fb_mon[inst_off])
842008f4:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
842008f8:	51 08       	rMAC = r8 + Null;
842008fa:	51 00       	rMAC = r0 + rMAC;
842008fc:	10 f0 16 89 	Null = M[rMAC + 1112];
84200900:	07 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_22;

84200902 <Lc_anc_tuning_set_parameters_21>:
        {
            (void) stream_anc_connect_feedback_monitor(ep_ffa, ANC_FBMON_FB);
84200902:	43 20       	r1 = Null + 1;
84200904:	3a 00       	r0 = r5 + Null;
84200906:	ff fd 5c f0 	call (m) 0xc254;
8420090a:	2f ea 
8420090c:	06 6e       	jump (m) Lc_anc_tuning_set_parameters_23;

8420090e <Lc_anc_tuning_set_parameters_22>:
        }
        else
        {
            (void) stream_anc_connect_feedback_monitor(ep_ffa, ANC_FBMON_FFA);
8420090e:	03 00       	r1 = Null + Null;
84200910:	3a 00       	r0 = r5 + Null;
84200912:	ff fd 5c f0 	call (m) 0xc254;
84200916:	23 ea 

84200918 <Lc_anc_tuning_set_parameters_23>:
    }

    /* Get FFb endpoints by checking the endpoint connected
     * to sink terminal 6,7
     */
    ep_ffb = p_ext_data->sinks[ANC_TUNING_SINK_MIC2_LEFT+inst_off].ep_handle;
84200918:	69 d8       	rMAC = M[FP + 52];
8420091a:	18 f0 e3 88 	r6 = M[rMAC + 908];

    if(is_parallel_anc)
8420091e:	59 d8       	rMAC = M[FP + 44];
84200920:	11 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_25;

84200922 <Lc_anc_tuning_set_parameters_24>:
    {
      /*dac_hw_params - First value and second values are Instance id and channel id respectively*/ 
       dac_hw_params[0] = AUDIO_INSTANCE_0;
84200922:	80 de       	M[FP + 64] = Null;
       dac_hw_params[1] = AUDIO_CHANNEL_A;
84200924:	88 de       	M[FP + 68] = Null;
       con_id = 0;
      /*Get FB endpoints by calling the same function again, we get same ID for a particular DAC*/
       ep_fb = stream_audio_get_endpoint(con_id, SINK, STREAM_DEVICE_CODEC, 
                                         sizeof(dac_hw_params)/sizeof(dac_hw_params[0]), dac_hw_params, NULL);
84200926:	00 f0 30 cf 	push Null;
8420092a:	01 14       	rMAC = FP + 64;
8420092c:	09 1c       	pushm <rMAC>;
8420092e:	85 20       	r3 = Null + 2;
84200930:	c4 20       	r2 = Null + 3;
84200932:	43 20       	r1 = Null + 1;
84200934:	02 00       	r0 = Null + Null;
84200936:	ff fd 5d f0 	call (m) 0xc4ba;
8420093a:	25 ec 
8420093c:	7e 4c       	SP = SP + -8;
8420093e:	72 de       	M[FP + 56] = r0;
84200940:	05 6e       	jump (m) Lc_anc_tuning_set_parameters_26;

84200942 <Lc_anc_tuning_set_parameters_25>:
    else
    {
      /* Get FB endpoints by checking the endpoint connected
       * to source terminal.
       */
       ep_fb  = p_ext_data->sources[ANC_TUNING_SOURCE_DAC_LEFT+inst_off].ep_handle;
84200942:	69 d8       	rMAC = M[FP + 52];
84200944:	11 f0 fb 88 	rMAC = M[rMAC + 1004];
84200948:	71 de       	M[FP + 56] = rMAC;

8420094a <Lc_anc_tuning_set_parameters_26>:
    }

    L2_DBG_MSG4("anc_tuning_cap: \
    eps are ffa:0x%x  ffb:0x%x  fb:0x%x  fb_mon:0x%x\n",ep_ffa,ep_ffb,ep_fb,ep_fb_mon);
8420094a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420094e:	88 24       	Null = rMAC - 2;
84200950:	0c 68       	if LT jump (m) Lc_anc_tuning_set_parameters_28;

84200952 <Lc_anc_tuning_set_parameters_27>:
84200952:	28 1c       	pushm <r9>;
84200954:	55 f1 02 f0 	r0 = Null + 357564684;
84200958:	0c 41 
8420095a:	44 08       	r2 = r6 + Null;
8420095c:	3b 00       	r1 = r5 + Null;
8420095e:	75 d8       	r3 = M[FP + 56];
84200960:	ff fd 01 f0 	call (m) 0xd20;
84200964:	21 ee 
84200966:	7f 4c       	SP = SP + -4;

84200968 <Lc_anc_tuning_set_parameters_28>:

    /* Remove endpoints from instance.
     * Remove endpoints from paths done internally.
     * Done for each parameter change
     */
    (void) stream_anc_configure_instance(ep_ffa, STREAM_ANC_INSTANCE_NONE_ID);
84200968:	03 00       	r1 = Null + Null;
8420096a:	3a 00       	r0 = r5 + Null;
8420096c:	ff fd 5a f0 	call (m) 0xbf2a;
84200970:	3f ed 
    if (ep_ffb)
84200972:	0f f8 00 c2 	Null = r6 - Null;
84200976:	06 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_30;

84200978 <Lc_anc_tuning_set_parameters_29>:
    {
        (void) stream_anc_configure_instance(ep_ffb,
                                             STREAM_ANC_INSTANCE_NONE_ID);
84200978:	03 00       	r1 = Null + Null;
8420097a:	42 08       	r0 = r6 + Null;
8420097c:	ff fd 5a f0 	call (m) 0xbf2a;
84200980:	2f ed 

84200982 <Lc_anc_tuning_set_parameters_30>:
    }
    if(is_parallel_anc)
84200982:	59 d8       	rMAC = M[FP + 44];
84200984:	09 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_32;

84200986 <Lc_anc_tuning_set_parameters_31>:
    {
       (void) stream_anc_sink_configure(ep_fb,STREAM_CONFIG_KEY_STREAM_ANC_INSTANCE , STREAM_ANC_INSTANCE_NONE_ID);
84200986:	03 f0 00 61 	r1 = Null + 4352;
8420098a:	04 00       	r2 = Null + Null;
8420098c:	72 d8       	r0 = M[FP + 56];
8420098e:	ff fd 5d f0 	call (m) 0xc39a;
84200992:	2d e0 
84200994:	06 6e       	jump (m) Lc_anc_tuning_set_parameters_33;

84200996 <Lc_anc_tuning_set_parameters_32>:
    }
    else
    {
       (void) stream_anc_configure_instance(ep_fb, STREAM_ANC_INSTANCE_NONE_ID);
84200996:	03 00       	r1 = Null + Null;
84200998:	72 d8       	r0 = M[FP + 56];
8420099a:	ff fd 5a f0 	call (m) 0xbf2a;
8420099e:	31 ec 

842009a0 <Lc_anc_tuning_set_parameters_33>:
    }

    /* Associate endpoints with ANC instances */
    (void) stream_anc_configure_instance(ep_ffa, instance_id);
842009a0:	4b 08       	r1 = r7 + Null;
842009a2:	3a 00       	r0 = r5 + Null;
842009a4:	ff fd 5a f0 	call (m) 0xbf2a;
842009a8:	27 ec 
    if (is_ffb_en)
842009aa:	49 d8       	rMAC = M[FP + 36];
842009ac:	06 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_35;

842009ae <Lc_anc_tuning_set_parameters_34>:
    {
        (void) stream_anc_configure_instance(ep_ffb, instance_id);
842009ae:	4b 08       	r1 = r7 + Null;
842009b0:	42 08       	r0 = r6 + Null;
842009b2:	ff fd 5a f0 	call (m) 0xbf2a;
842009b6:	39 eb 

842009b8 <Lc_anc_tuning_set_parameters_35>:
    }
    if(is_parallel_anc)
842009b8:	59 d8       	rMAC = M[FP + 44];
842009ba:	0a 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_37;

842009bc <Lc_anc_tuning_set_parameters_36>:
    {
         (void) stream_anc_sink_configure(ep_fb, STREAM_CONFIG_KEY_STREAM_ANC_INSTANCE, instance_id);
842009bc:	03 f0 00 61 	r1 = Null + 4352;
842009c0:	4c 08       	r2 = r7 + Null;
842009c2:	72 d8       	r0 = M[FP + 56];
842009c4:	ff fd 5c f0 	call (m) 0xc39a;
842009c8:	37 ee 
         num_anc_instances = 2;
842009ca:	13 71       	r9 = Null + 2;
842009cc:	07 6e       	jump (m) Lc_anc_tuning_set_parameters_38;

842009ce <Lc_anc_tuning_set_parameters_37>:
    }
    else
    {
         num_anc_instances = 1;
842009ce:	0b 71       	r9 = Null + 1;
         (void) stream_anc_configure_instance(ep_fb, instance_id);
842009d0:	4b 08       	r1 = r7 + Null;
842009d2:	72 d8       	r0 = M[FP + 56];
842009d4:	ff fd 5a f0 	call (m) 0xbf2a;
842009d8:	37 ea 

842009da <Lc_anc_tuning_set_parameters_38>:
    }

    /* Associate endpoints with filter paths */
    if (is_ffa_en)
842009da:	41 d8       	rMAC = M[FP + 32];
842009dc:	06 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_40;

842009de <Lc_anc_tuning_set_parameters_39>:
    {
        (void) stream_anc_configure_input(ep_ffa, STREAM_ANC_PATH_FFA_ID);
842009de:	43 20       	r1 = Null + 1;
842009e0:	3a 00       	r0 = r5 + Null;
842009e2:	ff fd 5a f0 	call (m) 0xbf1a;
842009e6:	39 e9 

842009e8 <Lc_anc_tuning_set_parameters_40>:
    }
    if (is_ffb_en)
842009e8:	49 d8       	rMAC = M[FP + 36];
842009ea:	06 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_42;

842009ec <Lc_anc_tuning_set_parameters_41>:
    {
        (void) stream_anc_configure_input(ep_ffb, STREAM_ANC_PATH_FFB_ID);
842009ec:	83 20       	r1 = Null + 2;
842009ee:	42 08       	r0 = r6 + Null;
842009f0:	ff fd 5a f0 	call (m) 0xbf1a;
842009f4:	2b e9 

842009f6 <Lc_anc_tuning_set_parameters_42>:
842009f6:	41 20       	rMAC = Null + 1;
842009f8:	79 de       	M[FP + 60] = rMAC;

842009fa <Lc_anc_tuning_set_parameters_43>:
         * Uses two methods to reach the ANC hardware:
         * configure a connected_to endpoint and
         * using a shim layer that provides an interface between the ANC hardware
         * and this capability.
        */
        if (is_ffa_en)
842009fa:	41 d8       	rMAC = M[FP + 32];
842009fc:	5d 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_48;

842009fe <Lc_anc_tuning_set_parameters_44>:
        {
            (void) stream_anc_configure_dmic_x2_enable(ep_ffa,
                                           STREAM_ANC_PATH_FFA_ID,
                                           anc_inst_ptr->OFFSET_DMIC_X2_FF_A_ENABLE);
842009fe:	34 b8       	r2 = M[r4 + 96];
84200a00:	43 20       	r1 = Null + 1;
84200a02:	3a 00       	r0 = r5 + Null;
84200a04:	ff fd 5b f0 	call (m) 0xc042;
84200a08:	3f e1 
            (void) stream_anc_configure_dc_filter_enable(ep_ffa,
                                           STREAM_ANC_PATH_FFA_ID,
                                           anc_inst_ptr->OFFSET_FF_A_DCFLT_ENABLE);
84200a0a:	b4 a9       	r2 = M[r4 + 88];
84200a0c:	43 20       	r1 = Null + 1;
84200a0e:	3a 00       	r0 = r5 + Null;
84200a10:	ff fd 5a f0 	call (m) 0xbfc6;
84200a14:	37 ed 
            (void) stream_anc_configure_dc_filter_shift(ep_ffa,
                                           STREAM_ANC_PATH_FFA_ID,
                                           anc_inst_ptr->OFFSET_FF_A_DCFLT_SHIFT);
84200a16:	64 f0 59 88 	r2 = M[r4 + 356];
84200a1a:	43 20       	r1 = Null + 1;
84200a1c:	3a 00       	r0 = r5 + Null;
84200a1e:	ff fd 5a f0 	call (m) 0xc004;
84200a22:	27 ef 
            (void) stream_anc_configure_gain(ep_ffa,
                                           STREAM_ANC_PATH_FFA_ID,
                                           anc_inst_ptr->OFFSET_ANC_FF_A_GAIN);
84200a24:	64 f0 2e 88 	r2 = M[r4 + 184];
84200a28:	43 20       	r1 = Null + 1;
84200a2a:	3a 00       	r0 = r5 + Null;
84200a2c:	ff fd 5a f0 	call (m) 0xbf4a;
84200a30:	3f e8 
            (void) stream_anc_configure_gain_shift(ep_ffa,
                                           STREAM_ANC_PATH_FFA_ID,
                                           anc_inst_ptr->OFFSET_ANC_FF_A_SHIFT);
84200a32:	b4 b8       	r2 = M[r4 + 104];
84200a34:	43 20       	r1 = Null + 1;
84200a36:	3a 00       	r0 = r5 + Null;
84200a38:	ff fd 5a f0 	call (m) 0xbf88;
84200a3c:	31 ea 

            /* Configure smLPF parameters */
            (void) stream_anc_configure_dc_filter_enable(ep_ffa,
                                           STREAM_ANC_PATH_SM_LPF_ID,
                                           anc_inst_ptr->OFFSET_SMLPF_ENABLE);
84200a3e:	74 a8       	r2 = M[r4 + 68];
84200a40:	03 21       	r1 = Null + 4;
84200a42:	3a 00       	r0 = r5 + Null;
84200a44:	ff fd 5a f0 	call (m) 0xbfc6;
84200a48:	23 ec 
            (void) stream_anc_configure_dc_filter_shift(ep_ffa,
                                           STREAM_ANC_PATH_SM_LPF_ID,
                                           anc_inst_ptr->OFFSET_SM_LPF_SHIFT);
84200a4a:	64 f0 5b 88 	r2 = M[r4 + 364];
84200a4e:	03 21       	r1 = Null + 4;
84200a50:	3a 00       	r0 = r5 + Null;
84200a52:	ff fd 5a f0 	call (m) 0xc004;
84200a56:	33 ed 

            /* Set LPF and IIR filter coefficients for FFa path */
            stream_anc_set_anc_lpf_coeffs(instance_id,
                            STREAM_ANC_PATH_FFA_ID,
                            (uint16)(anc_inst_ptr->OFFSET_ANC_FF_A_LPF_SHIFT0),
                            (uint16)(anc_inst_ptr->OFFSET_ANC_FF_A_LPF_SHIFT1));
84200a58:	61 f0 54 88 	rMAC = M[r4 + 336];
84200a5c:	43 20       	r1 = Null + 1;
84200a5e:	8d c6       	r3 = rMAC AND 0xffff;
84200a60:	61 f0 53 88 	rMAC = M[r4 + 332];
84200a64:	8c c6       	r2 = rMAC AND 0xffff;
84200a66:	4a 08       	r0 = r7 + Null;
84200a68:	ff fd 5b f0 	call (m) 0xc17a;
84200a6c:	33 e8 

            nb_coeffs = stream_anc_get_filters_coeff_number(STREAM_ANC_PATH_FFA_ID);
84200a6e:	42 20       	r0 = Null + 1;
84200a70:	ff fd 5b f0 	call (m) 0xc07c;
84200a74:	2d e0 
84200a76:	14 00       	r2 = r0 + Null;
            for (i=0; i < nb_coeffs; i++)
84200a78:	02 00       	r0 = Null + Null;
84200a7a:	61 f0 74 20 	rMAC = r4 + 116;
84200a7e:	a5 f0 38 28 	r3 = r8 + 1080;
84200a82:	10 05       	Null = r0 - r2;
84200a84:	02 f0 9b e0 	if C jump (m) Lc__loop2;

84200a88 <Lc_anc_tuning_set_parameters_45>:
84200a88:	24 09       	r10 = r2 + Null;
84200a8a:	0a 4c       	do (m) Lc__loop2;

84200a8c <Lc_anc_tuning_set_parameters_46>:
                 * (rounded instead of floored) for coefficients to end up being
                 * shaped correctly for the ANC hardware
                */
                p_ext_data->coeffs[i] = (uint16)frac_mult(
                            (anc_inst_ptr->OFFSET_ANC_FF_A_COEFF[i]),
                            FRACTIONAL(1.0/16.0)); 
84200a8c:	0a e8       	r0 = M[rMAC + Null];
84200a8e:	7f f0 f3 f7 	r1 = Null + 134217727;
84200a92:	ff 7b 
84200a94:	09 21       	rMAC = rMAC + 4;
84200a96:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200a9a:	2a 8c       	MH[r3 + 0] = r0;
84200a9c:	ad 20       	r3 = r3 + 2;

84200a9e <Lc__loop2>:
                            STREAM_ANC_PATH_FFA_ID,
                            (uint16)(anc_inst_ptr->OFFSET_ANC_FF_A_LPF_SHIFT0),
                            (uint16)(anc_inst_ptr->OFFSET_ANC_FF_A_LPF_SHIFT1));

            nb_coeffs = stream_anc_get_filters_coeff_number(STREAM_ANC_PATH_FFA_ID);
            for (i=0; i < nb_coeffs; i++)
84200a9e:	a5 f0 38 28 	r3 = r8 + 1080;
84200aa2:	43 20       	r1 = Null + 1;
84200aa4:	4a 08       	r0 = r7 + Null;
84200aa6:	ff fd 5a f0 	call (m) 0xc0a2;
84200aaa:	3d ef 
                            FRACTIONAL(1.0/16.0)); 
            }
            stream_anc_set_anc_iir_coeffs(instance_id, STREAM_ANC_PATH_FFA_ID,
                                          nb_coeffs, p_ext_data->coeffs);

            opmgr_override_set_ep_gain(ep_ffa, anc_inst_ptr->OFFSET_FF_A_FE_GAIN);
84200aac:	f3 88       	r1 = M[r4 + 12];
84200aae:	3a 00       	r0 = r5 + Null;
84200ab0:	ff fd 25 f0 	call (m) 0x551e;
84200ab4:	2f e3 

84200ab6 <Lc_anc_tuning_set_parameters_48>:
         * Uses two methods to reach the ANC hardware:
         * configure a connected_to endpoint and
         * using a shim layer that provides an interface between the
         * ANC hardware and this capability.
        */
        if (is_ffb_en)
84200ab6:	49 d8       	rMAC = M[FP + 36];
84200ab8:	50 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_53;

84200aba <Lc_anc_tuning_set_parameters_49>:
        {
            (void) stream_anc_configure_dmic_x2_enable(ep_ffb,
                                           STREAM_ANC_PATH_FFB_ID,
                                           anc_inst_ptr->OFFSET_DMIC_X2_FF_B_ENABLE);
84200aba:	74 b8       	r2 = M[r4 + 100];
84200abc:	83 20       	r1 = Null + 2;
84200abe:	42 08       	r0 = r6 + Null;
84200ac0:	ff fd 5a f0 	call (m) 0xc042;
84200ac4:	23 ec 
            (void) stream_anc_configure_dc_filter_enable(ep_ffb,
                                           STREAM_ANC_PATH_FFB_ID,
                                           anc_inst_ptr->OFFSET_FF_B_DCFLT_ENABLE);
84200ac6:	f4 a9       	r2 = M[r4 + 92];
84200ac8:	83 20       	r1 = Null + 2;
84200aca:	42 08       	r0 = r6 + Null;
84200acc:	ff fd 5a f0 	call (m) 0xbfc6;
84200ad0:	3b e7 
            (void) stream_anc_configure_dc_filter_shift(ep_ffb,
                                           STREAM_ANC_PATH_FFB_ID,
                                           anc_inst_ptr->OFFSET_FF_B_DCFLT_SHIFT);
84200ad2:	64 f0 5a 88 	r2 = M[r4 + 360];
84200ad6:	83 20       	r1 = Null + 2;
84200ad8:	42 08       	r0 = r6 + Null;
84200ada:	ff fd 5a f0 	call (m) 0xc004;
84200ade:	2b e9 
            (void) stream_anc_configure_gain(ep_ffb,
                                           STREAM_ANC_PATH_FFB_ID,
                                           anc_inst_ptr->OFFSET_ANC_FF_B_GAIN);
84200ae0:	64 f0 40 88 	r2 = M[r4 + 256];
84200ae4:	83 20       	r1 = Null + 2;
84200ae6:	42 08       	r0 = r6 + Null;
84200ae8:	ff fd 5a f0 	call (m) 0xbf4a;
84200aec:	23 e3 
            (void) stream_anc_configure_gain_shift(ep_ffb,
                                           STREAM_ANC_PATH_FFB_ID,
                                           anc_inst_ptr->OFFSET_ANC_FF_B_SHIFT);
84200aee:	f4 b8       	r2 = M[r4 + 108];
84200af0:	83 20       	r1 = Null + 2;
84200af2:	42 08       	r0 = r6 + Null;
84200af4:	ff fd 5a f0 	call (m) 0xbf88;
84200af8:	35 e4 

            /* Set LPF and IIR filter coefficients for FFb path */
            stream_anc_set_anc_lpf_coeffs(instance_id, STREAM_ANC_PATH_FFB_ID,
                                (uint16)(anc_inst_ptr->OFFSET_ANC_FF_B_LPF_SHIFT0),
                                (uint16)(anc_inst_ptr->OFFSET_ANC_FF_B_LPF_SHIFT1));
84200afa:	61 f0 56 88 	rMAC = M[r4 + 344];
84200afe:	83 20       	r1 = Null + 2;
84200b00:	8d c6       	r3 = rMAC AND 0xffff;
84200b02:	61 f0 55 88 	rMAC = M[r4 + 340];
84200b06:	8c c6       	r2 = rMAC AND 0xffff;
84200b08:	4a 08       	r0 = r7 + Null;
84200b0a:	ff fd 5b f0 	call (m) 0xc17a;
84200b0e:	31 e3 

            nb_coeffs = stream_anc_get_filters_coeff_number(STREAM_ANC_PATH_FFB_ID);
84200b10:	82 20       	r0 = Null + 2;
84200b12:	ff fd 5a f0 	call (m) 0xc07c;
84200b16:	2b eb 
84200b18:	14 00       	r2 = r0 + Null;
            for (i=0; i<nb_coeffs; i++)
84200b1a:	02 00       	r0 = Null + Null;
84200b1c:	61 f0 bc 20 	rMAC = r4 + 188;
84200b20:	a5 f0 38 28 	r3 = r8 + 1080;
84200b24:	10 05       	Null = r0 - r2;
84200b26:	02 f0 9b e0 	if C jump (m) Lc__loop3;

84200b2a <Lc_anc_tuning_set_parameters_50>:
84200b2a:	24 09       	r10 = r2 + Null;
84200b2c:	0a 4c       	do (m) Lc__loop3;

84200b2e <Lc_anc_tuning_set_parameters_51>:
                 * (rounded instead of floored) for coefficients to end up being 
                 * shaped correctly for the ANC hardware 
                 */
                p_ext_data->coeffs[i] = (uint16)frac_mult(
                            (anc_inst_ptr->OFFSET_ANC_FF_B_COEFF[i]),
                            FRACTIONAL(1.0/16.0)); 
84200b2e:	0a e8       	r0 = M[rMAC + Null];
84200b30:	7f f0 f3 f7 	r1 = Null + 134217727;
84200b34:	ff 7b 
84200b36:	09 21       	rMAC = rMAC + 4;
84200b38:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200b3c:	2a 8c       	MH[r3 + 0] = r0;
84200b3e:	ad 20       	r3 = r3 + 2;

84200b40 <Lc__loop3>:
            stream_anc_set_anc_lpf_coeffs(instance_id, STREAM_ANC_PATH_FFB_ID,
                                (uint16)(anc_inst_ptr->OFFSET_ANC_FF_B_LPF_SHIFT0),
                                (uint16)(anc_inst_ptr->OFFSET_ANC_FF_B_LPF_SHIFT1));

            nb_coeffs = stream_anc_get_filters_coeff_number(STREAM_ANC_PATH_FFB_ID);
            for (i=0; i<nb_coeffs; i++)
84200b40:	a5 f0 38 28 	r3 = r8 + 1080;
84200b44:	83 20       	r1 = Null + 2;
84200b46:	4a 08       	r0 = r7 + Null;
84200b48:	ff fd 5a f0 	call (m) 0xc0a2;
84200b4c:	3b ea 
                            FRACTIONAL(1.0/16.0)); 
            }
            stream_anc_set_anc_iir_coeffs(instance_id, STREAM_ANC_PATH_FFB_ID,
                                          nb_coeffs, p_ext_data->coeffs);

            opmgr_override_set_ep_gain(ep_ffb, anc_inst_ptr->OFFSET_FF_B_FE_GAIN);
84200b4e:	33 89       	r1 = M[r4 + 16];
84200b50:	42 08       	r0 = r6 + Null;
84200b52:	ff fd 24 f0 	call (m) 0x551e;
84200b56:	2d ee 

84200b58 <Lc_anc_tuning_set_parameters_53>:
         * Uses two methods to reach the ANC hardware:
         * configure a connected_to endpoint and
         * using a shim layer that provides an interface between the 
         * ANC hardware and this capability 
         */
        if (is_fb_en)
84200b58:	51 d8       	rMAC = M[FP + 40];
84200b5a:	3d 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_58;

84200b5c <Lc_anc_tuning_set_parameters_54>:
        {
            /* Really wants a DAC sink association, but the audio layer is
             * expecting an ADC source association on the same instance
             */
            (void) stream_anc_configure_gain(ep_ffa, STREAM_ANC_PATH_FB_ID,
                                             anc_inst_ptr->OFFSET_ANC_FB_GAIN);
84200b5c:	64 f0 52 88 	r2 = M[r4 + 328];
84200b60:	c3 20       	r1 = Null + 3;
84200b62:	3a 00       	r0 = r5 + Null;
84200b64:	ff fd 59 f0 	call (m) 0xbf4a;
84200b68:	27 ef 
            (void) stream_anc_configure_gain_shift(ep_ffa, STREAM_ANC_PATH_FB_ID,
                                             anc_inst_ptr->OFFSET_ANC_FB_SHIFT);
84200b6a:	34 b9       	r2 = M[r4 + 112];
84200b6c:	c3 20       	r1 = Null + 3;
84200b6e:	3a 00       	r0 = r5 + Null;
84200b70:	ff fd 5a f0 	call (m) 0xbf88;
84200b74:	39 e0 

            /* set LPF and IIR filter coefficients for FB path */
            stream_anc_set_anc_lpf_coeffs(instance_id,STREAM_ANC_PATH_FB_ID,
                                  (uint16)(anc_inst_ptr->OFFSET_ANC_FB_LPF_SHIFT0),
                                  (uint16)(anc_inst_ptr->OFFSET_ANC_FB_LPF_SHIFT1));
84200b76:	61 f0 58 88 	rMAC = M[r4 + 352];
84200b7a:	c3 20       	r1 = Null + 3;
84200b7c:	8d c6       	r3 = rMAC AND 0xffff;
84200b7e:	61 f0 57 88 	rMAC = M[r4 + 348];
84200b82:	8c c6       	r2 = rMAC AND 0xffff;
84200b84:	4a 08       	r0 = r7 + Null;
84200b86:	ff fd 5a f0 	call (m) 0xc17a;
84200b8a:	35 ef 

            nb_coeffs = stream_anc_get_filters_coeff_number(STREAM_ANC_PATH_FB_ID);
84200b8c:	c2 20       	r0 = Null + 3;
84200b8e:	ff fd 5a f0 	call (m) 0xc07c;
84200b92:	2f e7 
84200b94:	14 00       	r2 = r0 + Null;
            for (i=0; i<nb_coeffs; i++)
84200b96:	02 00       	r0 = Null + Null;
84200b98:	61 f0 04 21 	rMAC = r4 + 260;
84200b9c:	a5 f0 38 28 	r3 = r8 + 1080;
84200ba0:	10 05       	Null = r0 - r2;
84200ba2:	02 f0 9b e0 	if C jump (m) Lc__loop4;

84200ba6 <Lc_anc_tuning_set_parameters_55>:
84200ba6:	24 09       	r10 = r2 + Null;
84200ba8:	0a 4c       	do (m) Lc__loop4;

84200baa <Lc_anc_tuning_set_parameters_56>:
                 * (rounded instead of floored) for coefficients to end up being 
                 * shaped correctly for the ANC hardware 
                 */
                p_ext_data->coeffs[i] = (uint16)frac_mult(
                            (anc_inst_ptr->OFFSET_ANC_FB_COEFF[i]),
                            FRACTIONAL(1.0/16.0));
84200baa:	0a e8       	r0 = M[rMAC + Null];
84200bac:	7f f0 f3 f7 	r1 = Null + 134217727;
84200bb0:	ff 7b 
84200bb2:	09 21       	rMAC = rMAC + 4;
84200bb4:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200bb8:	2a 8c       	MH[r3 + 0] = r0;
84200bba:	ad 20       	r3 = r3 + 2;

84200bbc <Lc__loop4>:
            stream_anc_set_anc_lpf_coeffs(instance_id,STREAM_ANC_PATH_FB_ID,
                                  (uint16)(anc_inst_ptr->OFFSET_ANC_FB_LPF_SHIFT0),
                                  (uint16)(anc_inst_ptr->OFFSET_ANC_FB_LPF_SHIFT1));

            nb_coeffs = stream_anc_get_filters_coeff_number(STREAM_ANC_PATH_FB_ID);
            for (i=0; i<nb_coeffs; i++)
84200bbc:	a5 f0 38 28 	r3 = r8 + 1080;
84200bc0:	c3 20       	r1 = Null + 3;
84200bc2:	4a 08       	r0 = r7 + Null;
84200bc4:	ff fd 5a f0 	call (m) 0xc0a2;
84200bc8:	3f e6 
            }

            stream_anc_set_anc_iir_coeffs(instance_id, STREAM_ANC_PATH_FB_ID,
                                          nb_coeffs, p_ext_data->coeffs);

            opmgr_override_set_ep_gain(ep_fb, anc_inst_ptr->OFFSET_SPKR_RECEIVER_PA_GAIN);
84200bca:	f3 89       	r1 = M[r4 + 28];
84200bcc:	72 d8       	r0 = M[FP + 56];
84200bce:	ff fd 24 f0 	call (m) 0x551e;
84200bd2:	31 ea 

84200bd4 <Lc_anc_tuning_set_parameters_58>:
        }

        if(is_parallel_anc && (instance_id == STREAM_ANC_INSTANCE_ANC0_ID))
84200bd4:	59 d8       	rMAC = M[FP + 44];
84200bd6:	74 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_71;

84200bd8 <Lc_anc_tuning_set_parameters_59>:
84200bd8:	90 f0 01 24 	Null = r7 - 1;
84200bdc:	71 62       	if NE jump (m) Lc_anc_tuning_set_parameters_71;

84200bde <Lc_anc_tuning_set_parameters_60>:
        {
            /*Outmix enable*/
            status_check = stream_anc_configure_control(ep_ffa, (OUTMIX_ENABLE_MASK|FBMON_SEL_MASK));
84200bde:	05 f0 03 f0 	r1 = Null + 5242960;
84200be2:	50 40 
84200be4:	3a 00       	r0 = r5 + Null;
84200be6:	ff fd 59 f0 	call (m) 0xbf3a;
84200bea:	35 ea 
84200bec:	13 00       	r1 = r0 + Null;
            L2_DBG_MSG1("anc_tuning_cap: outmix enable flag has value %d \n", status_check);
84200bee:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200bf2:	88 24       	Null = rMAC - 2;
84200bf4:	07 68       	if LT jump (m) Lc_anc_tuning_set_parameters_62;

84200bf6 <Lc_anc_tuning_set_parameters_61>:
84200bf6:	55 f1 02 f0 	r0 = Null + 357564754;
84200bfa:	52 41 
84200bfc:	ff fd 00 f0 	call (m) 0xcde;
84200c00:	23 e7 

84200c02 <Lc_anc_tuning_set_parameters_62>:
       
            /*Get FB endpoints by calling the same function again, we get same ID for a particular DAC*/    
            dac_hw_params[0] = AUDIO_INSTANCE_0;
84200c02:	80 de       	M[FP + 64] = Null;
            dac_hw_params[1] = AUDIO_CHANNEL_B;
84200c04:	79 d8       	rMAC = M[FP + 60];
84200c06:	89 de       	M[FP + 68] = rMAC;
            con_id = 0;
            ep_fb = stream_audio_get_endpoint(con_id, SINK, STREAM_DEVICE_CODEC, 
                                              sizeof(dac_hw_params)/sizeof(dac_hw_params[0]), dac_hw_params, NULL);
84200c08:	00 f0 30 cf 	push Null;
84200c0c:	01 14       	rMAC = FP + 64;
84200c0e:	09 1c       	pushm <rMAC>;
84200c10:	85 20       	r3 = Null + 2;
84200c12:	c4 20       	r2 = Null + 3;
84200c14:	43 20       	r1 = Null + 1;
84200c16:	02 00       	r0 = Null + Null;
84200c18:	ff fd 5c f0 	call (m) 0xc4ba;
84200c1c:	23 e5 
84200c1e:	7e 4c       	SP = SP + -8;
84200c20:	72 de       	M[FP + 56] = r0;
    
            (void) stream_anc_configure_instance(ep_ffa, STREAM_ANC_INSTANCE_NONE_ID);
84200c22:	03 00       	r1 = Null + Null;
84200c24:	3a 00       	r0 = r5 + Null;
84200c26:	ff fd 59 f0 	call (m) 0xbf2a;
84200c2a:	25 e8 
            if (ep_ffb)
84200c2c:	0f f8 00 c2 	Null = r6 - Null;
84200c30:	06 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_64;

84200c32 <Lc_anc_tuning_set_parameters_63>:
            {
                (void) stream_anc_configure_instance(ep_ffb,
                                                     STREAM_ANC_INSTANCE_NONE_ID);
84200c32:	03 00       	r1 = Null + Null;
84200c34:	42 08       	r0 = r6 + Null;
84200c36:	ff fd 59 f0 	call (m) 0xbf2a;
84200c3a:	35 e7 

84200c3c <Lc_anc_tuning_set_parameters_64>:
            }
            (void) stream_anc_sink_configure(ep_fb, STREAM_CONFIG_KEY_STREAM_ANC_INSTANCE, STREAM_ANC_INSTANCE_NONE_ID);
84200c3c:	03 f0 00 61 	r1 = Null + 4352;
84200c40:	04 00       	r2 = Null + Null;
84200c42:	72 d8       	r0 = M[FP + 56];
84200c44:	ff fd 5b f0 	call (m) 0xc39a;
84200c48:	37 ea 
            instance_id = STREAM_ANC_INSTANCE_ANC1_ID;
84200c4a:	11 71       	r7 = Null + 2;
            /* Associate endpoints with ANC instances */
            (void) stream_anc_configure_instance(ep_ffa, instance_id);
84200c4c:	4b 08       	r1 = r7 + Null;
84200c4e:	3a 00       	r0 = r5 + Null;
84200c50:	ff fd 59 f0 	call (m) 0xbf2a;
84200c54:	3b e6 
            if (is_ffb_en)
84200c56:	49 d8       	rMAC = M[FP + 36];
84200c58:	06 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_66;

84200c5a <Lc_anc_tuning_set_parameters_65>:
            {
                (void) stream_anc_configure_instance(ep_ffb, instance_id);
84200c5a:	4b 08       	r1 = r7 + Null;
84200c5c:	42 08       	r0 = r6 + Null;
84200c5e:	ff fd 59 f0 	call (m) 0xbf2a;
84200c62:	2d e6 

84200c64 <Lc_anc_tuning_set_parameters_66>:
            }
            (void) stream_anc_sink_configure(ep_fb, STREAM_CONFIG_KEY_STREAM_ANC_INSTANCE, instance_id);
84200c64:	03 f0 00 61 	r1 = Null + 4352;
84200c68:	4c 08       	r2 = r7 + Null;
84200c6a:	72 d8       	r0 = M[FP + 56];
84200c6c:	ff fd 5b f0 	call (m) 0xc39a;
84200c70:	2f e9 
    
            /* Associate endpoints with filter paths */
            /* FFa Mic end point is connected to FFa path in ANC 0 and ANC 1*/
            if (is_ffa_en)
84200c72:	41 d8       	rMAC = M[FP + 32];
84200c74:	11 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_68;

84200c76 <Lc_anc_tuning_set_parameters_67>:
            {
                status_check = stream_configure_connected_to_endpoint(ep_ffa, STREAM_CONFIG_KEY_STREAM_ANC_INPUT, (INSTANCE_0_MASK|STREAM_ANC_PATH_FFA_ID));
84200c76:	84 f0 01 40 	r2 = Null + 65537;
84200c7a:	03 f0 01 61 	r1 = Null + 4353;
84200c7e:	3a 00       	r0 = r5 + Null;
84200c80:	ff fd 37 f0 	call (m) 0x7bf6;
84200c84:	37 eb 
                status_check = stream_configure_connected_to_endpoint(ep_ffa, STREAM_CONFIG_KEY_STREAM_ANC_INPUT, (INSTANCE_1_MASK|STREAM_ANC_PATH_FFA_ID));
84200c86:	04 f1 01 40 	r2 = Null + 131073;
84200c8a:	03 f0 01 61 	r1 = Null + 4353;
84200c8e:	3a 00       	r0 = r5 + Null;
84200c90:	ff fd 37 f0 	call (m) 0x7bf6;
84200c94:	27 eb 

84200c96 <Lc_anc_tuning_set_parameters_68>:
            }
            if (is_ffb_en)
84200c96:	49 d8       	rMAC = M[FP + 36];
84200c98:	11 60       	if EQ jump (m) Lc_anc_tuning_set_parameters_70;

84200c9a <Lc_anc_tuning_set_parameters_69>:
            {
            /* FFb Mic end point is connected to FFb path in ANC 0 and ANC 1*/
                status_check = stream_configure_connected_to_endpoint(ep_ffb, STREAM_CONFIG_KEY_STREAM_ANC_INPUT, (INSTANCE_0_MASK|STREAM_ANC_PATH_FFB_ID));
84200c9a:	84 f0 02 40 	r2 = Null + 65538;
84200c9e:	03 f0 01 61 	r1 = Null + 4353;
84200ca2:	42 08       	r0 = r6 + Null;
84200ca4:	ff fd 37 f0 	call (m) 0x7bf6;
84200ca8:	33 ea 
                status_check = stream_configure_connected_to_endpoint(ep_ffb, STREAM_CONFIG_KEY_STREAM_ANC_INPUT, (INSTANCE_1_MASK|STREAM_ANC_PATH_FFB_ID));
84200caa:	04 f1 02 40 	r2 = Null + 131074;
84200cae:	03 f0 01 61 	r1 = Null + 4353;
84200cb2:	42 08       	r0 = r6 + Null;
84200cb4:	ff fd 37 f0 	call (m) 0x7bf6;
84200cb8:	23 ea 

84200cba <Lc_anc_tuning_set_parameters_70>:
             * configure a connected_to endpoint and
             * using a shim layer that provides an interface between the ANC hardware
             * and this capability.
             */
            anc_inst_ptr = (ANC_INST_PARAMS*)(&p_ext_data->
                           anc_tuning_cap_params.OFFSET_ANC_USECASE_R);
84200cba:	a6 f0 84 21 	r4 = r8 + 388;

84200cbe <Lc_anc_tuning_set_parameters_71>:
    {
        (void) stream_anc_configure_input(ep_ffb, STREAM_ANC_PATH_FFB_ID);
    }
    while(num_anc_instances)
    {
         num_anc_instances--;
84200cbe:	03 f0 b1 f3 	rMAC = r9 + 65535;
84200cc2:	ff 3b 
    }
    if (is_ffb_en)
    {
        (void) stream_anc_configure_input(ep_ffb, STREAM_ANC_PATH_FFB_ID);
    }
    while(num_anc_instances)
84200cc4:	1b f7 ff 1f 	r9 = rMAC AND 0xffff;
84200cc8:	f1 ff b3 ea 	if NE jump (m) Lc_anc_tuning_set_parameters_43;

84200ccc <Lc_anc_tuning_set_parameters_72>:
                           anc_tuning_cap_params.OFFSET_ANC_USECASE_R);
         } 

    }
  
    return anc_enable_flag;
84200ccc:	62 d8       	r0 = M[FP + 48];

84200cce <Lc_anc_tuning_set_parameters_73>:
}
84200cce:	74 4c       	SP = SP + -48;
84200cd0:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200cd2:	d8 4c       	rts;

84200cd4 <$_anc_tuning_enable_wrapper>:
    stream_anc_set_anc_tune(anc_instance, decimation_chain_input);
#endif
}

void anc_tuning_enable_wrapper(uint16 inst0, uint16 inst1)
{
84200cd4:	c8 1c       	pushm <FP(=SP), rLink>;
84200cd6:	11 00       	rMAC = r0 + Null;
#if defined (NO_ANC_TUNING_PATCHES)
        stream_anc_enable_wrapper(0,inst0,inst1,anc_tuning_dummy_callback);
84200cd8:	42 f0 05 f0 	r3 = Null + 69209327;
84200cdc:	ef 58 
84200cde:	02 00       	r0 = Null + Null;
84200ce0:	1c 00       	r2 = r1 + Null;
84200ce2:	0b 00       	r1 = rMAC + Null;
84200ce4:	ff fd 5a f0 	call (m) 0xc14a;
84200ce8:	27 e3 

84200cea <Lc_anc_tuning_enable_wrapper_2>:
        params.anc_enable_1 = inst1;
        params.resp_callback = anc_tuning_dummy_callback;

        stream_anc_user1((void*)&params);
#endif
}
84200cea:	c8 48       	popm <FP, rLink>;
84200cec:	d8 4c       	rts;

84200cee <Lc_anc_tuning_dummy_callback_1>:
 */
bool blicenceComp=FALSE;

static bool anc_tuning_dummy_callback(unsigned dummy_con_id, STATUS_KYMERA dummy_status)
{
    blicenceComp = TRUE;
84200cee:	41 20       	rMAC = Null + 1;
84200cf0:	e0 f0 01 f0 	M[Null + $_blicenceComp] = rMAC;
84200cf4:	2a 8e 
    return TRUE;
84200cf6:	0a 00       	r0 = rMAC + Null;

84200cf8 <Lc_anc_tuning_dummy_callback_2>:
84200cf8:	d8 4c       	rts;

84200cfa <Lc_ups_params_anc_tuning_1>:
    return TRUE;
}

static bool ups_params_anc_tuning(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                 uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
84200cfa:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200cfc:	2e 00       	r4 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline ANC_TUNING_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (ANC_TUNING_OP_DATA *) base_op_get_instance_data(op_data);
84200cfe:	ef fd fb ff 	call (m) 0x4e6;
84200d02:	29 ef 
84200d04:	17 00       	r5 = r0 + Null;
static bool ups_params_anc_tuning(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                 uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
    ANC_TUNING_OP_DATA *p_ext_data = get_instance_data((OPERATOR_DATA*)instance_data);

    cpsSetParameterFromPsStore(&p_ext_data->params_def,length,data,status);
84200d06:	e5 d5       	r3 = MHS[FP + -8];
84200d08:	fc d9       	r2 = M[FP + -4];
84200d0a:	33 00       	r1 = r4 + Null;
84200d0c:	ef fd fe ff 	call (m) 0xa0a;
84200d10:	3f e7 

    /* Set the Reinit flag after setting the paramters */
    p_ext_data->ReInitFlag = 1;
84200d12:	41 20       	rMAC = Null + 1;
84200d14:	71 f0 bd 8e 	M[r5 + 756] = rMAC;

    return(TRUE);
84200d18:	0a 00       	r0 = rMAC + Null;

84200d1a <Lc_ups_params_anc_tuning_2>:
}
84200d1a:	f2 48       	popm <FP, r4, r5, rLink>;
84200d1c:	d8 4c       	rts;

84200d1e <$_ANC_TUNING_GetDefaults>:
   0x00000000u,			// FF_B_DCFLT_SHIFT_R
   0x00000000u			// SM_LPF_SHIFT_R
};

unsigned *ANC_TUNING_GetDefaults(unsigned capid){
	switch(capid){
84200d1e:	20 f0 b2 24 	Null = r0 - 178;
84200d22:	05 60       	if EQ jump (m) Lc_ANC_TUNING_GetDefaults_3;

84200d24 <Lc_ANC_TUNING_GetDefaults_2>:
84200d24:	01 f0 20 f0 	Null = r0 - 16514;
84200d28:	82 24 
84200d2a:	05 62       	if NE jump (m) Lc_ANC_TUNING_GetDefaults_4;

84200d2c <Lc_ANC_TUNING_GetDefaults_3>:
		case 0x00B2: return defaults_anc_tuningANC_TUNING;
84200d2c:	f8 ff 02 f0 	r0 = Null + -8388604;
84200d30:	04 40 
84200d32:	02 6e       	jump (m) Lc_ANC_TUNING_GetDefaults_5;

84200d34 <Lc_ANC_TUNING_GetDefaults_4>:
		case 0x4082: return defaults_anc_tuningANC_TUNING;
	}
	return((unsigned *)0);
84200d34:	02 00       	r0 = Null + Null;

84200d36 <Lc_ANC_TUNING_GetDefaults_5>:
84200d36:	d8 4c       	rts;

84200d38 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_anc_tuning_cap_data;
84200d38:	07 f0 02 f0 	r0 = Null + 7340032;
84200d3c:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84200d3e:	20 f0 f8 42 	Null = Null + 17144;
